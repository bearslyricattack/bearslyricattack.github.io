<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ClickHouse</title>
    <url>/2023/04/28/ClickHouse/</url>
    <content><![CDATA[<h1 id="ClickHouse"><a href="#ClickHouse" class="headerlink" title="ClickHouse:"></a>ClickHouse:</h1><p>一款查询引擎.</p>
<h1 id="1-数据库基本概念"><a href="#1-数据库基本概念" class="headerlink" title="1.数据库基本概念:"></a>1.数据库基本概念:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095032.png" alt="QQ截图20230301095032"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095221.png" alt="QQ截图20230301095221"></p>
<h2 id="1-1分类"><a href="#1-1分类" class="headerlink" title="1.1分类:"></a>1.1分类:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095333.png" alt="QQ截图20230301095333"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095426.png" alt="QQ截图20230301095426"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095500.png" alt="QQ截图20230301095500"></p>
<h2 id="1-2-OLAP数据库"><a href="#1-2-OLAP数据库" class="headerlink" title="1.2 OLAP数据库:"></a>1.2 OLAP数据库:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095547.png" alt="QQ截图20230301095547"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095724.png" alt="QQ截图20230301095724"></p>
<h2 id="1-3-sql"><a href="#1-3-sql" class="headerlink" title="1.3 sql:"></a>1.3 sql:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095816.png" alt="QQ截图20230301095816"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301095833.png" alt="QQ截图20230301095833"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100008.png" alt="QQ截图20230301100008"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100111.png" alt="QQ截图20230301100111"></p>
<h2 id="1-4-数据库架构"><a href="#1-4-数据库架构" class="headerlink" title="1.4 数据库架构:"></a>1.4 数据库架构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100203.png" alt="QQ截图20230301100203"></p>
<h3 id="1-4-1解释器"><a href="#1-4-1解释器" class="headerlink" title="1.4.1解释器:"></a>1.4.1解释器:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100321.png" alt="QQ截图20230301100321"></p>
<h3 id="1-4-2分析器"><a href="#1-4-2分析器" class="headerlink" title="1.4.2分析器:"></a>1.4.2分析器:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100359.png" alt="QQ截图20230301100359"></p>
<h3 id="1-4-3优化器"><a href="#1-4-3优化器" class="headerlink" title="1.4.3优化器:"></a>1.4.3优化器:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100511.png" alt="QQ截图20230301100511"></p>
<p>把ast变成一个一个的算子(执行计划).</p>
<h3 id="1-4-4执行引擎"><a href="#1-4-4执行引擎" class="headerlink" title="1.4.4执行引擎:"></a>1.4.4执行引擎:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100611.png" alt="QQ截图20230301100611"></p>
<h3 id="1-4-5存储引擎"><a href="#1-4-5存储引擎" class="headerlink" title="1.4.5存储引擎:"></a>1.4.5存储引擎:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100659.png" alt="QQ截图20230301100659"></p>
<h1 id="2-列式存储"><a href="#2-列式存储" class="headerlink" title="2.列式存储:"></a>2.列式存储:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100818.png" alt="QQ截图20230301100818"></p>
<h2 id="2-1-行式存储与列式存储"><a href="#2-1-行式存储与列式存储" class="headerlink" title="2.1 行式存储与列式存储:"></a>2.1 行式存储与列式存储:</h2><p>行式存储:每一行的顺序,连续的写到存储介质当中去.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301100929.png" alt="QQ截图20230301100929"></p>
<p>列式存储:一列一列的写入.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101022.png" alt="QQ截图20230301101022"></p>
<h2 id="2-2-列式存储的优点"><a href="#2-2-列式存储的优点" class="headerlink" title="2.2 列式存储的优点:"></a>2.2 列式存储的优点:</h2><h3 id="2-2-1-数据压缩"><a href="#2-2-1-数据压缩" class="headerlink" title="2.2.1 数据压缩:"></a>2.2.1 数据压缩:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101148.png" alt="QQ截图20230301101148"></p>
<p>比如主键在列上存储有某种规律(递增).</p>
<h4 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法:"></a>压缩算法:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101241.png" alt="QQ截图20230301101241"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101330.png" alt="QQ截图20230301101330"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101418.png" alt="QQ截图20230301101418"></p>
<h3 id="2-2-2-聚合计算："><a href="#2-2-2-聚合计算：" class="headerlink" title="2.2.2 聚合计算："></a>2.2.2 聚合计算：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101459.png" alt="QQ截图20230301101459"></p>
<h3 id="2-2-3-延迟物化："><a href="#2-2-3-延迟物化：" class="headerlink" title="2.2.3 延迟物化："></a>2.2.3 延迟物化：</h3><p>把一种数据格式变成另一种数据格式。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101619.png" alt="QQ截图20230301101619"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101718.png" alt="QQ截图20230301101718"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101806.png" alt="QQ截图20230301101806"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301101847.png" alt="QQ截图20230301101847"></p>
<h3 id="2-2-4-向量化："><a href="#2-2-4-向量化：" class="headerlink" title="2.2.4 向量化："></a>2.2.4 向量化：</h3><p>解释：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301102311.png" alt="QQ截图20230301102311"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301102428.png" alt="QQ截图20230301102428"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301102512.png" alt="QQ截图20230301102512"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301145624.png" alt="QQ截图20230301145624"></p>
<h2 id="2-3-优缺点分析"><a href="#2-3-优缺点分析" class="headerlink" title="2.3 优缺点分析:"></a>2.3 优缺点分析:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301193053.png" alt="QQ截图20230301193053"></p>
<h1 id="3-存储设计"><a href="#3-存储设计" class="headerlink" title="3.存储设计:"></a>3.存储设计:</h1><h2 id="3-1-表定义和结构"><a href="#3-1-表定义和结构" class="headerlink" title="3.1 表定义和结构:"></a>3.1 表定义和结构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301193925.png" alt="QQ截图20230301193925"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194207.png" alt="QQ截图20230301194207"></p>
<p>distable不存储数据,相当于view的功能.</p>
<p>localtable存储数据.</p>
<h2 id="3-2-引擎架构"><a href="#3-2-引擎架构" class="headerlink" title="3.2 引擎架构:"></a>3.2 引擎架构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194359.png" alt="QQ截图20230301194359"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194533.png" alt="QQ截图20230301194533"></p>
<p>bin存储数据,mrk存储索引.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194648.png" alt="QQ截图20230301194648"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194736.png" alt="QQ截图20230301194736"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194801.png" alt="QQ截图20230301194801"></p>
<h2 id="3-3-索引设计"><a href="#3-3-索引设计" class="headerlink" title="3.3 索引设计:"></a>3.3 索引设计:</h2><h3 id="3-3-1-hash-index"><a href="#3-3-1-hash-index" class="headerlink" title="3.3.1 hash index:"></a>3.3.1 hash index:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194820.png" alt="QQ截图20230301194820"></p>
<h3 id="3-3-2-b-tree"><a href="#3-3-2-b-tree" class="headerlink" title="3.3.2 b-tree:"></a>3.3.2 b-tree:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301194859.png" alt="QQ截图20230301194859"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301195006.png" alt="QQ截图20230301195006"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301195155.png" alt="QQ截图20230301195155"></p>
<h3 id="3-3-3-LSM-tree"><a href="#3-3-3-LSM-tree" class="headerlink" title="3.3.3 LSM tree:"></a>3.3.3 LSM tree:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301195321.png" alt="QQ截图20230301195321"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301195347.png" alt="QQ截图20230301195347"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301195533.png" alt="QQ截图20230301195533"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301195632.png" alt="QQ截图20230301195632"></p>
<p>稀疏索引:一些特定的数据,用于缩小查找范围.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301195740.png" alt="QQ截图20230301195740"></p>
<h2 id="3-4-索引实现"><a href="#3-4-索引实现" class="headerlink" title="3.4 索引实现:"></a>3.4 索引实现:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301200018.png" alt="QQ截图20230301200018"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301200038.png" alt="QQ截图20230301200038"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301200107.png" alt="QQ截图20230301200107"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301200229.png" alt="QQ截图20230301200229"></p>
<p>普通的mark都存储的是这个mark中的最小值,但是由于最后一个mark并没有装满,为了获得确定的区间,primaryindex存储的是所有数据的最大值.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301200436.png" alt="QQ截图20230301200436"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201204.png" alt="QQ截图20230301201204"></p>
<p>优化:二级索引:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201427.png" alt="QQ截图20230301201427"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201535.png" alt="QQ截图20230301201535"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201615.png" alt="QQ截图20230301201615"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201638.png" alt="QQ截图20230301201638"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201729.png" alt="QQ截图20230301201729"></p>
<h2 id="3-5-数据合并"><a href="#3-5-数据合并" class="headerlink" title="3.5 数据合并:"></a>3.5 数据合并:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201804.png" alt="QQ截图20230301201804"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301201915.png" alt="QQ截图20230301201915"></p>
<h2 id="3-6-数据查询"><a href="#3-6-数据查询" class="headerlink" title="3.6 数据查询:"></a>3.6 数据查询:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202034.png" alt="QQ截图20230301202034"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202042.png" alt="QQ截图20230301202042"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202132.png" alt="QQ截图20230301202132"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202203.png" alt="QQ截图20230301202203"></p>
<h1 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4.应用场景:"></a>4.应用场景:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202248.png" alt="QQ截图20230301202248"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202359.png" alt="QQ截图20230301202359"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202449.png" alt="QQ截图20230301202449"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202542.png" alt="QQ截图20230301202542"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202720.png" alt="QQ截图20230301202720"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202809.png" alt="QQ截图20230301202809"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301202916.png" alt="QQ截图20230301202916"></p>
<p>map:kv.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301203027.png" alt="QQ截图20230301203027"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301203145.png" alt="QQ截图20230301203145"></p>
<h1 id="5-总结："><a href="#5-总结：" class="headerlink" title="5.总结："></a>5.总结：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230301203304.png" alt="QQ截图20230301203304"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2023/03/13/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h1 id="1-Git介绍"><a href="#1-Git介绍" class="headerlink" title="1.Git介绍:"></a>1.Git介绍:</h1><p>git是一个版本控制软件，是可以在你电脑不联网的情况下，只在本地使用的一个版本管理工具，其作用就是可以让你更好的管理你的程序，比如你原来提交过的内容，以后虽然修改了，但是通过git这个工具，可以把你原来提交的内容重现出来，这样对于你后来才意识到的一些错误的更改，可以进行还原。</p>
<p>一个版本控制的通俗易懂例子:</p>
<p>[(121条消息) （一）Git和Github介绍_如筏喻者的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_40634003/article/details/122977154?ops_request_misc=%7B%22request_id%22:%22167860762916800192216681%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167860762916800192216681&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-122977154-null-null.142%5Ev73%5Econtrol,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=git">https://blog.csdn.net/weixin_40634003/article/details/122977154?ops_request_misc=%7B%22request%5Fid%22%3A%22167860762916800192216681%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=167860762916800192216681&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-122977154-null-null.142^v73^control,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=git</a> 和github&amp;spm&#x3D;1018.2226.3001.4187)</p>
<h2 id="1-1-版本控制软件类型"><a href="#1-1-版本控制软件类型" class="headerlink" title="1.1 版本控制软件类型:"></a>1.1 版本控制软件类型:</h2><h3 id="1-1-1-本地版本："><a href="#1-1-1-本地版本：" class="headerlink" title="1.1.1 本地版本："></a>1.1.1 本地版本：</h3><p>单机运行，使维护文件版本的操作工具化.<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/dcad420a312545c4a9e8c5f428dce96e.png" alt="dcad420a312545c4a9e8c5f428dce96e"></p>
<h3 id="1-1-2-集中式"><a href="#1-1-2-集中式" class="headerlink" title="1.1.2 集中式:"></a>1.1.2 集中式:</h3><p>集中化的版本控制系统：联网运行，支持多人协作开发;性能差、用户体验不好.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/efc7fffb3b1549178a68b0b9955ac1b7.png" alt="efc7fffb3b1549178a68b0b9955ac1b7"></p>
<h3 id="1-1-3-分布式"><a href="#1-1-3-分布式" class="headerlink" title="1.1.3 分布式:"></a>1.1.3 分布式:</h3><p>联网运行，支持多人协作开发;性能优秀、用户体验好.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/99b3f17afa124a8eb76a9a738cdb823b.png" alt="99b3f17afa124a8eb76a9a738cdb823b"></p>
<p>这里的分布式是指本机和服务器互相备份,与一般传统意义上的分布式全在服务端有所区别.</p>
<h2 id="1-2-Git特性"><a href="#1-2-Git特性" class="headerlink" title="1.2 Git特性:"></a>1.2 Git特性:</h2><h3 id="1-2-1-保存方式"><a href="#1-2-1-保存方式" class="headerlink" title="1.2.1 保存方式:"></a>1.2.1 保存方式:</h3><p>svn是保存一份原始的本地文件和改动.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/4e37806678b24531a8e2df05a7eee5d9.png" alt="4e37806678b24531a8e2df05a7eee5d9"></p>
<p>而git是保存每一次的完整的文件快照.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/c8fde5b0098740dfb5c9188992e9972c-1678676269145-10.png" alt="c8fde5b0098740dfb5c9188992e9972c"></p>
<p>就像使用了数据库索引一样,增加了读性能而略微牺牲了写性能.</p>
<h3 id="1-2-2-分区"><a href="#1-2-2-分区" class="headerlink" title="1.2.2 分区:"></a>1.2.2 分区:</h3><p>使用Git管理的项目，拥有三个区域，分别是工作区、暂存区、Git仓库。</p>
<p>工作区：我们书写代码的地方，工作的目录就叫工作区。</p>
<p>暂存区：暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。</p>
<p>本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本.</p>
<p><img src="C:\Users\wpy\Desktop\blog\source\images\Git\QQ截图20230313110157.png" alt="QQ截图20230313110157"></p>
<h2 id="1-3-Git与Github"><a href="#1-3-Git与Github" class="headerlink" title="1.3 Git与Github:"></a>1.3 Git与Github:</h2><p>GitHub 与 Git 是完全不同的两个东西。<br>在 Git 中，开发者将源代码存入名叫“Git 仓库”的资料库中并加以使用。而 GitHub 则是在网络上提供 Git 仓库的一项服务。</p>
<p>Git 仓库管理功能是 GitHub 的核心。因此，使用 GitHub 之前必须先掌握 Git 的相关知识，同时本地的设备还要安装 Git 的环境。</p>
<p>GitHub 上公开的软件源代码全都由 Git 进行管理且只支持用 Git 进行管理。<br>先有 Git，再有 Github，是 Github 傍 Git 大腿发展起来的，而不是 Git 傍 GitHub 大腿。</p>
<h1 id="2-Git使用"><a href="#2-Git使用" class="headerlink" title="2.Git使用:"></a>2.Git使用:</h1><h2 id="2-1-Git协作模式"><a href="#2-1-Git协作模式" class="headerlink" title="2.1 Git协作模式:"></a>2.1 Git协作模式:</h2><h3 id="2-1-1-团队协作"><a href="#2-1-1-团队协作" class="headerlink" title="2.1.1 团队协作:"></a>2.1.1 团队协作:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/20200209195719928.png" alt="20200209195719928"></p>
<h3 id="2-1-2-非团队协作"><a href="#2-1-2-非团队协作" class="headerlink" title="2.1.2 非团队协作:"></a>2.1.2 非团队协作:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/20200210121426442.png" alt="20200210121426442"></p>
<h2 id="2-2-分支"><a href="#2-2-分支" class="headerlink" title="2.2 分支:"></a>2.2 分支:</h2><p>在进行多人协作开发的时候，为了防止互相干扰，提高协同开发的体验，建议每个开发者都基于分支进行项目功能的开发，例如:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/598d123ef5ab439e8275acbf16baeb45.png" alt="598d123ef5ab439e8275acbf16baeb45"></p>
<h2 id="2-3-Git下载安装"><a href="#2-3-Git下载安装" class="headerlink" title="2.3 Git下载安装:"></a>2.3 Git下载安装:</h2><p>参看<a href="https://blog.csdn.net/weixin_47638941/article/details/120632890?ops_request_misc=%7B%22request_id%22:%22167867670516782427458948%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=167867670516782427458948&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120632890-null-null.142%5Ev73%5Econtrol,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=git%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">(121条消息) Git的下载安装 (图文教程)<em>git下载安装</em>@memory的博客-CSDN博客</a></p>
<h2 id="2-4-Git使用"><a href="#2-4-Git使用" class="headerlink" title="2.4 Git使用:"></a>2.4 Git使用:</h2><p><a href="https://juejin.cn/post/6844903924458078221#heading-3">Github使用教程图文详解 - 掘金 (juejin.cn)</a></p>
<p><a href="https://juejin.cn/post/7002456806198870023#heading-9">谈谈git与github使用 - 掘金 (juejin.cn)</a></p>
<h3 id="2-4-1-第一次使用"><a href="#2-4-1-第一次使用" class="headerlink" title="2.4.1 第一次使用:"></a>2.4.1 第一次使用:</h3><p>新建文件夹,执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//初始化git仓库</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>然后连接到远程仓库:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//为仓库起别名,并连接</span><br><span class="line">git remote add 别名 地址</span><br><span class="line">git remote add origin https://github.com/bearslyricattack/demo.git</span><br><span class="line">//创建自己的分支</span><br><span class="line">git checkout -b 分支名</span><br><span class="line">git checkout -b wpy_dev</span><br><span class="line">//从主分支上拉取下代码</span><br><span class="line">git pull 别名 分支名</span><br><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230313113241.png" alt="QQ截图20230313113241"></p>
<p>拉取下代码后,进行本地开发,在开发完成后,把开发完成的新代码放到这个文件夹下,然后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//由工作区添加到暂存区</span><br><span class="line">git add --all</span><br><span class="line">//由暂存区提交到仓库</span><br><span class="line">git commit -m &quot;&quot;</span><br><span class="line">&quot;&quot;里面是提交日志,生成的是版本号</span><br><span class="line">//提交到github</span><br><span class="line">git push 别名 分支名</span><br><span class="line">git push origin wpy_dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230313113330.png" alt="QQ截图20230313113330"></p>
<p>然后在登录github进行分支合并就可以了.</p>
<h3 id="2-4-2-以后使用"><a href="#2-4-2-以后使用" class="headerlink" title="2.4.2 以后使用:"></a>2.4.2 以后使用:</h3><p>只需要先pull,然后按照上面的流程继续即可.</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang</title>
    <url>/2023/01/17/Golang/</url>
    <content><![CDATA[<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang:"></a>Golang:</h1><h1 id="1-Golang简介"><a href="#1-Golang简介" class="headerlink" title="1.Golang简介:"></a>1.Golang简介:</h1><h2 id="1-1Golang优点"><a href="#1-1Golang优点" class="headerlink" title="1.1Golang优点:"></a>1.1Golang优点:</h2><p>1.高性能,高并发.python有性能问题.</p>
<p>2.语法简单,上手容易.类似于C语言的风格.</p>
<p>3.标准库</p>
<p>4.工具链</p>
<p>5.静态链接</p>
<p>6.快速编译</p>
<p>7.跨平台</p>
<p>8.垃圾回收</p>
<h2 id="1-2Golang入门"><a href="#1-2Golang入门" class="headerlink" title="1.2Golang入门:"></a>1.2Golang入门:</h2><h3 id="1-2-1-配置环境"><a href="#1-2-1-配置环境" class="headerlink" title="1.2.1 配置环境:"></a>1.2.1 配置环境:</h3><p>1.安装golang</p>
<p>2.配置集成开发环境</p>
<h3 id="1-2-2-基础语法"><a href="#1-2-2-基础语法" class="headerlink" title="1.2.2 基础语法:"></a>1.2.2 基础语法:</h3><h4 id="1-2-2-1-Hello-World"><a href="#1-2-2-1-Hello-World" class="headerlink" title="1.2.2.1 Hello World:"></a>1.2.2.1 Hello World:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-2-变量与常量："><a href="#1-2-2-2-变量与常量：" class="headerlink" title="1.2.2.2 变量与常量："></a>1.2.2.2 变量与常量：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//两种声明变量的方式</span><br><span class="line">//自动转换类型</span><br><span class="line">var a = &quot;123&quot;</span><br><span class="line">var b = 1</span><br><span class="line">//也可以显式的指出类型</span><br><span class="line">var d string = &quot;123&quot;</span><br><span class="line">var e = float64()</span><br><span class="line">//第二种</span><br><span class="line">f := float32(e)</span><br><span class="line">//常量就是把var换成const,常量没有确定的类型,根据上下文确定</span><br><span class="line">const a = &quot;123&quot;</span><br><span class="line">const v = 1</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-3-if-else"><a href="#1-2-2-3-if-else" class="headerlink" title="1.2.2.3 if-else:"></a>1.2.2.3 if-else:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	if 7%2 == 0 &#123;</span><br><span class="line">		fmt.Println(&quot;123&quot;)</span><br><span class="line">	&#125;else if 7%2 == 1&#123;</span><br><span class="line">		fmt.Println(&quot;456&quot;)</span><br><span class="line">	&#125;else 7%2 == 2&#123;</span><br><span class="line">		fmt.Println(&quot;789&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">没有括号,第一个大括号必须写在同一行内</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-4-for"><a href="#1-2-2-4-for" class="headerlink" title="1.2.2.4 for:"></a>1.2.2.4 for:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for j:=7;j&lt;9;j++&#123;</span><br><span class="line">   fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line">只有for循环</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-5-数组"><a href="#1-2-2-5-数组" class="headerlink" title="1.2.2.5 数组:"></a>1.2.2.5 数组:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var zu[5] int</span><br><span class="line">zu[4]=1</span><br><span class="line">固定长度</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-6-切片"><a href="#1-2-2-6-切片" class="headerlink" title="1.2.2.6 切片:"></a>1.2.2.6 切片:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m := make([]string,3)</span><br><span class="line">m[0]=&quot;123&quot;</span><br><span class="line">m = append(m,&quot;456&quot;)</span><br><span class="line">随意更改大小,使用append时必须返回其原值.</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-7-字典-key-value对"><a href="#1-2-2-7-字典-key-value对" class="headerlink" title="1.2.2.7 字典(key-value对):"></a>1.2.2.7 字典(key-value对):</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一个是key,第二个是value</span><br><span class="line">m:=make(map[string]int)</span><br><span class="line">m[&quot;123&quot;] =1</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-8-函数"><a href="#1-2-2-8-函数" class="headerlink" title="1.2.2.8 函数:"></a>1.2.2.8 函数:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func add1(a int,b int)(int,int)  &#123;</span><br><span class="line">   return a+b,a-b</span><br><span class="line">&#125;</span><br><span class="line">可以返回多个值</span><br><span class="line">当不需要要返回时,可使用a,_=add1(a,b)这样的格式</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-9-指针"><a href="#1-2-2-9-指针" class="headerlink" title="1.2.2.9 指针:"></a>1.2.2.9 指针:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func add(a *int)  &#123;</span><br><span class="line">   *a+=2</span><br><span class="line">&#125;</span><br><span class="line">调用的时候要加入取地址符号:&amp;a</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-10-结构体"><a href="#1-2-2-10-结构体" class="headerlink" title="1.2.2.10 结构体:"></a>1.2.2.10 结构体:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">   username string</span><br><span class="line">   password string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">   var a user</span><br><span class="line">   a.username = &quot;123&quot;</span><br><span class="line">   a.password = &quot;456&quot;</span><br><span class="line">   b := user&#123;username: &quot;123&quot;, password: &quot;456&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">访问时也可以使用指针访问,有时候可以避免大结构体重复拷贝的开销.</span><br><span class="line"></span><br><span class="line">结构体方法:</span><br><span class="line">type user struct &#123;</span><br><span class="line">	username string</span><br><span class="line">	password string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (u user)checkPassword(password string) bool  &#123;</span><br><span class="line">	return u.password ==password</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	var a user</span><br><span class="line">	a.username = &quot;123&quot;</span><br><span class="line">	a.password = &quot;456&quot;</span><br><span class="line">	b := user&#123;username: &quot;123&quot;, password: &quot;456&quot;&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	a.checkPassword(&quot;123&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-11-错误处理"><a href="#1-2-2-11-错误处理" class="headerlink" title="1.2.2.11: 错误处理:"></a>1.2.2.11: 错误处理:</h4><p>使用单独的返回值配合各种简单语句来处理错误信息.</p>
<p>简单的异常处理示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func add(a int,b int)(c int,d int)  &#123;</span><br><span class="line">   if a!=b&#123;</span><br><span class="line">      return a+b,0</span><br><span class="line">   &#125;</span><br><span class="line">   return a+b,a-b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">   var a = 1</span><br><span class="line">   var b = 2</span><br><span class="line">   var c int</span><br><span class="line">   var d int</span><br><span class="line">   c,d =add(a,b)</span><br><span class="line">   if d==0 &#123;</span><br><span class="line">      fmt.Println(a)</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">      fmt.Println(c)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-12-字符串操作"><a href="#1-2-2-12-字符串操作" class="headerlink" title="1.2.2.12: 字符串操作:"></a>1.2.2.12: 字符串操作:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">   var a = 1</span><br><span class="line">   println(&quot;s=%v&quot;,a)</span><br><span class="line">&#125;</span><br><span class="line">%v可以打印任意类型的变量</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-13-JSON处理"><a href="#1-2-2-13-JSON处理" class="headerlink" title="1.2.2.13:JSON处理:"></a>1.2.2.13:JSON处理:</h4><p>只要结构体任意属性的首字符都是大写,就可以使用json.Marshal(结构体名)来进行序列化,</p>
<p>然后使用string()强转后输出.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type DictRequest struct &#123;</span><br><span class="line">   TransType string `json:&quot;trans_type&quot;`</span><br><span class="line">   Source    string `json:&quot;source&quot;`</span><br><span class="line">&#125;</span><br><span class="line">也可以在定义结构体的时候手动的增添tag,这样生成结构体之后就会变成指定的名字.</span><br><span class="line">request := DictRequest&#123;TransType: &quot;en2zh&quot;, Source: &quot;good&quot;&#125;</span><br><span class="line">buf, err := json.Marshal(request)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-实战项目"><a href="#1-4-实战项目" class="headerlink" title="1.4 实战项目:"></a>1.4 实战项目:</h3><h4 id="1-4-1-在线翻译"><a href="#1-4-1-在线翻译" class="headerlink" title="1.4.1 在线翻译:"></a>1.4.1 在线翻译:</h4><p>调用彩云小译的api,获取返回值之后再控制台显示.完整代码以及部分注释如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;bytes&quot;</span><br><span class="line">   &quot;encoding/json&quot;</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;io/ioutil&quot;</span><br><span class="line">   &quot;log&quot;</span><br><span class="line">   &quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type DictRequest struct &#123;</span><br><span class="line">   TransType string `json:&quot;trans_type&quot;`</span><br><span class="line">   Source    string `json:&quot;source&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type DictResponse struct &#123;</span><br><span class="line">   Rc   int `json:&quot;rc&quot;`</span><br><span class="line">   Wiki struct &#123;</span><br><span class="line">      KnownInLaguages int `json:&quot;known_in_laguages&quot;`</span><br><span class="line">      Description     struct &#123;</span><br><span class="line">         Source string      `json:&quot;source&quot;`</span><br><span class="line">         Target interface&#123;&#125; `json:&quot;target&quot;`</span><br><span class="line">      &#125; `json:&quot;description&quot;`</span><br><span class="line">      ID   string `json:&quot;id&quot;`</span><br><span class="line">      Item struct &#123;</span><br><span class="line">         Source string `json:&quot;source&quot;`</span><br><span class="line">         Target string `json:&quot;target&quot;`</span><br><span class="line">      &#125; `json:&quot;item&quot;`</span><br><span class="line">      ImageURL  string `json:&quot;image_url&quot;`</span><br><span class="line">      IsSubject string `json:&quot;is_subject&quot;`</span><br><span class="line">      Sitelink  string `json:&quot;sitelink&quot;`</span><br><span class="line">   &#125; `json:&quot;wiki&quot;`</span><br><span class="line">   Dictionary struct &#123;</span><br><span class="line">      Prons struct &#123;</span><br><span class="line">         EnUs string `json:&quot;en-us&quot;`</span><br><span class="line">         En   string `json:&quot;en&quot;`</span><br><span class="line">      &#125; `json:&quot;prons&quot;`</span><br><span class="line">      Explanations []string      `json:&quot;explanations&quot;`</span><br><span class="line">      Synonym      []string      `json:&quot;synonym&quot;`</span><br><span class="line">      Antonym      []string      `json:&quot;antonym&quot;`</span><br><span class="line">      WqxExample   [][]string    `json:&quot;wqx_example&quot;`</span><br><span class="line">      Entry        string        `json:&quot;entry&quot;`</span><br><span class="line">      Type         string        `json:&quot;type&quot;`</span><br><span class="line">      Related      []interface&#123;&#125; `json:&quot;related&quot;`</span><br><span class="line">      Source       string        `json:&quot;source&quot;`</span><br><span class="line">   &#125; `json:&quot;dictionary&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func query(word string) &#123;</span><br><span class="line">   client := &amp;http.Client&#123;&#125;</span><br><span class="line">   //var data = strings.NewReader(`&#123;&quot;trans_type&quot;:&quot;en2zh&quot;,&quot;source&quot;:&quot;good&quot;&#125;`)</span><br><span class="line">   //request := DictRequest&#123;TransType: &quot;en2zh&quot;, Source: &quot;good&quot;&#125;</span><br><span class="line">   request := DictRequest&#123;TransType: &quot;en2zh&quot;, Source: word&#125;</span><br><span class="line">   buf, err := json.Marshal(request)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   var data = bytes.NewReader(buf)</span><br><span class="line">   //创建http请求</span><br><span class="line">   req, err := http.NewRequest(&quot;POST&quot;, &quot;https://api.interpreter.caiyunai.com/v1/dict&quot;, data)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   //设置请求头</span><br><span class="line">   req.Header.Set(&quot;authority&quot;, &quot;api.interpreter.caiyunai.com&quot;)</span><br><span class="line">   req.Header.Set(&quot;accept&quot;, &quot;application/json, text/plain, */*&quot;)</span><br><span class="line">   req.Header.Set(&quot;accept-language&quot;, &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;)</span><br><span class="line">   req.Header.Set(&quot;app-name&quot;, &quot;xy&quot;)</span><br><span class="line">   req.Header.Set(&quot;cache-control&quot;, &quot;no-cache&quot;)</span><br><span class="line">   req.Header.Set(&quot;content-type&quot;, &quot;application/json;charset=UTF-8&quot;)</span><br><span class="line">   req.Header.Set(&quot;device-id&quot;, &quot;&quot;)</span><br><span class="line">   req.Header.Set(&quot;origin&quot;, &quot;https://fanyi.caiyunapp.com&quot;)</span><br><span class="line">   req.Header.Set(&quot;os-type&quot;, &quot;web&quot;)</span><br><span class="line">   req.Header.Set(&quot;os-version&quot;, &quot;&quot;)</span><br><span class="line">   req.Header.Set(&quot;pragma&quot;, &quot;no-cache&quot;)</span><br><span class="line">   req.Header.Set(&quot;referer&quot;, &quot;https://fanyi.caiyunapp.com/&quot;)</span><br><span class="line">   req.Header.Set(&quot;sec-ch-ua&quot;, `&quot;Not?A_Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;108&quot;, &quot;Microsoft Edge&quot;;v=&quot;108&quot;`)</span><br><span class="line">   req.Header.Set(&quot;sec-ch-ua-mobile&quot;, &quot;?0&quot;)</span><br><span class="line">   req.Header.Set(&quot;sec-ch-ua-platform&quot;, `&quot;Windows&quot;`)</span><br><span class="line">   req.Header.Set(&quot;sec-fetch-dest&quot;, &quot;empty&quot;)</span><br><span class="line">   req.Header.Set(&quot;sec-fetch-mode&quot;, &quot;cors&quot;)</span><br><span class="line">   req.Header.Set(&quot;sec-fetch-site&quot;, &quot;cross-site&quot;)</span><br><span class="line">   req.Header.Set(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.76&quot;)</span><br><span class="line">   req.Header.Set(&quot;x-authorization&quot;, &quot;token:qgemv4jr1y38jyq6vhvi&quot;)</span><br><span class="line">   //发送请求</span><br><span class="line">   resp, err := client.Do(req)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   defer resp.Body.Close()</span><br><span class="line">   bodyText, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   //防御式编程,校验状态码</span><br><span class="line">   if resp.StatusCode != 200 &#123;</span><br><span class="line">      log.Fatal(&quot;bad StatusCode&quot;, resp.StatusCode, &quot;body&quot;, string(bodyText))</span><br><span class="line">   &#125;</span><br><span class="line">   var dictResponse DictResponse</span><br><span class="line">   err = json.Unmarshal(bodyText, &amp;dictResponse)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   //以最复杂的方式打印</span><br><span class="line">   fmt.Printf(&quot;%#v\n&quot;, dictResponse)</span><br><span class="line"></span><br><span class="line">   fmt.Println(word, &quot;UK:&quot;, dictResponse.Dictionary.Prons.En, dictResponse.Dictionary.Prons.EnUs)</span><br><span class="line">   for _, item := range dictResponse.Dictionary.Explanations &#123;</span><br><span class="line">      fmt.Println(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   //获取程序运行时,给出的参数的数目</span><br><span class="line">   //if len(os.Args) != 2 &#123;</span><br><span class="line">   // fmt.Fprintf(os.Stderr, `usage`)</span><br><span class="line">   // os.Exit(1)</span><br><span class="line">   //&#125;</span><br><span class="line">   //word := os.Args[1]</span><br><span class="line">   var word string</span><br><span class="line">   var n int</span><br><span class="line">   n, _ = fmt.Scan(&amp;word)</span><br><span class="line">   println(n)</span><br><span class="line">   query(word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>http请求是通过网站生成.<a href="https://curlconverter.com/">Convert curl commands to code (curlconverter.com)</a>.在调用网页api中,使用开发者模式找到发送的请求后,复制cURL到这个网站里面,选择语言就能生成这个复杂的请求.</p>
<p>而把json转换成go的结构体也可以通过<a href="https://oktools.net/json2go">JSON转Golang Struct - 在线工具 - OKTools</a>这种代码生成器来进行.</p>
<h4 id="1-4-2-代理"><a href="#1-4-2-代理" class="headerlink" title="1.4.2 代理:"></a>1.4.2 代理:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    //监听一个端口</span><br><span class="line">   server, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:1080&quot;)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      panic(err)</span><br><span class="line">   &#125;</span><br><span class="line">   for &#123;</span><br><span class="line">      //接受请求,返回连接</span><br><span class="line">      client, err := server.Accept()</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         log.Println(&quot;accept falied %v&quot;, err)</span><br><span class="line">         continue</span><br><span class="line">      &#125;</span><br><span class="line">      //启动子线程,处理连接</span><br><span class="line">      go process(client)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">func process(conn net.Conn) &#123;</span><br><span class="line">   //关闭连接</span><br><span class="line">   defer conn.Close()</span><br><span class="line">   //基于连接创建流</span><br><span class="line">   //待缓冲的流</span><br><span class="line">   reader := bufio.NewReader(conn)</span><br><span class="line">   for &#123;</span><br><span class="line">      //读,读的时候看起来是一次读一个,事实上是一次读了非常多.</span><br><span class="line">      b, err := reader.ReadByte()</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         break</span><br><span class="line">      &#125;</span><br><span class="line">      //写</span><br><span class="line">      _, err = conn.Write([]byte&#123;b&#125;)</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         break</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-Golang进阶"><a href="#1-3-Golang进阶" class="headerlink" title="1.3 Golang进阶:"></a>1.3 Golang进阶:</h2><p>Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。</p>
<h3 id="1-3-1-并发与并行"><a href="#1-3-1-并发与并行" class="headerlink" title="1.3.1 并发与并行:"></a>1.3.1 并发与并行:</h3><p>并发是指多个线程在一个核的CPU上运行,并行是指多个线程在多个核的CPU上运行.一般二者统称为并发.</p>
<p>go可以通过调度,充分发挥多核计算机的优势.</p>
<h3 id="1-3-2-协程与线程"><a href="#1-3-2-协程与线程" class="headerlink" title="1.3.2 协程与线程:"></a>1.3.2 协程与线程:</h3><p>协程指的是用户态的轻量级线程,栈kb级别.由go语言自己调度.</p>
<p>线程指的是内核态,一个线程可以跑多个协程,栈mb级别.</p>
<h3 id="1-3-3-协程-Goroutine"><a href="#1-3-3-协程-Goroutine" class="headerlink" title="1.3.3 协程:Goroutine:"></a>1.3.3 协程:Goroutine:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func hello(i int) &#123;</span><br><span class="line">   println(&quot;hello goroutine&quot; + fmt.Sprint(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HelloGoRoutine() &#123;</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      //开启协程 在调用函数的时候使用go 关键字</span><br><span class="line">      go func(j int) &#123;</span><br><span class="line">         hello(j)</span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line">   //阻塞 在协程进行完毕之前,主线程不能退出.</span><br><span class="line">   time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   HelloGoRoutine()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为:</p>
<p>hello goroutine4<br>hello goroutine2<br>hello goroutine1<br>hello goroutine3<br>hello goroutine0</p>
<p>乱序输出,每次结果都有所不同.</p>
<h3 id="1-3-4-协程通信"><a href="#1-3-4-协程通信" class="headerlink" title="1.3.4 协程通信:"></a>1.3.4 协程通信:</h3><p>主要有两种方式.</p>
<h4 id="1-3-4-1-通过通信共享内存"><a href="#1-3-4-1-通过通信共享内存" class="headerlink" title="1.3.4.1 通过通信共享内存:"></a>1.3.4.1 通过通信共享内存:</h4><p>Communicating Sequential Process:通过通道,让一个协程发送特定的值到另一个协程.</p>
<h4 id="1-3-4-2-通过共享内存实现通信"><a href="#1-3-4-2-通过共享内存实现通信" class="headerlink" title="1.3.4.2 通过共享内存实现通信:"></a>1.3.4.2 通过共享内存实现通信:</h4><p>不同的协程直接通过共享一块区域实现通信,但是一定程度上会影响程序的性能,所以不推荐.</p>
<h4 id="1-3-4-3-通道-channel"><a href="#1-3-4-3-通道-channel" class="headerlink" title="1.3.4.3 通道:channel:"></a>1.3.4.3 通道:channel:</h4><p>是一种特殊的数据结构,类似于队列,具有先进先出的特性,分为有缓冲通道和无缓冲通道.</p>
<p>无缓冲时,双方协程数据同步.只有数据被取走才能进入下一个数据.相当于容量为1的通道</p>
<p>有缓冲时,需要协程把通道中的数据取走后,才能得到下一个数据.可以</p>
<p>通道操作是<strong>并发安全</strong>的，在同一时刻，只会执行对同一个通道的任意个发送操作中的某一个，直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。接收操作也一样。另外，对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。</p>
<p>一个通道示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func CalSquare() &#123;</span><br><span class="line">   //无缓冲通道</span><br><span class="line">   src := make(chan int)</span><br><span class="line">   //有缓冲通道</span><br><span class="line">   dest := make(chan int, 3)</span><br><span class="line">   go func() &#123;</span><br><span class="line">   	  //程序结束时关闭</span><br><span class="line">      defer close(src)</span><br><span class="line">      for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">         //把数据发送到src通道中</span><br><span class="line">         src &lt;- i</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   go func() &#123;</span><br><span class="line">      defer close(dest)</span><br><span class="line">      //从src通道中取出数据</span><br><span class="line">      for i := range src &#123;</span><br><span class="line">         //把数据发送到dest通道中</span><br><span class="line">         dest &lt;- i * i</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   for i := range dest &#123;</span><br><span class="line">      println(i)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   CalSquare()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-4-WaitGroup"><a href="#1-3-4-4-WaitGroup" class="headerlink" title="1.3.4.4 WaitGroup:"></a>1.3.4.4 WaitGroup:</h4><p>优化判断协程全部进行完毕的工具.一个示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func hello(i int) &#123;</span><br><span class="line">   println(&quot;hello goroutine&quot; + fmt.Sprint(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func HelloGoRoutine() &#123;</span><br><span class="line">   var wg sync.WaitGroup</span><br><span class="line">   //开启了五个线程 计数器初始化为5</span><br><span class="line">   wg.Add(5)</span><br><span class="line">   for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">      //开启协程 在调用函数的时候使用go 关键字</span><br><span class="line">      go func(j int) &#123;</span><br><span class="line">         //调用的defer 在协程结束的时候控制计数器减一</span><br><span class="line">         defer wg.Done()</span><br><span class="line">         hello(j)</span><br><span class="line">      &#125;(i)</span><br><span class="line">   &#125;</span><br><span class="line">   //阻塞直到计数器为0</span><br><span class="line">   wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   HelloGoRoutine()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-Golang依赖管理"><a href="#1-4-Golang依赖管理" class="headerlink" title="1.4 Golang依赖管理:"></a>1.4 Golang依赖管理:</h2><h3 id="1-4-1-入门"><a href="#1-4-1-入门" class="headerlink" title="1.4.1: 入门:"></a>1.4.1: 入门:</h3><p>工程项目不可能只简单地基于标准库搭建,需要依赖其他包(别人已经写好的代码),这些被称之为依赖,而如何管理依赖库是一个问题.</p>
<p>最终目的是让程序员不要关注各种依赖,而专注于业务逻辑上面.</p>
<h3 id="1-4-2-GOPATH"><a href="#1-4-2-GOPATH" class="headerlink" title="1.4.2: GOPATH:"></a>1.4.2: GOPATH:</h3><p>一个环境变量,主要分为bin(编译的二进制文件),pkg(编译中间产物),src(项目源码)</p>
<p>项目的代码依赖于src下面的代码,通过go get下载最新版本的包到src目录下.</p>
<p>弊端是无法实现项目依赖的多版本控制.</p>
<h3 id="1-4-3-Go-Vendor"><a href="#1-4-3-Go-Vendor" class="headerlink" title="1.4.3: Go Vendor:"></a>1.4.3: Go Vendor:</h3><p>项目目录下增加vendor文件,依赖包放在特定的文件夹下.</p>
<p>寻找依赖的方式:vendor,gopath</p>
<p>通过每个项目引入依赖的副本,解决了多个项目需要同一个package依赖的冲突问题.</p>
<p>还是无法解决依赖冲突的问题.</p>
<h3 id="1-4-4-Go-Module"><a href="#1-4-4-Go-Module" class="headerlink" title="1.4.4: Go Module:"></a>1.4.4: Go Module:</h3><p>主要通过go.mod文件管理依赖包版本.定义版本规则和管理项目依赖关系.</p>
<p>通过go get&#x2F;go mod 指令工具管理依赖包.与maven类似.</p>
<h4 id="1-4-4-1-依赖管理三要素"><a href="#1-4-4-1-依赖管理三要素" class="headerlink" title="1.4.4.1 依赖管理三要素:"></a>1.4.4.1 依赖管理三要素:</h4><p>1.管理文件,描述依赖 go.mod</p>
<p>2.中心仓库管理依赖库 Proxy</p>
<p>3.本地工具 go get&#x2F;mod</p>
<h4 id="1-4-4-2-go-mod文件"><a href="#1-4-4-2-go-mod文件" class="headerlink" title="1.4.4.2 go.mod文件:"></a>1.4.4.2 go.mod文件:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module hello //依赖管理的基本单元,每个包都需要一个go.mod文件</span><br><span class="line"></span><br><span class="line">go 1.12 //原生库版本号</span><br><span class="line"></span><br><span class="line">require (  </span><br><span class="line">	//单元依赖 由path和version组成</span><br><span class="line">	github.com/labstack/echo v3.3.10+incompatible // indirect</span><br><span class="line">	github.com/labstack/gommon v0.2.8 // indirect</span><br><span class="line">	github.com/mattn/go-colorable v0.1.1 // indirect</span><br><span class="line">	github.com/mattn/go-isatty v0.0.7 // indirect</span><br><span class="line">	github.com/valyala/fasttemplate v1.0.0 // indirect</span><br><span class="line">	golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; indirect 表示间接依赖:比如a依赖b,b依赖c a对c就是间接依赖</p>
<p>+incompatible 做一个不兼容的标识</p>
<p>go.mod 自己定义了版本规则:</p>
<p>1.语义化版本;</p>
<p>{major}{minior}{patch}</p>
<p>不同的major之间存在隔离.不兼容</p>
<p>minior做新增函数,在major下做前后兼容</p>
<p>patch做代码bug修复. </p>
<p>eg. V1.3.0</p>
<p>2.基于commit的伪版本.</p>
<p>版本号-时间戳-哈希码</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230116160410.png" alt="QQ截图20230116160410"></p>
<h3 id="1-4-5-依赖分发"><a href="#1-4-5-依赖分发" class="headerlink" title="1.4.5:依赖分发:"></a>1.4.5:依赖分发:</h3><p>就是从哪里下载依赖的问题:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230116160746.png" alt="QQ截图20230116160746"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230116160755.png" alt="QQ截图20230116160755"></p>
<h2 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5 测试:"></a>1.5 测试:</h2><h3 id="1-5-1-测试类型"><a href="#1-5-1-测试类型" class="headerlink" title="1.5.1 测试类型:"></a>1.5.1 测试类型:</h3><p>回归测试:人工模拟真实操作</p>
<p>集成测试:对系统进行测试</p>
<p>单元测试:对单独的模块进行测试</p>
<p>从上到下,覆盖率逐渐变大,成本逐渐变低.所以单元测试是最重要的.</p>
<h3 id="1-5-2-单元测试"><a href="#1-5-2-单元测试" class="headerlink" title="1.5.2 单元测试:"></a>1.5.2 单元测试:</h3><h4 id="1-5-2-1-测试规则"><a href="#1-5-2-1-测试规则" class="headerlink" title="1.5.2.1 测试规则:"></a>1.5.2.1 测试规则:</h4><p>所有测试文件以_test.go结尾.与被测试文件紧挨着.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func TestXxx(*testing.T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-2-测试覆盖率"><a href="#1-5-2-2-测试覆盖率" class="headerlink" title="1.5.2.2 测试覆盖率:"></a>1.5.2.2 测试覆盖率:</h4><p>测试用例覆盖代码的程度.一般的项目覆盖率能达到50-60%.</p>
<h4 id="1-5-2-3-Mock"><a href="#1-5-2-3-Mock" class="headerlink" title="1.5.2.3 Mock:"></a>1.5.2.3 Mock:</h4><p>主要是为了解决单元测试中的依赖问题,做到幂等(每次测试都得到同样的结果)和稳定.</p>
<p>比如说原函数a在运行时需要操作文件a,但是如果a文件出现问题,就得不到正确的测试结果,而mock机制可以通过打桩,把a换成另一个函数b.从而取消对文件或者其他组件的强依赖.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230116170725.png" alt="QQ截图20230116170725"></p>
<h4 id="1-5-2-4-基准测试"><a href="#1-5-2-4-基准测试" class="headerlink" title="1.5.2.4 基准测试:"></a>1.5.2.4 基准测试:</h4><p>go语言自带的测试框架.</p>
<h2 id="1-6-项目开发"><a href="#1-6-项目开发" class="headerlink" title="1.6 项目开发:"></a>1.6 项目开发:</h2><p>主要描述项目实现的流程.</p>
<h3 id="1-6-1-需求描述"><a href="#1-6-1-需求描述" class="headerlink" title="1.6.1 需求描述:"></a>1.6.1 需求描述:</h3><p>以文本的形式描述需求.</p>
<h3 id="1-6-2-用例"><a href="#1-6-2-用例" class="headerlink" title="1.6.2 用例:"></a>1.6.2 用例:</h3><p>识别用例后,使用ER图表征具体元素.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230116171603.png" alt="QQ截图20230116171603"></p>
<h3 id="1-6-3-分层模型"><a href="#1-6-3-分层模型" class="headerlink" title="1.6.3 分层模型:"></a>1.6.3 分层模型:</h3><p>选择分层模型实现项目.一般的模型如下:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230116171645.png" alt="QQ截图20230116171645"></p>
<p>与MVC结构类似.</p>
<h3 id="1-6-4-组件工具-Gin"><a href="#1-6-4-组件工具-Gin" class="headerlink" title="1.6.4 组件工具:Gin:"></a>1.6.4 组件工具:Gin:</h3><h2 id="1-7-高质量编程"><a href="#1-7-高质量编程" class="headerlink" title="1.7 高质量编程:"></a>1.7 高质量编程:</h2><h3 id="1-7-1-高质量"><a href="#1-7-1-高质量" class="headerlink" title="1.7.1 高质量:"></a>1.7.1 高质量:</h3><p>正确可靠,简洁清晰的代码.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230117112904.png" alt="QQ截图20230117112904"></p>
<h3 id="1-7-2-注释"><a href="#1-7-2-注释" class="headerlink" title="1.7.2: 注释:"></a>1.7.2: 注释:</h3><p>“好的代码有很多注释,坏的代码需要很多注释”</p>
<p>代码是最好的注释,提供代码为表达出的上下文信息.</p>
<p>1.公共符号始终要注释.(变量.常量.函数.结构等).</p>
<p>2.任何既不明显也不简短的公共功能必须要注释.</p>
<p>3.无论长度和复杂程度如何,对库中的函数必须注释.</p>
<h4 id="1-7-2-1-解释代码作用"><a href="#1-7-2-1-解释代码作用" class="headerlink" title="1.7.2.1: 解释代码作用:"></a>1.7.2.1: 解释代码作用:</h4><p>建议统一放在公共符号之前.适合注释公共符号.</p>
<h4 id="1-7-2-2-解释代码是如何做的"><a href="#1-7-2-2-解释代码是如何做的" class="headerlink" title="1.7.2.2: 解释代码是如何做的:"></a>1.7.2.2: 解释代码是如何做的:</h4><p>建议统一放在公共符号之前.适合注释实现过程.</p>
<h4 id="1-7-2-3-解释代码实现的原因"><a href="#1-7-2-3-解释代码实现的原因" class="headerlink" title="1.7.2.3: 解释代码实现的原因:"></a>1.7.2.3: 解释代码实现的原因:</h4><p>建议放在代码内,提供额外的上下文.</p>
<h4 id="1-7-2-4-解释代码什么情况下会出错"><a href="#1-7-2-4-解释代码什么情况下会出错" class="headerlink" title="1.7.2.4: 解释代码什么情况下会出错:"></a>1.7.2.4: 解释代码什么情况下会出错:</h4><p>建议统一放在公共符号之前.解释代码的限制条件.</p>
<h3 id="1-7-3-代码格式"><a href="#1-7-3-代码格式" class="headerlink" title="1.7.3: 代码格式:"></a>1.7.3: 代码格式:</h3><h4 id="1-7-3-1-gofmt"><a href="#1-7-3-1-gofmt" class="headerlink" title="1.7.3.1: gofmt:"></a>1.7.3.1: gofmt:</h4><p>自动格式化代码.</p>
<h4 id="1-7-3-2-goimports"><a href="#1-7-3-2-goimports" class="headerlink" title="1.7.3.2: goimports:"></a>1.7.3.2: goimports:</h4><p>自动修正包.</p>
<h3 id="1-7-4-命名规范"><a href="#1-7-4-命名规范" class="headerlink" title="1.7.4: 命名规范;"></a>1.7.4: 命名规范;</h3><h4 id="1-7-4-1-变量"><a href="#1-7-4-1-变量" class="headerlink" title="1.7.4.1: 变量:"></a>1.7.4.1: 变量:</h4><p>1.简洁胜过冗长.</p>
<p>2.变量距离被使用的地方越远(库),则需要携带更多的上下文信息.</p>
<h4 id="1-7-4-2-函数"><a href="#1-7-4-2-函数" class="headerlink" title="1.7.4.2: 函数:"></a>1.7.4.2: 函数:</h4><p>1.简短,尽量不携带包的上下文信息.</p>
<p>2.返回类型和函数名相同时不需要展示,反之则额外展示.</p>
<h4 id="1-7-4-3-包"><a href="#1-7-4-3-包" class="headerlink" title="1.7.4.3: 包:"></a>1.7.4.3: 包:</h4><p>1.全小写.</p>
<p>2.包含一定的上下文信息.</p>
<p>3.不要与标准库同名.</p>
<p>4.不用常见的变量名.</p>
<p>5.使用单数而不是复数.</p>
<p>6.谨慎的使用缩写.</p>
<p>核心是降低阅读理解代码的成本,重点是考虑上下文信息,设计简洁的名称.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230117115503.png" alt="QQ截图20230117115503"></p>
<h3 id="1-7-3-控制流程"><a href="#1-7-3-控制流程" class="headerlink" title="1.7.3: 控制流程:"></a>1.7.3: 控制流程:</h3><p>1.尽量避免嵌套.</p>
<p>2.优先处理错误情况.尽量早的返回或者继续循环.</p>
<p>3.尽量保持正常代码路径为最小缩进.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230117115932.png" alt="QQ截图20230117115932"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230117115946.png" alt="QQ截图20230117115946"></p>
<p>线性原理.正常流程代码沿着屏幕向下移动,故障问题大多出现在复杂的条件语句和循环语句中.</p>
<h3 id="1-7-4-异常处理"><a href="#1-7-4-异常处理" class="headerlink" title="1.7.4: 异常处理:"></a>1.7.4: 异常处理:</h3><p>1.简单错误:只出现一次的错误,使用error.New.</p>
<p>2.复杂错误,使用errors.is判断错误是否为特定错误,errors.as获取特定种类的错误.</p>
<p>3.panic:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230117120637.png" alt="QQ截图20230117120637"></p>
<p>4.recover:</p>
<h4 id="1-7-4-1-defer规则"><a href="#1-7-4-1-defer规则" class="headerlink" title="1.7.4.1 defer规则:"></a><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230117120802.png" alt="QQ截图20230117120802">1.7.4.1 defer规则:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230117121658.png" alt="QQ截图20230117121658"></p>
<h1 id="2-Go框架三件套"><a href="#2-Go框架三件套" class="headerlink" title="2.Go框架三件套:"></a>2.Go框架三件套:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120233653.png" alt="QQ截图20230120233653"></p>
<p>1.gorm:功能强大的orm(object relational mapping,对象关系映射,orm将数据表抽象为一个类，每条数据就是一个实例。同时封装了便捷的方法，让我们可以更简单的操作数据库，即使是你对sql语法只是了解)框架.</p>
<p>2.kitex:字节跳动内部的golang微服务RPC:</p>
<p>RPC（Remote Procedure Call）远程过程调用协议，一种通过网络从远程计算机上请求服务，而不需要了解底层网络技术的协议。RPC它假定某些协议的存在，例如TPC&#x2F;UDP等，为通信程序之间携带信息数据。在OSI网络七层模型中，RPC跨越了传输层和应用层，RPC使得开发，包括网络分布式多程序在内的应用程序更加容易。过程是什么？ 过程就是业务处理、计算任务，更直白的说，就是程序，就是想调用本地方法一样调用远程的过程. </p>
<p>框架,具有高性能,强扩展性的特点.</p>
<p>3.hertz:字节跳动内部的http框架,高易用性,高扩展性.的特点.</p>
<h2 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1 使用:"></a>2.1 使用:</h2><h3 id="2-1-1-gorm-数据库操作"><a href="#2-1-1-gorm-数据库操作" class="headerlink" title="2.1.1 gorm 数据库操作:"></a>2.1.1 gorm 数据库操作:</h3><h4 id="2-1-1-1-基本使用"><a href="#2-1-1-1-基本使用" class="headerlink" title="2.1.1.1 基本使用:"></a>2.1.1.1 基本使用:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120220112.png" alt="QQ截图20230120220112"></p>
<h4 id="2-1-1-2-数据库连接"><a href="#2-1-1-2-数据库连接" class="headerlink" title="2.1.1.2 数据库连接:"></a>2.1.1.2 数据库连接:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120221008.png" alt="QQ截图20230120221008"></p>
<h4 id="2-1-1-3-创建数据"><a href="#2-1-1-3-创建数据" class="headerlink" title="2.1.1.3 创建数据:"></a>2.1.1.3 创建数据:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120221621.png" alt="QQ截图20230120221621"></p>
<h4 id="2-1-1-4-查询数据"><a href="#2-1-1-4-查询数据" class="headerlink" title="2.1.1.4 查询数据:"></a>2.1.1.4 查询数据:</h4><p>链式调用(.方法().方法()这样的调用方式,责任链模式)的时候,调用where方法的时候,底层是在拼接sql语句,调用find等方法的时候,sql语句已经开始执行了,所以在后面追加条件的话是不会生效的.</p>
<p>所以推荐使用result这样的参数接收链式调用的方法.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120221756.png" alt="QQ截图20230120221756"></p>
<h4 id="2-1-1-5-更新数据"><a href="#2-1-1-5-更新数据" class="headerlink" title="2.1.1.5 更新数据:"></a>2.1.1.5 更新数据:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120222134.png" alt="QQ截图20230120222134"></p>
<h4 id="2-1-1-6-删除数据"><a href="#2-1-1-6-删除数据" class="headerlink" title="2.1.1.6 删除数据:"></a>2.1.1.6 删除数据:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120222356.png" alt="QQ截图20230120222356"></p>
<h4 id="2-1-1-7-事务"><a href="#2-1-1-7-事务" class="headerlink" title="2.1.1.7 事务:"></a>2.1.1.7 事务:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120223316.png" alt="QQ截图20230120223316"></p>
<p>自动方法:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120223548.png" alt="QQ截图20230120223548"></p>
<h4 id="2-1-1-8-hook"><a href="#2-1-1-8-hook" class="headerlink" title="2.1.1.8 hook:"></a>2.1.1.8 hook:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120223755.png" alt="QQ截图20230120223755"></p>
<h4 id="2-1-1-9-性能优化"><a href="#2-1-1-9-性能优化" class="headerlink" title="2.1.1.9 性能优化:"></a>2.1.1.9 性能优化:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120223926.png" alt="QQ截图20230120223926"></p>
<h4 id="2-1-1-10-扩展"><a href="#2-1-1-10-扩展" class="headerlink" title="2.1.1.10 扩展:"></a>2.1.1.10 扩展:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120224018.png" alt="QQ截图20230120224018"></p>
<h3 id="2-1-2-kitex-微服务框架"><a href="#2-1-2-kitex-微服务框架" class="headerlink" title="2.1.2 kitex: 微服务框架:"></a>2.1.2 kitex: 微服务框架:</h3><h4 id="2-1-2-1-安装"><a href="#2-1-2-1-安装" class="headerlink" title="2.1.2.1 安装:"></a>2.1.2.1 安装:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120225132.png" alt="QQ截图20230120225132"></p>
<h4 id="2-1-2-2-Thrift与IDL"><a href="#2-1-2-2-Thrift与IDL" class="headerlink" title="2.1.2.2 Thrift与IDL:"></a>2.1.2.2 Thrift与IDL:</h4><p>Thrift 是一个提供可扩展，跨语言的服务开发框架，通过其强大的代码生成器，可以和 C++, Java, Python, PHP, Ruby, Erlang, Haskell, C#, Cocoa, Javascript, Node.js, Smalltalk, OCaml, Golang 等多种语言高效且无缝的工作。</p>
<p>Thrift 最初是由 Facebook 作为内部项目开发使用，于 2007.04 开源，2008.05 进入 Apache 孵化器，并于 2010.11 成为 Apache 顶级项目（Top-Level Project, TLP）, 至今已有 10+ 年，thrift 功能强大，使用二进制进行传输，速度更快。</p>
<p>IDL 是 Thrift 的核心，也是 Thrift 编译器直接操作的源码，既然 IDL 是一门语言，那么就有他自己的语法.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120225258.png" alt="QQ截图20230120225258"></p>
<p>RPC是远程过程调用（Remote Procedure Call)，通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p>
<p>比如:比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<p>目前的 RPC 框架大致有两种不同的侧重方向，一种偏重于服务治理，有Dubbo、Motan 等。适用于大型服务的微服务化拆分以及管理。</p>
<p>另一种偏重于跨语言调用。有 Thrift、gRPC 等，这一类的 RPC 框架重点关注于服务的跨语言调用。</p>
<p>总结来说，Thrift是一种RPC框架。</p>
<p>Thrift源于大名鼎鼎的facebook之手，对于当时的facebook来说创造thrift是为了解决facebook系统中各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性。所以thrift可以支持多种程序语言，例如:  C++, C#等等。在多种不同的语言之间通信thrift可以作为二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。Thrift是一个轻量级、跨语言的RPC框架，主要用于各个服务之间的RPC通信。它通过自身的IDL中间语言, 并借助代码生成引擎生成各种主流语言的RPC服务端&#x2F;客户端模板代码。<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207180706.png" alt="QQ截图20230207180706"></p>
<h4 id="2-1-2-3-kitex使用"><a href="#2-1-2-3-kitex使用" class="headerlink" title="2.1.2.3 kitex使用:"></a>2.1.2.3 kitex使用:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120225607.png" alt="QQ截图20230120225607"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120225732.png" alt="QQ截图20230120225732"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120225834.png" alt="QQ截图20230120225834"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120230049.png" alt="QQ截图20230120230049"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120230407.png" alt="QQ截图20230120230407"></p>
<h4 id="2-1-2-4-拓展"><a href="#2-1-2-4-拓展" class="headerlink" title="2.1.2.4 拓展:"></a>2.1.2.4 拓展:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120230450.png" alt="QQ截图20230120230450"></p>
<h3 id="2-1-3-hertz"><a href="#2-1-3-hertz" class="headerlink" title="2.1.3: hertz:"></a>2.1.3: hertz:</h3><h4 id="2-1-3-1-基本使用"><a href="#2-1-3-1-基本使用" class="headerlink" title="2.1.3.1: 基本使用:"></a>2.1.3.1: 基本使用:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120230713.png" alt="QQ截图20230120230713"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120230838.png" alt="QQ截图20230120230838"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120230912.png" alt="QQ截图20230120230912"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120230922.png" alt="QQ截图20230120230922"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120231103.png" alt="QQ截图20230120231103"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120231315.png" alt="QQ截图20230120231315"></p>
<p>也可以注册在单独路由或者路由组下(v1).</p>
<p>如果注册在路由组下,那么访问404时中间件的方法会不会执行?</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120231657.png" alt="QQ截图20230120231657"></p>
<h4 id="2-1-3-2-代码生成工具"><a href="#2-1-3-2-代码生成工具" class="headerlink" title="2.1.3.2: 代码生成工具:"></a>2.1.3.2: 代码生成工具:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120231747.png" alt="QQ截图20230120231747"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120231819.png" alt="QQ截图20230120231819"></p>
<h4 id="2-1-3-3-性能"><a href="#2-1-3-3-性能" class="headerlink" title="2.1.3.3: 性能:"></a>2.1.3.3: 性能:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120231905.png" alt="QQ截图20230120231905"></p>
<h4 id="2-1-3-4-扩展"><a href="#2-1-3-4-扩展" class="headerlink" title="2.1.3.4: 扩展:"></a>2.1.3.4: 扩展:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232054.png" alt="QQ截图20230120232054"></p>
<h3 id="2-1-4-项目实战"><a href="#2-1-4-项目实战" class="headerlink" title="2.1.4 项目实战:"></a>2.1.4 项目实战:</h3><h4 id="2-1-4-1-项目介绍"><a href="#2-1-4-1-项目介绍" class="headerlink" title="2.1.4.1 项目介绍:"></a>2.1.4.1 项目介绍:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232149.png" alt="QQ截图20230120232149"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232306.png" alt="QQ截图20230120232306"></p>
<h4 id="2-1-4-2-调用关系"><a href="#2-1-4-2-调用关系" class="headerlink" title="2.1.4.2: 调用关系:"></a>2.1.4.2: 调用关系:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232355.png" alt="QQ截图20230120232355"></p>
<h4 id="2-1-4-3-IDL介绍"><a href="#2-1-4-3-IDL介绍" class="headerlink" title="2.1.4.3: IDL介绍:"></a>2.1.4.3: IDL介绍:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232520.png" alt="QQ截图20230120232520"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232529.png" alt="QQ截图20230120232529"></p>
<h4 id="2-1-4-4-技术栈介绍"><a href="#2-1-4-4-技术栈介绍" class="headerlink" title="2.1.4.4: 技术栈介绍:"></a>2.1.4.4: 技术栈介绍:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232541.png" alt="QQ截图20230120232541"></p>
<h4 id="2-1-4-5-关键代码讲解"><a href="#2-1-4-5-关键代码讲解" class="headerlink" title="2.1.4.5: 关键代码讲解:"></a>2.1.4.5: 关键代码讲解:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232556.png" alt="QQ截图20230120232556"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232903.png" alt="QQ截图20230120232903"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120232956.png" alt="QQ截图20230120232956"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120233024.png" alt="QQ截图20230120233024"></p>
<p>建议bizdemo版本.</p>
<h4 id="2-1-4-5-总结"><a href="#2-1-4-5-总结" class="headerlink" title="2.1.4.5: 总结:"></a>2.1.4.5: 总结:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120233217.png" alt="QQ截图20230120233217"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230120233333.png" alt="QQ截图20230120233333"></p>
<h1 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3.性能优化:"></a>3.性能优化:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131212817-1675171739813-3.png" alt="QQ截图20230131212817"></p>
<h2 id="3-1-性能优化工具-benchmark"><a href="#3-1-性能优化工具-benchmark" class="headerlink" title="3.1 性能优化工具:benchmark"></a>3.1 性能优化工具:benchmark</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131212844.png" alt="QQ截图20230131212844"></p>
<p>运行结果:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131212920.png" alt="QQ截图20230131212920"></p>
<h2 id="3-2-性能优化建议"><a href="#3-2-性能优化建议" class="headerlink" title="3.2 性能优化建议:"></a>3.2 性能优化建议:</h2><h3 id="3-2-1-slice预分配内存"><a href="#3-2-1-slice预分配内存" class="headerlink" title="3.2.1 slice预分配内存:"></a>3.2.1 slice预分配内存:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131213029.png" alt="QQ截图20230131213029"></p>
<p>原因:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131213302.png" alt="QQ截图20230131213302"></p>
<p>如果不预先分配内存,那么会造成在内存不够的时候,对底层数组进行扩容,从而导致耗时增加.</p>
<h3 id="3-2-2-释放大切片的内存"><a href="#3-2-2-释放大切片的内存" class="headerlink" title="3.2.2 释放大切片的内存:"></a>3.2.2 释放大切片的内存:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131213700.png" alt="QQ截图20230131213700"></p>
<p>在使用切片当中的一部分的时候,要新建一个切片,把原先切片中的数据拷贝过去.</p>
<h3 id="3-2-3-map预分配内存"><a href="#3-2-3-map预分配内存" class="headerlink" title="3.2.3 map预分配内存:"></a>3.2.3 map预分配内存:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131213831.png" alt="QQ截图20230131213831"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131213900.png" alt="QQ截图20230131213900"></p>
<h3 id="3-2-4-字符串处理"><a href="#3-2-4-字符串处理" class="headerlink" title="3.2.4: 字符串处理:"></a>3.2.4: 字符串处理:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214031.png" alt="QQ截图20230131214031"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214135.png" alt="QQ截图20230131214135"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214251.png" alt="QQ截图20230131214251"></p>
<p>最后一项指标是内存分配次数,结果验证了之前的方法.</p>
<h3 id="3-2-5-空结构体"><a href="#3-2-5-空结构体" class="headerlink" title="3.2.5: 空结构体:"></a>3.2.5: 空结构体:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214457.png" alt="QQ截图20230131214457"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214505.png" alt="QQ截图20230131214505"></p>
<h3 id="3-2-6-atomic包"><a href="#3-2-6-atomic包" class="headerlink" title="3.2.6: atomic包:"></a>3.2.6: atomic包:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214613.png" alt="QQ截图20230131214613"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214634.png" alt="QQ截图20230131214634"></p>
<h3 id="3-2-7-总结"><a href="#3-2-7-总结" class="headerlink" title="3.2.7: 总结:"></a>3.2.7: 总结:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214721.png" alt="QQ截图20230131214721"></p>
<h2 id="3-3-性能优化原则"><a href="#3-3-性能优化原则" class="headerlink" title="3.3 性能优化原则:"></a>3.3 性能优化原则:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131214852.png" alt="QQ截图20230131214852"></p>
<h2 id="3-4-性能分析工具-pprof"><a href="#3-4-性能分析工具-pprof" class="headerlink" title="3.4 性能分析工具:pprof:"></a>3.4 性能分析工具:pprof:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215026.png" alt="QQ截图20230131215026"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215036.png" alt="QQ截图20230131215036"></p>
<h3 id="3-4-1-使用"><a href="#3-4-1-使用" class="headerlink" title="3.4.1 使用:"></a>3.4.1 使用:</h3><h4 id="3-4-1-1-搭建"><a href="#3-4-1-1-搭建" class="headerlink" title="3.4.1.1 搭建:"></a>3.4.1.1 搭建:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215133.png" alt="QQ截图20230131215133"></p>
<h4 id="3-4-1-2-浏览器查看指标"><a href="#3-4-1-2-浏览器查看指标" class="headerlink" title="3.4.1.2 浏览器查看指标:"></a>3.4.1.2 浏览器查看指标:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215258.png" alt="QQ截图20230131215258"></p>
<h4 id="3-4-1-3-采集性能数据："><a href="#3-4-1-3-采集性能数据：" class="headerlink" title="3.4.1.3 采集性能数据："></a>3.4.1.3 采集性能数据：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215447.png" alt="QQ截图20230131215447"></p>
<h4 id="3-4-1-4-操作数据："><a href="#3-4-1-4-操作数据：" class="headerlink" title="3.4.1.4  操作数据："></a>3.4.1.4  操作数据：</h4><h5 id="3-4-1-4-1-时间"><a href="#3-4-1-4-1-时间" class="headerlink" title="3.4.1.4.1: 时间:                     "></a>3.4.1.4.1: 时间:                     <img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215508.png" alt="QQ截图20230131215508"></h5><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215706.png" alt="QQ截图20230131215706"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215820.png" alt="QQ截图20230131215820"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215840.png" alt="QQ截图20230131215840"></p>
<h5 id="3-4-1-4-2-内存："><a href="#3-4-1-4-2-内存：" class="headerlink" title="3.4.1.4.2: 内存："></a>3.4.1.4.2: 内存：</h5><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131215948.png" alt="QQ截图20230131215948"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131220918.png" alt="QQ截图20230131220918"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131221154.png" alt="QQ截图20230131221154"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131221226.png" alt="QQ截图20230131221226"></p>
<h5 id="3-4-1-4-3-协程："><a href="#3-4-1-4-3-协程：" class="headerlink" title="3.4.1.4.3: 协程："></a>3.4.1.4.3: 协程：</h5><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131221450.png" alt="QQ截图20230131221450"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131221549.png" alt="QQ截图20230131221549"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131221710.png" alt="QQ截图20230131221710"></p>
<h5 id="3-4-1-4-4-锁："><a href="#3-4-1-4-4-锁：" class="headerlink" title="3.4.1.4.4: 锁："></a>3.4.1.4.4: 锁：</h5><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131222038.png" alt="QQ截图20230131222038"></p>
<h5 id="3-4-1-4-5：阻塞："><a href="#3-4-1-4-5：阻塞：" class="headerlink" title="3.4.1.4.5：阻塞："></a>3.4.1.4.5：阻塞：</h5><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131222133.png" alt="QQ截图20230131222133"></p>
<p>可能有部分阻塞会被隐藏，需要手动打开。</p>
<p><img src="C:\Users\wpy\Desktop\blog\source\images\Golang学习笔记\QQ截图20230131222559.png" alt="QQ截图20230131222559"></p>
<h3 id="3-4-2-原理"><a href="#3-4-2-原理" class="headerlink" title="3.4.2 原理:"></a>3.4.2 原理:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203094748.png" alt="QQ截图20230203094748"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203094830.png" alt="QQ截图20230203094830"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203094910.png" alt="QQ截图20230203094910"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203095052.png" alt="QQ截图20230203095052"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203095145.png" alt="QQ截图20230203095145"></p>
<h3 id="3-4-3-总结"><a href="#3-4-3-总结" class="headerlink" title="3.4.3 总结:"></a>3.4.3 总结:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203095252.png" alt="QQ截图20230203095252"></p>
<h2 id="3-5-性能调优案例"><a href="#3-5-性能调优案例" class="headerlink" title="3.5 性能调优案例:"></a>3.5 性能调优案例:</h2><h3 id="3-5-1-分类"><a href="#3-5-1-分类" class="headerlink" title="3.5.1 分类:"></a>3.5.1 分类:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203095355.png" alt="QQ截图20230203095355"></p>
<h3 id="3-5-2-业务服务优化"><a href="#3-5-2-业务服务优化" class="headerlink" title="3.5.2 业务服务优化:"></a>3.5.2 业务服务优化:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203095459.png" alt="QQ截图20230203095459"></p>
<h4 id="3-5-2-1-流程"><a href="#3-5-2-1-流程" class="headerlink" title="3.5.2.1 流程:"></a>3.5.2.1 流程:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203095620.png" alt="QQ截图20230203095620"></p>
<h4 id="3-5-2-2-服务评估"><a href="#3-5-2-2-服务评估" class="headerlink" title="3.5.2.2 服务评估:"></a>3.5.2.2 服务评估:</h4><p><img src="C:\Users\wpy\Desktop\blog\source\images\Golang学习笔记\QQ截图20230203095716.png" alt="QQ截图20230203095716">      <img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203095918.png" alt="QQ截图20230203095918"></p>
<h4 id="3-5-2-3-定位瓶颈"><a href="#3-5-2-3-定位瓶颈" class="headerlink" title="3.5.2.3 定位瓶颈:"></a>3.5.2.3 定位瓶颈:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100005.png" alt="QQ截图20230203100005"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100039.png" alt="QQ截图20230203100039"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100051.png" alt="QQ截图20230203100051"></p>
<h4 id="3-5-2-4-优化改造"><a href="#3-5-2-4-优化改造" class="headerlink" title="3.5.2.4 优化改造:"></a>3.5.2.4 优化改造:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100330.png" alt="QQ截图20230203100330"></p>
<p>重新测试接口,对比数据</p>
<h4 id="3-5-2-5-优化效果验证"><a href="#3-5-2-5-优化效果验证" class="headerlink" title="3.5.2.5 优化效果验证:"></a>3.5.2.5 优化效果验证:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100425.png" alt="QQ截图20230203100425"></p>
<h4 id="3-5-2-6-进一步优化"><a href="#3-5-2-6-进一步优化" class="headerlink" title="3.5.2.6 进一步优化:"></a>3.5.2.6 进一步优化:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100525.png" alt="QQ截图20230203100525"></p>
<p>被调用的服务被称为调用服务的上游服务.</p>
<h3 id="3-5-3-基础库优化"><a href="#3-5-3-基础库优化" class="headerlink" title="3.5.3 基础库优化:"></a>3.5.3 基础库优化:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100655.png" alt="QQ截图20230203100655"></p>
<h3 id="3-5-4-Go语言优化"><a href="#3-5-4-Go语言优化" class="headerlink" title="3.5.4 Go语言优化:"></a>3.5.4 Go语言优化:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100813.png" alt="QQ截图20230203100813"></p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结:"></a>3.6 总结:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203100859.png" alt="QQ截图20230203100859"></p>
<p>以数据为核心.</p>
<h1 id="4-高性能go"><a href="#4-高性能go" class="headerlink" title="4.高性能go:"></a>4.高性能go:</h1><h2 id="4-1-引入"><a href="#4-1-引入" class="headerlink" title="4.1 引入:"></a>4.1 引入:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203163427.png" alt="QQ截图20230203163427"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203163438.png" alt="QQ截图20230203163438"></p>
<p>为什么要做性能优化?</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203163718.png" alt="QQ截图20230203163718"></p>
<h2 id="4-2-性能优化的两个层面"><a href="#4-2-性能优化的两个层面" class="headerlink" title="4.2 性能优化的两个层面:"></a>4.2 性能优化的两个层面:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203165210.png" alt="QQ截图20230203165210"></p>
<h2 id="4-3-性能优化与软件质量"><a href="#4-3-性能优化与软件质量" class="headerlink" title="4.3 性能优化与软件质量:"></a>4.3 性能优化与软件质量:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203165313.png" alt="QQ截图20230203165313"></p>
<p>尽量不要修改sdk中的接口,而是修改其实现.</p>
<h2 id="4-4-自动内存管理"><a href="#4-4-自动内存管理" class="headerlink" title="4.4 自动内存管理:"></a>4.4 自动内存管理:</h2><h3 id="4-4-1-背景"><a href="#4-4-1-背景" class="headerlink" title="4.4.1 背景:"></a>4.4.1 背景:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203170548.png" alt="QQ截图20230203170548"></p>
<p>连续释放两次,或者释放之后再进行使用.</p>
<p><img src="C:\Users\wpy\Desktop\blog\source\images\Golang学习笔记\QQ截图20230203170530.png" alt="QQ截图20230203170530"></p>
<h3 id="4-4-2-相关概念"><a href="#4-4-2-相关概念" class="headerlink" title="4.4.2 相关概念:"></a>4.4.2 相关概念:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203171051.png" alt="QQ截图20230203171051"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203171218.png" alt="QQ截图20230203171218"></p>
<h3 id="4-4-3-追踪垃圾回收"><a href="#4-4-3-追踪垃圾回收" class="headerlink" title="4.4.3 追踪垃圾回收:"></a>4.4.3 追踪垃圾回收:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203171621.png" alt="QQ截图20230203171621"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203171656.png" alt="QQ截图20230203171656"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203171709.png" alt="QQ截图20230203171709"></p>
<h4 id="4-4-3-1-分代GC"><a href="#4-4-3-1-分代GC" class="headerlink" title="4.4.3.1 分代GC:"></a>4.4.3.1 分代GC:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203171758.png" alt="QQ截图20230203171758"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203171903.png" alt="QQ截图20230203171903"></p>
<h3 id="4-4-引用计数"><a href="#4-4-引用计数" class="headerlink" title="4.4 引用计数:"></a>4.4 引用计数:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203172448.png" alt="QQ截图20230203172448"></p>
<h3 id="4-4-5-总结"><a href="#4-4-5-总结" class="headerlink" title="4.4.5 总结:"></a>4.4.5 总结:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203172514.png" alt="QQ截图20230203172514"></p>
<h2 id="4-5-go内存管理及优化"><a href="#4-5-go内存管理及优化" class="headerlink" title="4.5 go内存管理及优化:"></a>4.5 go内存管理及优化:</h2><h3 id="4-5-1-go内存分配-分块与缓存"><a href="#4-5-1-go内存分配-分块与缓存" class="headerlink" title="4.5.1: go内存分配:分块与缓存"></a>4.5.1: go内存分配:分块与缓存</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203172911.png" alt="QQ截图20230203172911"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173008.png" alt="QQ截图20230203173008"></p>
<h3 id="4-5-2-出现的问题"><a href="#4-5-2-出现的问题" class="headerlink" title="4.5.2 出现的问题:"></a>4.5.2 出现的问题:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173157.png" alt="QQ截图20230203173157"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173216.png" alt="QQ截图20230203173216"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173248.png" alt="QQ截图20230203173248"></p>
<h3 id="4-5-3-balanced-GC"><a href="#4-5-3-balanced-GC" class="headerlink" title="4.5.3 balanced GC:"></a>4.5.3 balanced GC:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173327.png" alt="QQ截图20230203173327"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173513.png" alt="QQ截图20230203173513"></p>
<p>解决方案:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173636.png" alt="QQ截图20230203173636"></p>
<p>收益:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173707.png" alt="QQ截图20230203173707"></p>
<h3 id="4-5-4-总结"><a href="#4-5-4-总结" class="headerlink" title="4.5.4 总结:"></a>4.5.4 总结:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173809.png" alt="QQ截图20230203173809"></p>
<h1 id="5-编译器和静态分析"><a href="#5-编译器和静态分析" class="headerlink" title="5.编译器和静态分析:"></a>5.编译器和静态分析:</h1><h2 id="5-1-编译器结构"><a href="#5-1-编译器结构" class="headerlink" title="5.1 编译器结构:"></a>5.1 编译器结构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203173902.png" alt="QQ截图20230203173902"></p>
<p>IR是机器无关的.类似于字节码.</p>
<p>本次主要介绍编译器后端的优化.</p>
<h2 id="5-2-静态分析"><a href="#5-2-静态分析" class="headerlink" title="5.2 静态分析:"></a>5.2 静态分析:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203174251.png" alt="QQ截图20230203174251"></p>
<h3 id="5-2-1-过程内分析和过程间分析"><a href="#5-2-1-过程内分析和过程间分析" class="headerlink" title="5.2.1 过程内分析和过程间分析:"></a>5.2.1 过程内分析和过程间分析:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203174427.png" alt="QQ截图20230203174427"></p>
<h2 id="5-3-总结"><a href="#5-3-总结" class="headerlink" title="5.3 总结:"></a>5.3 总结:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203174613.png" alt="QQ截图20230203174613"></p>
<h2 id="5-4-go编译器优化："><a href="#5-4-go编译器优化：" class="headerlink" title="5.4 go编译器优化："></a>5.4 go编译器优化：</h2><h3 id="5-4-1-背景："><a href="#5-4-1-背景：" class="headerlink" title="5.4.1 背景："></a>5.4.1 背景：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203174803.png" alt="QQ截图20230203174803"></p>
<h3 id="5-4-2-函数内联："><a href="#5-4-2-函数内联：" class="headerlink" title="5.4.2 函数内联："></a>5.4.2 函数内联：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203175035.png" alt="QQ截图20230203175035"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203175137.png" alt="QQ截图20230203175137"></p>
<h3 id="5-4-3-Beast-Mode："><a href="#5-4-3-Beast-Mode：" class="headerlink" title="5.4.3 Beast Mode："></a>5.4.3 Beast Mode：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203175237.png" alt="QQ截图20230203175237"></p>
<p>收益:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203175546.png" alt="QQ截图20230203175546"></p>
<h3 id="5-4-4-逃逸分析："><a href="#5-4-4-逃逸分析：" class="headerlink" title="5.4.4 逃逸分析："></a>5.4.4 逃逸分析：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203175516.png" alt="QQ截图20230203175516"></p>
<h3 id="5-4-5-总结"><a href="#5-4-5-总结" class="headerlink" title="5.4.5 总结:"></a>5.4.5 总结:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203175630.png" alt="QQ截图20230203175630"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203175658.png" alt="QQ截图20230203175658"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hertz</title>
    <url>/2023/02/04/Hertz/</url>
    <content><![CDATA[<h1 id="Hertz"><a href="#Hertz" class="headerlink" title="Hertz"></a>Hertz</h1><h1 id="1-简介："><a href="#1-简介：" class="headerlink" title="1.简介："></a>1.简介：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204145726.png" alt="QQ截图20230204145726"></p>
<h1 id="2-Hertz分层设计："><a href="#2-Hertz分层设计：" class="headerlink" title="2.Hertz分层设计："></a>2.Hertz分层设计：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204145757.png" alt="QQ截图20230204145757"></p>
<h1 id="3-特点："><a href="#3-特点：" class="headerlink" title="3.特点："></a>3.特点：</h1><p><a href="https://www.cloudwego.io/zh/docs/hertz/">Hertz | CloudWeGo</a></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204145934.png" alt="QQ截图20230204145934"></p>
<p><a href="https://mp.weixin.qq.com/s/jU-IiDett3LLeEFtmrXXxw">微服务超 10 万、跨语言场景，字节服务网格依靠 CloudWeGo 扛住流量洪峰 (qq.com)</a><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204150004.png" alt="QQ截图20230204150004"></p>
<h1 id="4-新特性："><a href="#4-新特性：" class="headerlink" title="4.新特性："></a>4.新特性：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204150346.png" alt="QQ截图20230204150346"></p>
<h1 id="5-提问截图："><a href="#5-提问截图：" class="headerlink" title="5.提问截图："></a>5.提问截图：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204150458.png" alt="QQ截图20230204150458"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204150530.png" alt="QQ截图20230204150530"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204150512.png" alt="QQ截图20230204150512"></p>
<h1 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用:"></a>6.使用:</h1><p>依据<a href="https://www.cloudwego.io/zh/docs/hertz/getting-started/">快速开始 | CloudWeGo</a>此教程学习.</p>
<h2 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装:"></a>6.1 安装:</h2><p>cmd,git,powershell的区别?</p>
<p>安装报错:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230204210542.png" alt="微信图片_20230204210542"></p>
<p>解决方案:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204215755.png" alt="QQ截图20230204215755"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">env</span>:GOPROXY = <span class="string">&quot;https://proxy.golang.com.cn,direct&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720230204215817.png" alt="QQ图片20230204215817"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230205182837.jpg" alt="微信图片_20230205182837"></p>
<h2 id="6-2-goland配置"><a href="#6-2-goland配置" class="headerlink" title="6.2 goland配置:"></a>6.2 goland配置:</h2><p>全部爆红,识别不出来,同步也同步不了.</p>
<p>解决方案是设置代理.</p>
<p><a href="https://blog.csdn.net/JikeStardy/article/details/123090981?ops_request_misc=%7B%22request_id%22:%22167559127316800215033458%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=167559127316800215033458&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-123090981-null-null.142%5Ev73%5Econtrol,201%5Ev4%5Eadd_ask,239%5Ev1%5Econtrol&utm_term=goland%E4%BB%A3%E7%90%86&spm=1018.2226.3001.4187">(181条消息) Goland 下载 go 包_JikeStardy的博客-CSDN博客</a></p>
<p>解决方案从这个文章找到,略有修改.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOPROXY=&quot;https://goproxy.cn&quot;;GO111MODULE=on</span><br></pre></td></tr></table></figure>

<p>可能会出现版本不匹配的情况.建议切换到1.19版本.</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:8888/ping</span><br></pre></td></tr></table></figure>

<h2 id="6-3-hello-world"><a href="#6-3-hello-world" class="headerlink" title="6.3 hello world:"></a>6.3 hello world:</h2><p>尝试编写一个类似于spring中，controller层的一个接口的一个简单的方法.</p>
<p>只需要一个main方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;context&quot;</span><br><span class="line">   &quot;github.com/cloudwego/hertz/pkg/app&quot;</span><br><span class="line">   &quot;github.com/cloudwego/hertz/pkg/app/server&quot;</span><br><span class="line">   &quot;github.com/cloudwego/hertz/pkg/protocol/consts&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   h := server.Default(</span><br><span class="line">      server.WithHostPorts(&quot;127.0.0.1:8080&quot;),</span><br><span class="line">      //使用这个配置指定ip和端口.</span><br><span class="line">   )</span><br><span class="line">   //建立一个get请求</span><br><span class="line">   h.GET(&quot;/hello&quot;, func(c context.Context, ctx *app.RequestContext) &#123;</span><br><span class="line">   	  //在这里写访问这个接口的具体逻辑.</span><br><span class="line">      ctx.String(consts.StatusOK, &quot;hello hertz!&quot;)</span><br><span class="line">   &#125;)</span><br><span class="line">   //类似于接口的打开.</span><br><span class="line">   h.Spin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230205221923.png" alt="QQ截图20230205221923"></p>
<h2 id="6-4-获取参数："><a href="#6-4-获取参数：" class="headerlink" title="6.4 获取参数："></a>6.4 获取参数：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name := ctx.Query(&quot;name&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="6-5-hertz-gorm-实现简单的MVC逻辑"><a href="#6-5-hertz-gorm-实现简单的MVC逻辑" class="headerlink" title="6.5 hertz+gorm 实现简单的MVC逻辑:"></a>6.5 hertz+gorm 实现简单的MVC逻辑:</h2><p>也是只需要main函数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;context&quot;</span><br><span class="line">   &quot;github.com/cloudwego/hertz/pkg/app&quot;</span><br><span class="line">   &quot;github.com/cloudwego/hertz/pkg/app/server&quot;</span><br><span class="line">   &quot;github.com/cloudwego/hertz/pkg/common/json&quot;</span><br><span class="line">   &quot;github.com/cloudwego/hertz/pkg/protocol/consts&quot;</span><br><span class="line">   &quot;gorm.io/driver/mysql&quot;</span><br><span class="line">   &quot;gorm.io/gorm&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//定义gorm model</span><br><span class="line">type User struct &#123;</span><br><span class="line">   Name string `gorm:&quot;column:name; type:varchar(32);&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义表名</span><br><span class="line">func (u User) TableName() string &#123;</span><br><span class="line">   return &quot;User&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   //建立数据库连接,数据库名:数据库密码@...</span><br><span class="line">   dsn := &quot;root:123456@tcp(127.0.0.1:3306)/dbgotest?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span><br><span class="line">   db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">   //处理错误</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">   	  //控制台打印错误日志</span><br><span class="line">      panic(&quot;数据库连接失败!&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   //新建数据库表,根据结构体创建</span><br><span class="line">   m := db.Migrator()</span><br><span class="line">   err = m.CreateTable(&amp;User&#123;&#125;)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      panic(&quot;新建表失败!&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   //配置http</span><br><span class="line">   h := server.Default(</span><br><span class="line">      server.WithHostPorts(&quot;127.0.0.1:8080&quot;),</span><br><span class="line">   )</span><br><span class="line">   h.GET(&quot;/hello&quot;, func(c context.Context, ctx *app.RequestContext) &#123;</span><br><span class="line">      username := ctx.Query(&quot;name&quot;)</span><br><span class="line">      //创建一条数据,传入一个对象.</span><br><span class="line">      db.Create(&amp;User&#123;Name: username&#125;)</span><br><span class="line">      //查询一条数据</span><br><span class="line">      var user User</span><br><span class="line">      db.First(&amp;user, &quot;name = ?&quot;, username)</span><br><span class="line">      //转换格式后输出</span><br><span class="line">      res, _ := json.Marshal(user)</span><br><span class="line">      ctx.String(consts.StatusOK, string(res))</span><br><span class="line">   &#125;)</span><br><span class="line">   h.Spin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言设计与实现</title>
    <url>/2023/03/14/Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Go语言设计与实现"><a href="#Go语言设计与实现" class="headerlink" title="Go语言设计与实现"></a>Go语言设计与实现</h1><h1 id="1-编译原理"><a href="#1-编译原理" class="headerlink" title="1.编译原理:"></a>1.编译原理:</h1><p>go语言编译器的源代码放在src&#x2F;cmd&#x2F;complie中.</p>
<h2 id="1-1-预备知识"><a href="#1-1-预备知识" class="headerlink" title="1.1 预备知识:"></a>1.1 预备知识:</h2><h3 id="1-1-1-抽象语法树"><a href="#1-1-1-抽象语法树" class="headerlink" title="1.1.1 抽象语法树:"></a>1.1.1 抽象语法树:</h3><p>抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。抽象语法树在很多领域有广泛的应用，比如浏览器，智能编辑器，编译器。</p>
<h3 id="1-1-2-静态单赋值"><a href="#1-1-2-静态单赋值" class="headerlink" title="1.1.2 静态单赋值:"></a>1.1.2 静态单赋值:</h3><p>称为ssa,是编译器后端的一部分,是指每个变量只会被赋值一次,是一种中间代码的特性.</p>
<h3 id="1-1-3-编译阶段"><a href="#1-1-3-编译阶段" class="headerlink" title="1.1.3 编译阶段:"></a>1.1.3 编译阶段:</h3><h4 id="1-1-3-1-编译器的前后端"><a href="#1-1-3-1-编译器的前后端" class="headerlink" title="1.1.3.1 编译器的前后端:"></a>1.1.3.1 编译器的前后端:</h4><p>编译器一般由前端和后端组成.其中前端负责把源代码转换成语言无关的中间代码,后端主要负责代码的生成和优化.包括中间代码和机器码.                                                                                                                                                                                                                                                                                </p>
<h4 id="1-1-3-2-词法分析和语法分析"><a href="#1-1-3-2-词法分析和语法分析" class="headerlink" title="1.1.3.2 词法分析和语法分析:"></a>1.1.3.2 词法分析和语法分析:</h4><p>词法分析是解析源代码文件,变成token序列,语法分析是把token序列变成ast.</p>
<p>出现任何问题编译会即刻终止并在控制台打印问题.</p>
<h4 id="1-1-3-3-类型检查"><a href="#1-1-3-3-类型检查" class="headerlink" title="1.1.3.3 类型检查:"></a>1.1.3.3 类型检查:</h4><p>对ast进行各种类型的检查,同时更改一些关键字的类型.（如make）。</p>
<h5 id="1-1-3-3-1-强类型和弱类型："><a href="#1-1-3-3-1-强类型和弱类型：" class="headerlink" title="1.1.3.3.1 强类型和弱类型："></a>1.1.3.3.1 强类型和弱类型：</h5><p>强类型：在语言的编译器有更严格的要求。</p>
<p>弱类型：编译时期的类型错误会在运行时进行隐式的类型转换，可能会导致错误。</p>
<h5 id="1-1-3-3-2-静态类型检查和动态类型检查："><a href="#1-1-3-3-2-静态类型检查和动态类型检查：" class="headerlink" title="1.1.3.3.2 静态类型检查和动态类型检查："></a>1.1.3.3.2 静态类型检查和动态类型检查：</h5><p>静态类型检查通过对源代码的分析，判断程序类型是否安全。可以在编译器约束变量的类型。</p>
<p>动态类型检查是运行时确定程序类型是否安全的过程，这就要求在编译时，为所有的对象加入类型标签等信息，而工程师可以利用这些信息实现反射，动态派发等一系列动态的功能。使用起来非常灵活。</p>
<p>这两种类型检查并不是完全对立的，很多编程语言同时使用这两种类型检查，使用静态类型检查减少错误，为对象添加类型标签，从而实现语言的动态功能。Go语言就是其中之一。 </p>
<h4 id="1-1-3-4-中间代码生成"><a href="#1-1-3-4-中间代码生成" class="headerlink" title="1.1.3.4 中间代码生成:"></a>1.1.3.4 中间代码生成:</h4><p>经过前两步之后,就可以认为代码已经不存在问题了,就可以生成中间代码。</p>
<p>通过goroutine并发编译方式，将每一个函数的ast变成中间代码。</p>
<h4 id="1-1-3-5-机器码生成："><a href="#1-1-3-5-机器码生成：" class="headerlink" title="1.1.3.5 机器码生成："></a>1.1.3.5 机器码生成：</h4><p>根据不同的架构环境以及中间代码，生成机器码.</p>
<h1 id="2-数据结构："><a href="#2-数据结构：" class="headerlink" title="2.数据结构："></a>2.数据结构：</h1><h2 id="2-1-数组："><a href="#2-1-数组：" class="headerlink" title="2.1 数组："></a>2.1 数组：</h2><h3 id="2-1-1-初始化"><a href="#2-1-1-初始化" class="headerlink" title="2.1.1 初始化:"></a>2.1.1 初始化:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr := [3]int&#123;1,2,3&#125;</span><br><span class="line">arr := [...]int&#123;1,2,3&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数组初始化大小后无法改变。</p>
<h3 id="2-1-2-访问和赋值"><a href="#2-1-2-访问和赋值" class="headerlink" title="2.1.2 访问和赋值:"></a>2.1.2 访问和赋值:</h3><p>数组是一连串的存储空间,通过数组开头的指针,数组的大小,数组中数据元素的大小访问数组中的元素.</p>
<h2 id="2-2-切片"><a href="#2-2-切片" class="headerlink" title="2.2 切片:"></a>2.2 切片:</h2><p>数组切边,即动态数组.数据结构是一个结构体:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type SliceHeader struct&#123;</span><br><span class="line">Data uintptr</span><br><span class="line">len int</span><br><span class="line">cap int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data是一个数组的一部分，连续片段的引用。len是当前切片的长度，cap是data数组的大小。</p>
<h3 id="2-2-1-初始化："><a href="#2-2-1-初始化：" class="headerlink" title="2.2.1 初始化："></a>2.2.1 初始化：</h3><p>使用make关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slice := make([]int,10)</span><br></pre></td></tr></table></figure>

<p>当切片长度不够的时候，会发生扩容，具体过程是新建一个更大的切片然后把原先切片的内容复制过去。</p>
<h2 id="2-3-哈希表："><a href="#2-3-哈希表：" class="headerlink" title="2.3 哈希表："></a>2.3 哈希表：</h2><h3 id="2-3-1-设计原理："><a href="#2-3-1-设计原理：" class="headerlink" title="2.3.1 设计原理："></a>2.3.1 设计原理：</h3><p>两个关键点：哈希函数和解决冲突的方法。</p>
<h4 id="2-3-1-1：哈希函数："><a href="#2-3-1-1：哈希函数：" class="headerlink" title="2.3.1.1：哈希函数："></a>2.3.1.1：哈希函数：</h4><p>理想情况：输出范围远远大于输入范围.</p>
<p>实际解决方案：输出结果尽可能的均匀，通过工程手段解决冲突问题。</p>
<h4 id="2-3-1-2-解决冲突方法："><a href="#2-3-1-2-解决冲突方法：" class="headerlink" title="2.3.1.2 解决冲突方法："></a>2.3.1.2 解决冲突方法：</h4><p>开放地址法和拉链法。</p>
<h3 id="2-3-2-使用："><a href="#2-3-2-使用：" class="headerlink" title="2.3.2 使用："></a>2.3.2 使用：</h3><h4 id="2-3-2-1-初始化："><a href="#2-3-2-1-初始化：" class="headerlink" title="2.3.2.1 初始化："></a>2.3.2.1 初始化：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用make</span><br><span class="line">hash := make(map[string]int,3)</span><br><span class="line">//使用字面量</span><br><span class="line">hash := map[string]int &#123;</span><br><span class="line"> &quot;1&quot;: 1,</span><br><span class="line"> &quot;2&quot;: 2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-2-使用"><a href="#2-3-2-2-使用" class="headerlink" title="2.3.2.2 使用:"></a>2.3.2.2 使用:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = hash[key]</span><br><span class="line"></span><br><span class="line">for k,v := range hash&#123;</span><br><span class="line"> 	//k,v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-3-数据结构"><a href="#2-3-2-3-数据结构" class="headerlink" title="2.3.2.3 数据结构:"></a>2.3.2.3 数据结构:</h4><p>核心是一个hmap,包括count:数量,hash0:哈希表种子等.还有 buckets,指向正常桶和溢出桶的数组(他们是连续存储的),数组中的元素存储</p>
<p>的是哈希键的前八位.一个桶存储8个键值对,一旦有更多的键值对,就会装载到溢出桶中,超过一定的范围就会引发扩容,使桶的数量翻倍.</p>
<h2 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4 字符串:"></a>2.4 字符串:</h2><h3 id="2-4-1-数据结构"><a href="#2-4-1-数据结构" class="headerlink" title="2.4.1 数据结构:"></a>2.4.1 数据结构:</h3><p> 与切片高度相似,包含指向字节数组的指针,和数组的大小.</p>
<p>与Java,Python等语言一样,Go的字符串也是只读的,不可变的.因此所有字符串上的操作都是通过复制实现的. </p>
<h3 id="2-4-2-使用"><a href="#2-4-2-使用" class="headerlink" title="2.4.2 使用:"></a>2.4.2 使用:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str := &quot;123&quot;</span><br></pre></td></tr></table></figure>

<p>在进行拼接和类型转换时,string和[]byte之间转换,可能会造成性能问题. </p>
<h1 id="3-语言特性"><a href="#3-语言特性" class="headerlink" title="3. 语言特性:"></a>3. 语言特性:</h1><h2 id="3-1-函数调用"><a href="#3-1-函数调用" class="headerlink" title="3.1 函数调用:"></a>3.1 函数调用:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func myFunction(a,b int)(int ,int)&#123;</span><br><span class="line"> 	return a+b,a-b</span><br><span class="line">&#125;</span><br><span class="line">myFunction(66,77)</span><br></pre></td></tr></table></figure>

<p>与c语言传递参数时同时使用寄存器(前六个参数)和栈,用寄存器传递返回值的方式,go语言选择使用完全栈传递参数和返回值.牺牲了部分函数调用的性能,但是不需要考虑寄存器的具体设计,同时更加简单,支持多返回值.</p>
<h2 id="3-2-参数传递"><a href="#3-2-参数传递" class="headerlink" title="3.2 参数传递:"></a>3.2 参数传递:</h2><p>向函数传递参数一般有两种方式,一种是传值,双方持有两份不同的数据,另一种是传递引用,双方持有同一份数据.</p>
<p>而在Go语言中,选择了传值的方式,无论是何种数据类型,都会进行复制.对于一般的数据类型,比如整数,数组,结构体等,都会复制全部内容.而对于指针,会复制一个指针,指向原有指针指向的对象.</p>
<p>所以在向函数传递很大的数组或者结构体是,尽量传递指针而不是其本身,避免发生大规模的数据复制从而影响性能.</p>
<h2 id="3-3-接口"><a href="#3-3-接口" class="headerlink" title="3.3 接口:"></a>3.3 接口:</h2><p>代码必须能够被人阅读，只是机器恰好可以执行.</p>
<p>接口用于隐藏实现底层,解耦依赖关系等等功能,很多面向对象语言都有接口这一概念，例如 Java 和 C#。</p>
<h3 id="3-3-1-定义"><a href="#3-3-1-定义" class="headerlink" title="3.3.1 定义:"></a>3.3.1 定义:</h3><p>定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量.与定义结构体非常相近.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type error interface &#123;</span><br><span class="line">	Error() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言中的接口实现是隐式的,只需要实现接口下面的所有的方法,就详单与实现了接口,而不需要像Java一样显式的声明出来.</p>
<h3 id="3-3-2-接口检查"><a href="#3-3-2-接口检查" class="headerlink" title="3.3.2 接口检查:"></a>3.3.2 接口检查:</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code    <span class="type">int64</span></span><br><span class="line">	Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, code=%d&quot;</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rpcErr <span class="type">error</span> = NewRPCError(<span class="number">400</span>, <span class="string">&quot;unknown err&quot;</span>) <span class="comment">// typecheck1</span></span><br><span class="line">	err := AsErr(rpcErr) <span class="comment">// typecheck2</span></span><br><span class="line">	<span class="built_in">println</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRPCError</span><span class="params">(code <span class="type">int64</span>, msg <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;RPCError&#123; <span class="comment">// typecheck3</span></span><br><span class="line">		Code:    code,</span><br><span class="line">		Message: msg,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsErr</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 语言在<a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">编译期间</a>对代码进行类型检查，上述代码总共触发了三次类型检查：</p>
<ol>
<li>将 <code>*RPCError</code> 类型的变量赋值给 <code>error</code> 类型的变量 <code>rpcErr</code>；</li>
<li>将 <code>*RPCError</code> 类型的变量 <code>rpcErr</code> 传递给签名中参数类型为 <code>error</code> 的 <code>AsErr</code> 函数；</li>
<li>将 <code>*RPCError</code> 类型的变量从函数签名的返回值类型为 <code>error</code> 的 <code>NewRPCError</code> 函数中返回；</li>
</ol>
<h3 id="3-3-3-类型"><a href="#3-3-3-类型" class="headerlink" title="3.3.3 类型:"></a>3.3.3 类型:</h3><p> Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 <code>interface&#123;&#125;</code>：Go 语言使用 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 表示第一种接口，使用 <a href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 表示第二种不包含任何方法的接口 <code>interface&#123;&#125;</code>，两种接口虽然都使用 <code>interface</code> 声明，但是由于后者在 Go 语言中很常见，所以在实现时使用了特殊的类型。</p>
<h3 id="3-3-4-指针和接口"><a href="#3-3-4-指针和接口" class="headerlink" title="3.3.4 指针和接口:"></a>3.3.4 指针和接口:</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Quack() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = &amp;Cat&#123;&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用结构体作为参数实现接口,而在初始化变量的时候使用指针的方式.也就是说,c是一个指针,指向一个cat结构体,当运行c.quack方法时,会复制一个指针,同样指向cat,所以可以正常运行.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duck <span class="keyword">interface</span> &#123;</span><br><span class="line">	Quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cat)</span></span> Quack() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;meow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Duck = Cat&#123;&#125;</span><br><span class="line">	c.Quack()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码使用指针作为参数实现接口,而初始化变量的时候使用结构体的方式,这样是不行的,因为这个方法需要的是一个指针变量,而这个现在并没有指针变量,所以无法通过.</p>
<h2 id="3-4-反射"><a href="#3-4-反射" class="headerlink" title="3.4 反射:"></a>3.4 反射:</h2><p>主要依靠”reflect”包.主要包括两个函数和类型,他们是一一对应的.</p>
<p>1.类型reflect.Type是反射包定义的一个接口，我们可以使用reflect.TypeOf()函数获取任意变量的类型.</p>
<p>2.类型reflect.Value是反射包定义的一个结构体,可以使用reflect.ValueOf()函数获取任意变量的值.</p>
<p>反射包中的所有方法基本都是围绕着 reflect.Type 和reflect.Value两个类型设计的。我们通过 reflect.TypeOf()、reflect.ValueOf()可以将一个普通的变量转换成反射包中提供的reflect.Type  和 reflect.Value随后就可以使用反射包中的方法对它们进行复杂的操作。</p>
<h3 id="3-4-1-第一法则"><a href="#3-4-1-第一法则" class="headerlink" title="3.4.1 第一法则:"></a>3.4.1 第一法则:</h3><p>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象.</p>
<p>两个重要的方法的参数都是接口类型.使用时会发生类型转换.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	author := <span class="string">&quot;draven&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;TypeOf author:&quot;</span>, reflect.TypeOf(author))</span><br><span class="line">	fmt.Println(<span class="string">&quot;ValueOf author:&quot;</span>, reflect.ValueOf(author))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line">TypeOf author: <span class="type">string</span></span><br><span class="line">ValueOf author: draven</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-第二法则"><a href="#3-4-2-第二法则" class="headerlink" title="3.4.2 第二法则:"></a>3.4.2 第二法则:</h3><p>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v := reflect.ValueOf(<span class="number">1</span>)</span><br><span class="line">v.Interface().(<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-3-第三法则"><a href="#3-4-3-第三法则" class="headerlink" title="3.4.3 第三法则:"></a>3.4.3 第三法则:</h3><p>要修改反射对象，其值必须可设置；</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := reflect.ValueOf(&amp;i)</span><br><span class="line">	v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">go</span> run reflect.<span class="keyword">go</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>修改反射对象值的过程,由于传值特性,这种过程类似于</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	v := &amp;i</span><br><span class="line">	*v = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-关键字"><a href="#4-关键字" class="headerlink" title="4.关键字:"></a>4.关键字:</h1>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/01/17/Redis/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="1-Redis介绍："><a href="#1-Redis介绍：" class="headerlink" title="1.Redis介绍："></a>1.Redis介绍：</h1><h2 id="1-1-为什么需要redis："><a href="#1-1-为什么需要redis：" class="headerlink" title="1.1 为什么需要redis："></a>1.1 为什么需要redis：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215111415.png" alt="QQ截图20230215111415"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215111447.png" alt="QQ截图20230215111447"></p>
<h2 id="1-2-基本结构："><a href="#1-2-基本结构：" class="headerlink" title="1.2 基本结构："></a>1.2 基本结构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215111543.png" alt="QQ截图20230215111543"></p>
<p>一定程度上实现持久化。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215111849.png" alt="QQ截图20230215111849"></p>
<h1 id="2-Redis应用案例："><a href="#2-Redis应用案例：" class="headerlink" title="2. Redis应用案例："></a>2. Redis应用案例：</h1><h2 id="2-1-连续签到："><a href="#2-1-连续签到：" class="headerlink" title="2.1 连续签到："></a>2.1 连续签到：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215111950.png" alt="QQ截图20230215111950"></p>
<h2 id="2-2-String数据结构："><a href="#2-2-String数据结构：" class="headerlink" title="2.2 String数据结构："></a>2.2 String数据结构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215112319.png" alt="QQ截图20230215112319"></p>
<p>存储的是二进制数据。</p>
<p>flags获取数据类型，alloc是分配空间长度，len是实际长度。</p>
<h2 id="2-3-消息通知："><a href="#2-3-消息通知：" class="headerlink" title="2.3 消息通知："></a>2.3 消息通知：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215112738.png" alt="QQ截图20230215112738"></p>
<h2 id="2-4-List数据结构："><a href="#2-4-List数据结构：" class="headerlink" title="2.4 List数据结构："></a>2.4 List数据结构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215113124.png" alt="QQ截图20230215113124"></p>
<p>在一个节点上存储很多个数据。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215113359.png" alt="QQ截图20230215113359"></p>
<h2 id="2-5-计数："><a href="#2-5-计数：" class="headerlink" title="2.5 计数："></a>2.5 计数：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230215113442.png" alt="QQ截图20230215113442"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机</title>
    <url>/2023/01/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="1-走进Java"><a href="#1-走进Java" class="headerlink" title="1.走进Java:"></a>1.走进Java:</h1><h2 id="1-1-Java技术体系"><a href="#1-1-Java技术体系" class="headerlink" title="1.1 Java技术体系:"></a>1.1 Java技术体系:</h2><h3 id="1-1-1-JDK"><a href="#1-1-1-JDK" class="headerlink" title="1.1.1 JDK:"></a>1.1.1 JDK:</h3><p>JDK,全拼为”Java Development Kit”,由Java语言,Java虚拟机,Java类库三部分组成.JDK是支持Java开发所需的最小的环境.经常以JDK代指整个的Java技术体系.</p>
<h3 id="1-1-2-JRE"><a href="#1-1-2-JRE" class="headerlink" title="1.1.2 JRE:"></a>1.1.2 JRE:</h3><p>JRE,全拼为”Java Runtime Environment”,由Java SE API子集和Java虚拟机组成,是运行Java程序的标准环境.</p>
<h3 id="1-1-3-Java-SE和Java-EE"><a href="#1-1-3-Java-SE和Java-EE" class="headerlink" title="1.1.3 Java SE和Java EE:"></a>1.1.3 Java SE和Java EE:</h3><p>SE(standard edition):面向桌面级别的应用(如Windows系统下的应用)的Java平台.</p>
<p>EE(enterprise edition):支持使用多层架构的企业级应用的Java平台.</p>
<h2 id="1-2-Java语言编译-运行过程"><a href="#1-2-Java语言编译-运行过程" class="headerlink" title="1.2: Java语言编译.运行过程:"></a>1.2: Java语言编译.运行过程:</h2><p>首先,程序员编写出的Java程序,有一个个.Java格式的类组成.然后通过编译,形成字节码文件,也就是.class文件.然后通过JVM加载.class文件.生成可执行文件(也就是由0和1组成的文件).</p>
<p>字节码:字节码是一种中间状态的二进制代码，是由源码编译过来的，可读性没有源码高。而且cpu也不能够直接读取字节码，需要经过JVM虚拟机转译成机器码之后，cpu才能够读取并运行。</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定机器上运行，这也是java编译与解释并存的特点。</p>
<p>而java语言通过字节码的方式，在一定程度在解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以java程序运行时比较高效，而且由于字节码并不专对于一种特定的机器，因此java程序无需重新编译便可以在多种不同的计算机上运行。</p>
<h1 id="2-内存分配"><a href="#2-内存分配" class="headerlink" title="2.内存分配:"></a>2.内存分配:</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述:"></a>2.1 概述:</h2><p>在C,C++中,在内存管理领域,程序员要负责每一个对象从开始到销毁的所有的工作,而在Java中,程序员只需要关注在恰当的地方创建对象,而不需要关注如何去进行垃圾的回收,不必为一个new操作去写对应的delete&#x2F;free代码.</p>
<p>而是由虚拟机自动的去进行内存分配和垃圾回收.</p>
<h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域:"></a>2.2 运行时数据区域:</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域.如图所示:</p>
<h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1: 程序计数器:"></a>2.2.1: 程序计数器:</h3><p>当前线程所执行的字节码指示器.每条线程都需要有一个独立的程序计数器.</p>
<h3 id="2-2-2-虚拟机栈"><a href="#2-2-2-虚拟机栈" class="headerlink" title="2.2.2: 虚拟机栈:"></a>2.2.2: 虚拟机栈:</h3><p>描述的是Java方法执行的线程内存模型.每当一个Java方法被执行,虚拟机就会同步创建一个栈帧,用于储存与该方法相关的信息,比如局部变量表,操作数栈等.每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>局部变量表:表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。</p>
<p>如果线程请求的栈深度大于虚 拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展[2]，当栈扩 展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>
<h3 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3: 本地方法栈:"></a>2.2.3: 本地方法栈:</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机 栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<h3 id="2-2-4-堆："><a href="#2-2-4-堆：" class="headerlink" title="2.2.4: 堆："></a>2.2.4: 堆：</h3><p>对于Java应用程序来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所 有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。</p>
<p>Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大 对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p>
<p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
<h3 id="2-2-5-方法区："><a href="#2-2-5-方法区：" class="headerlink" title="2.2.5: 方法区："></a>2.2.5: 方法区：</h3><p>是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>如果方法区无法满足新的内存分配需求时，将抛出 。</p>
<h3 id="2-2-6-运行时常量池："><a href="#2-2-6-运行时常量池：" class="headerlink" title="2.2.6: 运行时常量池："></a>2.2.6: 运行时常量池：</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<h3 id="2-2-7-直接内存："><a href="#2-2-7-直接内存：" class="headerlink" title="2.2.7: 直接内存："></a>2.2.7: 直接内存：</h3><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。它的意思是在一些特殊的时候，通过某些方法直接分配堆外内存，然后同各国Java堆里面的一个对象作为这部分内存的引用，已在一些特定的应用场景中显著的提高性能。</p>
<p>这部分也可能会出现OutOfMemoryError异常。</p>
<h2 id="2-3-对象的创建："><a href="#2-3-对象的创建：" class="headerlink" title="2.3: 对象的创建："></a>2.3: 对象的创建：</h2><h3 id="2-3-1-判断类加载"><a href="#2-3-1-判断类加载" class="headerlink" title="2.3.1: 判断类加载:"></a>2.3.1: 判断类加载:</h3><p>当虚拟机遇到一条代表new的字节码指令时,首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那 必须先执行相应的类加载过程.</p>
<h3 id="2-3-2-为新生对象分配内存"><a href="#2-3-2-为新生对象分配内存" class="headerlink" title="2.3.2: 为新生对象分配内存:"></a>2.3.2: 为新生对象分配内存:</h3><p>对象所需内存的大小在类加载完成 后便可完全确定.为对象分配内存就相当于把一块确定大小的内存从Java堆中划分出来给这个对象使用.如何分配这些内存取决于Java堆中的内存分布情况.不同的内存分布,所使用的分配方法也不一样.</p>
<h4 id="2-3-2-1-指针碰撞"><a href="#2-3-2-1-指针碰撞" class="headerlink" title="2.3.2.1: 指针碰撞:"></a>2.3.2.1: 指针碰撞:</h4><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一 边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</p>
<h4 id="2-3-2-2-空闲列表"><a href="#2-3-2-2-空闲列表" class="headerlink" title="2.3.2.2: 空闲列表:"></a>2.3.2.2: 空闲列表:</h4><p>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分 配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为“空闲列表”（Free List）。</p>
<h4 id="2-3-2-2-线程并发问题"><a href="#2-3-2-2-线程并发问题" class="headerlink" title="2.3.2.2: 线程并发问题:"></a>2.3.2.2: 线程并发问题:</h4><p>对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。(比如在springboot中两个用户近乎同时访问一个需要new对象的接口).</p>
<p>解决这个问题 有两种可选方案：一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。</p>
<p>CAS: compare and swap.是一种用于解决并发带来的数据问题的方法.CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论哪种情况，它都会返回在这个未知的数据在进行CAS 指令之前的值。</p>
<h4 id="2-3-2-3-设置对象信息"><a href="#2-3-2-3-设置对象信息" class="headerlink" title="2.3.2.3: 设置对象信息:"></a>2.3.2.3: 设置对象信息:</h4><p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到 类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才 计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。</p>
<h4 id="2-3-2-4-执行构造函数"><a href="#2-3-2-4-执行构造函数" class="headerlink" title="2.3.2.4: 执行构造函数:"></a>2.3.2.4: 执行构造函数:</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视 角看来，对象创建才刚刚开始——构造函数，即Class文件中的()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说,此时执行new指令之后会接着执行 ()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<h2 id="2-4-对象的内存布局"><a href="#2-4-对象的内存布局" class="headerlink" title="2.4: 对象的内存布局:"></a>2.4: 对象的内存布局:</h2><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<h3 id="2-4-1-对象头"><a href="#2-4-1-对象头" class="headerlink" title="2.4.1: 对象头:"></a>2.4.1: 对象头:</h3><p>对象头包括两类信息.</p>
<p>第一类是用于存储对象自身的运行时数据，如哈 希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部 分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它 为“Mark Word”。</p>
<p>第二类是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的 信息推断出数组的大小。</p>
<h3 id="2-4-2-实例数据"><a href="#2-4-2-实例数据" class="headerlink" title="2.4.2: 实例数据:"></a>2.4.2: 实例数据:</h3><p>对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
<p>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存 放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的 +XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p>
<h3 id="2-4-3-对齐填充"><a href="#2-4-3-对齐填充" class="headerlink" title="2.4.3: 对齐填充:"></a>2.4.3: 对齐填充:</h3><p>它仅仅起着占位符的作 用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者 2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h2 id="2-5-访问对象"><a href="#2-5-访问对象" class="headerlink" title="2.5: 访问对象:"></a>2.5: 访问对象:</h2><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种:</p>
<h3 id="2-5-1-使用句柄访问"><a href="#2-5-1-使用句柄访问" class="headerlink" title="2.5.1: 使用句柄访问:"></a>2.5.1: 使用句柄访问:</h3><p>句柄:句柄是一种特殊的智能指针 。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄。句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。</p>
<p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就，是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。如图所示：</p>
<p>![image-20220902170941215](C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\blog\myblog\source_posts\image-20220902170941215.png)</p>
<p>使用句柄访问最大的好处就是reference中存储的是稳定句柄地 址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p>
<h3 id="2-5-2-使用直接指针访问："><a href="#2-5-2-使用直接指针访问：" class="headerlink" title="2.5.2: 使用直接指针访问："></a>2.5.2: 使用直接指针访问：</h3><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p>
<p>![image-20220902171228641](C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\blog\myblog\source_posts\image-20220902171228641.png)</p>
<p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访 问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟 机HotSpot而言，它主要使用第二种方式进行对象访。</p>
<h1 id="3-垃圾回收："><a href="#3-垃圾回收：" class="headerlink" title="3.垃圾回收："></a>3.垃圾回收：</h1><h2 id="3-1-垃圾回收的范畴"><a href="#3-1-垃圾回收的范畴" class="headerlink" title="3.1: 垃圾回收的范畴:"></a>3.1: 垃圾回收的范畴:</h2><p>Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈这3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的）,因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<p>而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能 会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才 能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。而垃圾收集器所关注的正是这两个区域.</p>
<h2 id="3-2-判断对象已经不被使用"><a href="#3-2-判断对象已经不被使用" class="headerlink" title="3.2: 判断对象已经不被使用:"></a>3.2: 判断对象已经不被使用:</h2><p>Java堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就 是要确定这些对象之中哪些还“存活”着，哪些已经“死去”.即已经不再被引用.</p>
<h3 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1: 引用计数算法:"></a>3.2.1: 引用计数算法:</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>这种方法的优势是原理比较简单,效率比较高,但是也有一些问题,比如很难判断引用结束等问题.而在主流的虚拟机中没有采用这种方式进行内存管理.</p>
<h3 id="3-2-2-可达性分析"><a href="#3-2-2-可达性分析" class="headerlink" title="3.2.2: 可达性分析:"></a>3.2.2: 可达性分析:</h3><h4 id="3-2-2-1-范畴"><a href="#3-2-2-1-范畴" class="headerlink" title="3.2.2.1: 范畴:"></a>3.2.2.1: 范畴:</h4><p>当前主流的商用程序语言的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。</p>
<p>这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>简单观察这个算法就知道,这个算法的关键是如何去确保在程序运行中,所有的引用都不因为区域问题而发生遗漏.</p>
<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<p>(1)在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。</p>
<p>(2)在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</p>
<p>(3)在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</p>
<p>(4)在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p>
<p>(5)Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
<p>(6)所有被同步锁（synchronized关键字）持有的对象。</p>
<p>(7)反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不 同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</p>
<p>如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生 代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引 用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性.</p>
<h4 id="3-2-2-2-并发问题"><a href="#3-2-2-2-并发问题" class="headerlink" title="3.2.2.2: 并发问题:"></a>3.2.2.2: 并发问题:</h4><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。。在根节点枚举（见3.4.1节）这个步骤中，由于GC Roots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长，这听起来是理所当然的事情。</p>
<p>因为几乎所有的垃圾回收算法都使用可达性分析,所以对这一步的优化是十分必要的,既然要进行优化,就必须要明白为什么这种算法要求全过程都基于一个保障一致性的快照中.</p>
<p>如果没有这个条件,那么势必会导致系统在进行可达性分析的同时还运行着程序,那么就可能会出现一个对象经过可达性分析后被分析为”死亡”,然后在同时进行的程序中它又被已经扫描过的对象重新引用了,这就出现另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了.</p>
<p>可以使用三色标记来描述这种可达性分析的过程:其中对象的状态通过三种颜色描述:</p>
<p>(1)白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p>
<p>(2)黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。’</p>
<p>(3)灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</p>
<p>![image-20220904121030816](C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\blog\myblog\source_posts\image-20220904121030816.png)</p>
<p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p>
<p>(1)赋值器插入了一条或多条从黑色对象到白色对象的新引用.</p>
<p>(2)赋值器删除了全部从灰色对象到该白色对象的直接或间接引用.</p>
<p>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning， SATB）。</p>
<p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
<p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<h2 id="3-3-引用类型"><a href="#3-3-引用类型" class="headerlink" title="3.3: 引用类型:"></a>3.3: 引用类型:</h2><p>一般意义上的引用类型就是reference存储某个对象的地址,但是这种简单的引用在垃圾回收时不适合于所有的情况,比如有这么一类对象:</p>
<p>在内存非常充裕时,保留这些对象,当内存在垃圾回收后仍然非常紧张,那就把这些对象抛弃掉,与各种应用程序的”缓存”相同,就无法通过简单的引用来表征这种策略下复杂的关系.</p>
<p>于是Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱</p>
<h3 id="3-3-1-强引用"><a href="#3-3-1-强引用" class="headerlink" title="3.3.1: 强引用:"></a>3.3.1: 强引用:</h3><p>最传统的引用定义,形如Object obj&#x3D;new Object()这样的引用都属于强引用,无论在何种情况下,只要这个对象还存在强引用的关系,垃圾收集器就不会回收这个对象.</p>
<h3 id="3-3-2-软引用"><a href="#3-3-2-软引用" class="headerlink" title="3.3.2: 软引用:"></a>3.3.2: 软引用:</h3><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
<h3 id="3-3-3-弱引用"><a href="#3-3-3-弱引用" class="headerlink" title="3.3.3: 弱引用:"></a>3.3.3: 弱引用:</h3><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<p>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
<h3 id="3-3-4-虚引用"><a href="#3-3-4-虚引用" class="headerlink" title="3.3.4: 虚引用:"></a>3.3.4: 虚引用:</h3><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p>
<h2 id="3-4-对象逃脱-finalize-方法"><a href="#3-4-对象逃脱-finalize-方法" class="headerlink" title="3.4: 对象逃脱:finalize()方法:"></a>3.4: 对象逃脱:finalize()方法:</h2><p>如果可达性分析认为这个对象已经没有被引用过,那么它也不会马上被回收,而是对其执行一次finalize()方法,如果这个方法没有在类的定义中被覆写,或者这个方法已经被执行过一次了,那么虚拟机将不会再执行这个方法了,换而言之,虚拟机对每个对象只会执行一次这个方法.</p>
<p>如果这个对象通过这个方法成功在引用链上建立了引用,那么它就不会被清除,反之它就基本确定会被清除了.</p>
<p>这个方法不推荐被使用,因为它运行代价高昂，不确定性大，无法保证各个对象的调用顺序.建议使用try-catch等实现对象的保留.</p>
<h2 id="3-5-方法区的回收"><a href="#3-5-方法区的回收" class="headerlink" title="3.5: 方法区的回收:"></a>3.5: 方法区的回收:</h2><p>我们知道,方法区主要存储的是各种类和方法的信息,常量,静态变量等内容.而对方法区的垃圾收集主要分为两种类型:废弃的常量和不常用的类.</p>
<h3 id="3-5-1-常量回收"><a href="#3-5-1-常量回收" class="headerlink" title="3.5.1: 常量回收:"></a>3.5.1: 常量回收:</h3><p>回收废弃常量与回收Java堆中的对象非常类似.</p>
<p>假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也与此类似。</p>
<h3 id="3-5-2-类回收"><a href="#3-5-2-类回收" class="headerlink" title="3.5.2: 类回收:"></a>3.5.2: 类回收:</h3><p>类的回收比常量回收条件严格得多,需要同时满足以下三个条件:</p>
<p>(1)该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p>
<p>(2)加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p>
<p>(3)该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<h2 id="3-6-垃圾回收算法"><a href="#3-6-垃圾回收算法" class="headerlink" title="3.6: 垃圾回收算法:"></a>3.6: 垃圾回收算法:</h2><p>上面只是介绍了垃圾回收的条件,具体对垃圾怎么回收还没有涉及.下面介绍的就是垃圾回收时发生的具体细节.</p>
<p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接 垃圾收集”。本节介绍的所有算法均属于追踪式垃圾收集的范畴。</p>
<h3 id="3-6-1-分代收集理论"><a href="#3-6-1-分代收集理论" class="headerlink" title="3.6.1: 分代收集理论:"></a>3.6.1: 分代收集理论:</h3><p>分代收集(Generational Collection)名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p>
<p>(1)弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>
<p>(2)强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
<p>简单理解这两条规则:简单对象用作简单的功能,实现简单的业务,所以产生的快,也消亡的快,经常会在程序中new出来,然后实现某个功能之后就不再使用它.(经验规则,不是对所有的程序都适用)而熬过很多次垃圾收集过程的对象意味着一直存在着引用,大概率是在程序中有着重要的功能,所以难以消亡.</p>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域——因而才有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法——因而发展出了“标记-复制算法”“标记-清除算法”“标记-整理算法”等针对性的垃圾收集算法。</p>
<h3 id="3-6-2-跨代引用"><a href="#3-6-2-跨代引用" class="headerlink" title="3.6.2: 跨代引用:"></a>3.6.2: 跨代引用:</h3><p>如果垃圾收集器如上文所说的那样,对分块的Java堆分别进行垃圾收集的话,那么会出现跨带引用问题,比如新生代对象被老对象所引用,这就导致在新生代垃圾收集的判断对象不被引用时,还要同时遍历老年代以确保确实没有对象在引用新生代的对象,这样就会带来很大的负担.为了解决这个问题,引入第三条经验法则:</p>
<p>(3): 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>
<p>简单理解:如果老年代引用了新生代的对象,由于老年代难以消亡,那么这个新生代对象由于存在这种引用关系也难以消亡,那么随着时间的推移,它也会慢慢地变成老年代.</p>
<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>
<h3 id="3-6-3-标记-清除算法"><a href="#3-6-3-标记-清除算法" class="headerlink" title="3.6.3: 标记-清除算法:"></a>3.6.3: 标记-清除算法:</h3><p>标记-清除算法是最简单也是最早出现的垃圾回收算法.主要分为标记和清除两个阶段,首先进行标记阶段,遍历需要进行垃圾回收的区域,标记所有需要被清除的对象(也可以是最后存活的对象),然后统一根据标记清除.</p>
<p>这种算法有两个主要问题:一是执行效率不稳定, 如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低.</p>
<p>二是容易出现空间碎片.因为清除的对象所占的内存是散乱的分布在Java堆之中,这就导致经过多次垃圾回收后,内存被分成一块块的碎片,不利于进行大对象(如对象集合)的内存分配.以至于提前进行下一次垃圾回收动作.</p>
<p>![image-20220904113344793](C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\blog\myblog\source_posts\image-20220904113344793.png)</p>
<h3 id="3-6-4-标记-复制算法"><a href="#3-6-4-标记-复制算法" class="headerlink" title="3.6.4: 标记-复制算法:"></a>3.6.4: 标记-复制算法:</h3><h4 id="3-6-4-1-传统做法"><a href="#3-6-4-1-传统做法" class="headerlink" title="3.6.4.1: 传统做法:"></a>3.6.4.1: 传统做法:</h4><p>简称为复制算法.主要是为了解决标记-清除算法的空间碎片问题.主要思路是:把内存区域分成两半,每次只使用其中的一半,在进行垃圾收集时,把标记为存活的对象整齐的复制到另外一半内存区域中去,然后把当前半区所有的内存回收掉.</p>
<p>这种算法也有两个主要问题:一是为很多对象复制内存,会产生大量的内存复制的开销,所以主要用来回收新生代的对象.,二是显而易见的,每次都有一半的内存没有使用,造成巨大的浪费.</p>
<p>![image-20220904114352640](C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\blog\myblog\source_posts\image-20220904114352640.png)</p>
<h4 id="3-6-4-2-优化方案-Apple式回收"><a href="#3-6-4-2-优化方案-Apple式回收" class="headerlink" title="3.6.4.2: 优化方案:Apple式回收:"></a>3.6.4.2: 优化方案:Apple式回收:</h4><p>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</p>
<p>当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活.因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。</p>
<h3 id="3-6-5-标记-整理算法"><a href="#3-6-5-标记-整理算法" class="headerlink" title="3.6.5: 标记-整理算法:"></a>3.6.5: 标记-整理算法:</h3><p>复制算法的优化方案需要老年代进行内存担保,所以并不适用于老年代的垃圾回收.而标记-整理算法的思路是:首先标记对象,然后让所有存活的对象都向内存的同一个方向移动,然后清除掉边界以外的内存.</p>
<p>![image-20220904115432889](C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\blog\myblog\source_posts\image-20220904115432889.png)</p>
<p>显而易见,这种算法与标记-清除算法的区别是这种算法会移动对象,而标记-清除算法不会移动对象.</p>
<p>对老年代而言,一般有大多数对象再次存活,频繁的移动对象势必要带来沉重的内存开销,而且这种对象移动操作必须要全程暂停用户应用程序才能进行.</p>
<p>但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。</p>
<p>综上所述,是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。</p>
<p>吞吐量:实质是赋值器（Mutator，可以理解为使用垃圾收集的用户程序，本书为便于理解，多数地方用“用户程序”或“用户线程”代替）与收集器的效率总和。在这个案例中,即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。</p>
<p>另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p>
<h1 id="4-虚拟机执行子系统"><a href="#4-虚拟机执行子系统" class="headerlink" title="4.虚拟机执行子系统:"></a>4.虚拟机执行子系统:</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1: 概述:"></a>4.1: 概述:</h2><p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p>
<p>“计算机只认识0和1，所以我们写的程序需要被编译器翻译成由0和1构成的二进制格式才能被计算机执行。”十多年过去了，今天的计算机仍然只能识别0和1，但由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，把我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p>
<h2 id="4-2-字节码"><a href="#4-2-字节码" class="headerlink" title="4.2: 字节码:"></a>4.2: 字节码:</h2><p>字节码是一种中间状态的二进制代码,由字母和数字组成.</p>
<p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石.</p>
<p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。</p>
<p>Java语言中的各种语法、关键字、常量变量和运算符号的语义最终都会由多条字节码指令组合来表达，这决定了字节码指令所能提供的语言描述能力必须比Java语言本身更加强大才行。因此，有一些Java语言本身无法有效支持的语言特性并不代表在字节码中也无法有效表达出来，这为其他程序语言实现一些有别于Java的语言特性提供了发挥空间。</p>
<p>![image-20220926102257194](C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\blog\myblog\source_posts\image-20220926102257194.png)</p>
<h2 id="4-3-Class文件"><a href="#4-3-Class文件" class="headerlink" title="4.3: Class文件:"></a>4.3: Class文件:</h2><p>Class文件是由用户编写完程序后,通过编译器生成的应用程序文件,主要由一条条的字节码指令组成.任何一个Class文件都对应着唯一的一个类或接口的定义信息.</p>
<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符.</p>
<p>下面简要介绍下Class文件的结构:</p>
<h3 id="4-3-1-开头"><a href="#4-3-1-开头" class="headerlink" title="4.3.1: 开头:"></a>4.3.1: 开头:</h3><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
<p>不仅是Class文件，很多文件格式标准中都有使用魔数来进行身份识别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆。</p>
<p>Class文件的魔数取得很有“浪漫气息”， 值为0xCAFEBABE.</p>
<p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p>
<h3 id="4-3-2-常量池"><a href="#4-3-2-常量池" class="headerlink" title="4.3.2: 常量池:"></a>4.3.2: 常量池:</h3><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库.</p>
<p>由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值.</p>
<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p>
<p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>
<p>·被模块导出或者开放的包（Package）</p>
<p>·类和接口的全限定名（Fully Qualified Name）</p>
<p>·字段的名称和描述符（Descriptor）</p>
<p>·方法的名称和描述符</p>
<p>·方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</p>
<p>·动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</p>
<p>Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接（具体见第7章）。也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在下一章介绍虚拟机类加载过程时再详细讲解。</p>
<h3 id="4-3-3-访问接口"><a href="#4-3-3-访问接口" class="headerlink" title="4.3.3: 访问接口:"></a>4.3.3: 访问接口:</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final；等等。</p>
<h3 id="4-3-4-类索引、父类索引与接口索引集合"><a href="#4-3-4-类索引、父类索引与接口索引集合" class="headerlink" title="4.3.4: 类索引、父类索引与接口索引集合:"></a>4.3.4: 类索引、父类索引与接口索引集合:</h3><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后.</p>
<p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合 （interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定该类型的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p>
<h3 id="4-3-5-字段表集合"><a href="#4-3-5-字段表集合" class="headerlink" title="4.3.5: 字段表集合:"></a>4.3.5: 字段表集合:</h3><p>字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>
<h3 id="4-3-6-方法表集合"><a href="#4-3-6-方法表集合" class="headerlink" title="4.3.6: 方法表集合:"></a>4.3.6: 方法表集合:</h3><p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项.</p>
<p>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面.</p>
<p>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。特征签名是指一个方法中各个参数在常量池中的字段符号 引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p>
<h3 id="4-3-7-字节码指令简介"><a href="#4-3-7-字节码指令简介" class="headerlink" title="4.3.7: 字节码指令简介:"></a>4.3.7: 字节码指令简介:</h3><p>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构.</p>
<p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。</p>
<p>由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不能够超过256条；</p>
<p>如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效正确地工作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">自动计算PC寄存器的值加1; </span><br><span class="line"></span><br><span class="line">根据PC寄存器指示的位置，从字节码流中取出操作码; </span><br><span class="line"></span><br><span class="line">if (字节码存在操作数) 从字节码流中取出操作数; </span><br><span class="line"></span><br><span class="line">执行操作码所定义的操作; </span><br><span class="line"></span><br><span class="line">&#125; while (字节码流长度 &gt; 0); </span><br></pre></td></tr></table></figure>

<h3 id="4-3-8-公有设计，私有实现"><a href="#4-3-8-公有设计，私有实现" class="headerlink" title="4.3.8: 公有设计，私有实现:"></a>4.3.8: 公有设计，私有实现:</h3><p>《Java虚拟机规范》描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。这些内容与硬件、操作系统和具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看作程序在各种Java平台实现之间互相安全地交互的手段。</p>
<p>任何一款Java虚拟机实现都必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。</p>
<p>在满足《Java虚拟机规范》的约束下对具体实现做出修改和优化也是完全可行的，并且《Java虚拟机规范》中明确鼓励实现者这样去做。只要优化以后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整保持，那实现者就可以选择以任何方式去实现这些语义，虚拟机在后台如何处理Class文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可.</p>
<h2 id="4-4-虚拟机类加载机制"><a href="#4-4-虚拟机类加载机制" class="headerlink" title="4.4: 虚拟机类加载机制:"></a>4.4: 虚拟机类加载机制:</h2><h3 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1: 概述:"></a>4.4.1: 概述:</h3><p>类加载:</p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型.</p>
<p>与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为Java应用提供了极高的扩展性和灵活性，</p>
<p>例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。</p>
<h3 id="4-4-2-类加载的过程概述"><a href="#4-4-2-类加载的过程概述" class="headerlink" title="4.4.2: 类加载的过程概述:"></a>4.4.2: 类加载的过程概述:</h3><p>类的加载主要由以下七个阶段组成.</p>
<h3 id="4-4-3-类加载的时机"><a href="#4-4-3-类加载的时机" class="headerlink" title="4.4.3: 类加载的时机:"></a>4.4.3: 类加载的时机:</h3><p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。</p>
<p>但是对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<p>1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：</p>
<p>·使用new关键字实例化对象的时候。</p>
<p>·读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</p>
<p>·调用一个类型的静态方法的时候。</p>
<p>2）使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p>
<p>3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。</p>
<h3 id="4-4-4-加载阶段"><a href="#4-4-4-加载阶段" class="headerlink" title="4.4.4: 加载阶段:"></a>4.4.4: 加载阶段:</h3><p>“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段.主要完成三件事:</p>
<p>1）通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入</p>
<p>口。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot笔记</title>
    <url>/2023/01/17/Springboot%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Springboot笔记"><a href="#Springboot笔记" class="headerlink" title="Springboot笔记"></a>Springboot笔记</h1><p>Springboot的复杂性不是来自他处理的对象,而是来自他自身,是来自不断演进发展的springboot带来的时间维度上的复杂性.</p>
<h1 id="1-Web前后端分离基本原理-Spring-MVC"><a href="#1-Web前后端分离基本原理-Spring-MVC" class="headerlink" title="1.Web前后端分离基本原理:Spring MVC"></a>1.Web前后端分离基本原理:Spring MVC</h1><p>用户在view(视图层)进行操作,该层调用controller的接口进行逻辑处理,controller调用service层的方法,service层的数据持久化又需要dao层的数据库支持.</p>
<h1 id="2-Springboot介绍"><a href="#2-Springboot介绍" class="headerlink" title="2.Springboot介绍:"></a>2.Springboot介绍:</h1><p>Springboot是一个java ee框架,是Spring的升级版,采用前后端分离的方式产出接口,实现网页,微信小程序,app的开发,他的特点是简化配置,部署.监控</p>
<h1 id="3-Springboot项目上手"><a href="#3-Springboot项目上手" class="headerlink" title="3.Springboot项目上手:"></a>3.Springboot项目上手:</h1><h2 id="3-1-创建Springboot项目："><a href="#3-1-创建Springboot项目：" class="headerlink" title="3.1 创建Springboot项目："></a>3.1 创建Springboot项目：</h2><p>idea：file-new-Spring Initializr</p>
<h2 id="3-2-Springboot项目结构："><a href="#3-2-Springboot项目结构：" class="headerlink" title="3.2 Springboot项目结构："></a>3.2 Springboot项目结构：</h2><p>新建项目后，会得到一个文件夹，其中一级文件需要关注最重要的是src文件夹和pom.xml文件，pom.xml是依赖(依赖？可以理解认为一些外部包)的配置文件，其中src包括main文件夹和text文件夹，text文件夹存放测试文件，main包括java文件夹（用于写业务程序），resources文件夹（存放项目的配置）</p>
<h2 id="3-3-新建Controller层："><a href="#3-3-新建Controller层：" class="headerlink" title="3.3 新建Controller层："></a>3.3 新建Controller层：</h2><h3 id="3-3-1-Controller介绍："><a href="#3-3-1-Controller介绍：" class="headerlink" title="3.3.1 Controller介绍："></a>3.3.1 Controller介绍：</h3><p>在java文件夹下，创建类名为某Controller类进行编写。Controller是接口层，是直接和前端交互的地方，它由一个一个的接口组成.（接口：接收一部分数据，进行内部处理，返回另一组数据）</p>
<h3 id="3-3-2-注解："><a href="#3-3-2-注解：" class="headerlink" title="3.3.2 注解："></a>3.3.2 注解：</h3><p>在类上方增加@RestController注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class  ctivityController &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>用于标识这个类是Controller类，同时这个注解是@Controller和@ResposeBody两个注解的结合，可以直接接收前端的json格式的数据，同时返回json格式的数据</p>
<h3 id="3-3-3-基本结构："><a href="#3-3-3-基本结构：" class="headerlink" title="3.3.3 基本结构："></a>3.3.3 基本结构：</h3><p>Controller类由一个一个的接口构成，其基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/addScore&quot;)</span><br><span class="line">public Result addScore (@RequestParam(&quot;addStrips&quot;) List&lt;AddStrip&gt; addStrips)&#123;</span><br><span class="line">    return activityService.addScore(name, addStrips);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口就是一些注解加上一个方法，必须要有的是形如@PostMapping一样的注解，表明了这个接口访问的地址，以及访问的方式等信息</p>
<p>而对于需要传参数的接口，需要加类似@RequestParam类的接口，加在方法所需的参数前，表明了这个参数传来的名称与格式。</p>
<h3 id="3-3-4-Post与Get请求："><a href="#3-3-4-Post与Get请求：" class="headerlink" title="3.3.4: Post与Get请求："></a>3.3.4: Post与Get请求：</h3><p>post请求的参数在reposeBody中，可以使用@RequestBody获取数据.get请求的参数体现在url中，不能使用@RequestBody获取数据。</p>
<p>一般因为post请求实现了信息的隐藏，在url中看不到，所以认为post请求比get请求更安全。</p>
<h3 id="3-3-5：-RequestParam与-RequestBody："><a href="#3-3-5：-RequestParam与-RequestBody：" class="headerlink" title="3.3.5：@RequestParam与@RequestBody："></a>3.3.5：@RequestParam与@RequestBody：</h3><h4 id="3-3-5-1-RequestParam"><a href="#3-3-5-1-RequestParam" class="headerlink" title="3.3.5.1: @RequestParam:"></a>3.3.5.1: @RequestParam:</h4><p>用来处理Content-Type: 为 application&#x2F;x-www-form-urlencoded编码的内容。（Http协议中，如果不指定Content-Type，则默认传递的参数就是application&#x2F;x-www-form-urlencoded类型.POST类型和GET类型都可以使用@RequestParam注解来接收参数.</p>
<p>@RequestParam注解有三个参数,required 表示是否必须，默认为 true，必须。defaultValue 可设置请求参数的默认值，如果设置了该值，required&#x3D;true将失效，自动为false,如果没有传该参数，就使用默认值。value 为接收url的参数名（相当于key值）.</p>
<h4 id="3-3-5-2-application-x2F-x-www-form-urlencoded"><a href="#3-3-5-2-application-x2F-x-www-form-urlencoded" class="headerlink" title="3.3.5.2: application&#x2F;x-www-form-urlencoded:"></a>3.3.5.2: application&#x2F;x-www-form-urlencoded:</h4><p>application&#x2F;x-www-form-urlencoded：是最常见的 POST 提交数据的方式，浏览器的原生表单如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据，它是未指定属性时的默认值。 数据发送过程中会对数据进行序列化处理，以键值对形式?key1&#x3D;value1&amp;key2&#x3D;value2的方式发送到服务器。 数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘&#x3D;’ 分隔键和值。非字母或数字的字符会被 percent-encoding。在axios中当请求参数为qs.stringify(data)时，会以此方式提交数据。后台如果使用对象接收的话,可以自动封装成对象.</p>
<h4 id="3-3-5-3-RequestBody"><a href="#3-3-5-3-RequestBody" class="headerlink" title="3.3.5.3: @RequestBody:"></a>3.3.5.3: @RequestBody:</h4><p>@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非 Content-Type: application&#x2F;x-www-form-urlencoded编码格式的数据，比如：application&#x2F;json、application&#x2F;xml等类型的数据。</p>
<h4 id="3-3-5-4-application-x2F-json"><a href="#3-3-5-4-application-x2F-json" class="headerlink" title="3.3.5.4: application&#x2F;json:"></a>3.3.5.4: application&#x2F;json:</h4><p>随着 json 规范的越来越流行，并且对浏览器支持程度原来越好，许多开发人员在请求头中加入 content-type: application&#x2F;jsonapplication&#x2F;json ，这样做可以方便的提交复杂的结构化数据，这样特别适合restful接口。它告诉服务器请求的主体内容是 json 格式的字符串，服务器端会对json字符串进行解析，json 格式要支持比键值对复杂得多的结构化数据。这种方式的好处就是前端人员不需要关心数据结构的复杂度，只需要标准的json格式就能提交成功。当在 axios 中请求参数为普通对象时，POST 请求默认发送的是 application&#x2F;json 格式的数据。 application&#x2F;json 需要封装成对象的话，可以加上 @RequestBody 进行注解。</p>
<p>综上,当传输实体类属性时,用@RequestParam(用@RequestBody)也可,但是传入List类型的数据时,由于@RequestParam所要求的application&#x2F;x-www-form-urlencoded识别不了,所以只能通过@RequestBody传输数据.</p>
<p>@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。</p>
<h1 id="4-主启动类："><a href="#4-主启动类：" class="headerlink" title="4. 主启动类："></a>4. 主启动类：</h1><p>在java文件夹下，自动生成的一个类，下面有一个主方法。</p>
<p>这个类用于项目的启动，不需要做任何的修改。</p>
<h1 id="5-修改项目配置："><a href="#5-修改项目配置：" class="headerlink" title="5.修改项目配置："></a>5.修改项目配置：</h1><p>位于resources文件夹下，为了更快的写配置，删除掉该文件夹下原有的application.properties文件，新建一个application.yml文件</p>
<p>格式：</p>
<p>properties：</p>
<p>key&#x3D;value</p>
<p>yml：</p>
<p>key: value（注意value前面有一个空格）</p>
<p>完成前三步后,就可以运行程序,并在网页上访问相应的接口的到相应的数据,但这样不能实现数据的变化,而要做到这一点,就需要进行数据库操作.</p>
<h1 id="6-数据库操作"><a href="#6-数据库操作" class="headerlink" title="6.数据库操作:"></a>6.数据库操作:</h1><h2 id="6-1-技术选型"><a href="#6-1-技术选型" class="headerlink" title="6.1 技术选型:"></a>6.1 技术选型:</h2><p>选用mysql数据库,使用jpa进行操作</p>
<p>jpa:jpa: java persistence(持久化) api ,一种对象持久化的标准.</p>
<p>spring-data-jpa:根据jpa开发出的一个产品.</p>
<h2 id="6-2-操作过程"><a href="#6-2-操作过程" class="headerlink" title="6.2 操作过程:"></a>6.2 操作过程:</h2><h3 id="6-2-1-添加maven依赖"><a href="#6-2-1-添加maven依赖" class="headerlink" title="6.2.1 添加maven依赖:"></a>6.2.1 添加maven依赖:</h3><p> spring-data-jpa.</p>
<p> mysql-connector-java</p>
<h3 id="6-2-2-yml配置"><a href="#6-2-2-yml配置" class="headerlink" title="6.2.2 yml配置:"></a>6.2.2 yml配置:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">  url: jdbc:mysql://localhost:3306/dbaddscore(你自己的数据库名)</span><br><span class="line">  					ip地址:端口</span><br><span class="line">  username: root</span><br><span class="line">  password: (你自己的密码)</span><br><span class="line">jpa:</span><br><span class="line">  hibernate:</span><br><span class="line">    ddl-auto: update(意味着没有数据就新建,有数据也保留),还可用create(每次运行都覆盖数据)等</span><br><span class="line">  show-sql: true(在控制台展示sql语句)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="6-2-3-链接数据库"><a href="#6-2-3-链接数据库" class="headerlink" title="6.2.3 链接数据库:"></a>6.2.3 链接数据库:</h3><p>用Navicat与数据库连接,在里面创建即可,编码选择UTF-8.</p>
<p>只需要新建数据库即可,无需自己建表.</p>
<h3 id="6-2-4-编写实体类"><a href="#6-2-4-编写实体类" class="headerlink" title="6.2.4: 编写实体类:"></a>6.2.4: 编写实体类:</h3><h4 id="6-2-4-1-实体类注解"><a href="#6-2-4-1-实体类注解" class="headerlink" title="6.2.4.1 实体类注解:"></a>6.2.4.1 实体类注解:</h4><p>完成数据库连接后即可编写实体类,实体类是会数据库中储存的类.</p>
<p>建立类后,在类的上方加@Entity注解,表示这是一个实体类,在项目运行时,会自动创建由这个类所映射的表,以及里面的所有数据.</p>
<p>注意:在此类中一定要有一个无参的构造方法,否则会报错,可以在类上方通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br></pre></td></tr></table></figure>

<p>这两个注解来实现.</p>
<h4 id="6-2-4-2-数据库主键"><a href="#6-2-4-2-数据库主键" class="headerlink" title="6.2.4.2 数据库主键:"></a>6.2.4.2 数据库主键:</h4><p>数据库主键是这一行数据在这张表中唯一的标识,在一张表中,每条数据的这个字段一定不相同,可以作为其他表的外键,让其他表通过这个属性的值找到这条记录</p>
<p>主键注解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * id</span><br><span class="line"> */</span><br><span class="line">@Id  用于表征接下来这个数据是主键</span><br><span class="line">@GeneratedValue(strategy = GenerationType.IDENTITY) 主键策略,当前是主键自动生成</span><br><span class="line">private Integer id;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-5-建立数据库接口"><a href="#6-2-5-建立数据库接口" class="headerlink" title="6.2.5: 建立数据库接口:"></a>6.2.5: 建立数据库接口:</h3><p>建立接口名为实体类名+Repository,继承JpaRepository,同时在类上方添加@Repository注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public interface ActivityRepository extends JpaRepository&lt;Activity,Integer&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数是类名,第二个参数是类的主键数据类型.</p>
<p>在没有额外方法的时候,数据库中不用写任何代码.</p>
<h3 id="6-2-6-接口实例化"><a href="#6-2-6-接口实例化" class="headerlink" title="6.2.6: 接口实例化:"></a>6.2.6: 接口实例化:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">UserRepository userRepository;</span><br></pre></td></tr></table></figure>

<p>在所需要的类的上方添加这个,就可以使用这个新建的对象调用数据库中各种方法.</p>
<p>简单的数据库操作都用自带的方法:如</p>
<p>.findAll() 返回数据库中所有数据.</p>
<p>.save() 保存一个对象</p>
<h3 id="6-2-7-修改对象数据"><a href="#6-2-7-修改对象数据" class="headerlink" title="6.2.7: 修改对象数据:"></a>6.2.7: 修改对象数据:</h3><p>修改时,通过find方法找到对象,修改其中的数据,注意不要修改其主键,然后重新使用数据库保存,数据库就会根据主键自动覆盖之前的数据.</p>
<h3 id="6-2-8-自定义数据库操作"><a href="#6-2-8-自定义数据库操作" class="headerlink" title="6.2.8 自定义数据库操作:"></a>6.2.8 自定义数据库操作:</h3><p>jpa中共有三种方法:</p>
<p> (1) 默认的方法:</p>
<p> (2) 自定义规则名的方法:</p>
<p>只需要按规定的jpa格式写好对应的方法名,就能自动获得方法,不用自己写,如:</p>
<p>List findActivityByYear(Integer year);</p>
<p> (3) 自定义sql语句:</p>
<p>使用@Query注解(注意jdbc和jpa两个包都支持这个注解,注意不要导错包):</p>
<p>格式为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Query(value = &quot;sql语句&quot;,nativeQuery = &quot;&quot;)</span><br><span class="line">方法相关信息</span><br></pre></td></tr></table></figure>

<p>nativeQuery默认为false,意为hql,即字段用的是实体类中的名字,true表示sql,字段用的是数据库中的名字.</p>
<h3 id="6-2-9-级联操作"><a href="#6-2-9-级联操作" class="headerlink" title="6.2.9 级联操作:"></a>6.2.9 级联操作:</h3><h4 id="6-2-9-1-介绍"><a href="#6-2-9-1-介绍" class="headerlink" title="6.2.9.1: 介绍:"></a>6.2.9.1: 介绍:</h4><p>级联操作用于维护有关系的几张表之间的关系.本质上是用一张表的主键数据,成为另一张上的外键数据,操作级联更新,级联删除等操作.</p>
<p>启用级联操作时,当更新一个表的主键值,系统将会相应的更新其对应的所有外键值,如果删除主键,相应的外键也会一同删除.</p>
<p>比如角色有多个课程,课程也会被多个角色选.适合于多对多关系.jpa会自动生成中间表，java的entity代码中只需要User类和Role类,无需创建中间表user_role类（sql建表语句中可以手动创建该中间表，不手动创建jpa系统也会帮忙自动创建).</p>
<p>当角色类维护外键时,若角色名字改变,课程列表中的角色名也会随之改变,若角色删除,课程列表中也会删除这个学生,</p>
<p>但课程没有维护外键的能力,也就是说当课程名称改变时,学生课表中课程的姓名不会改变,课程删除时,学生课表中的课程也不会删除.</p>
<h4 id="6-2-9-2-使用"><a href="#6-2-9-2-使用" class="headerlink" title="6.2.9.2: 使用:"></a>6.2.9.2: 使用:</h4><p>以manytomany的多对多关系为例子,进行配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在控制类的关联字段上加上如下配置:</span><br><span class="line">@ManyToMany(fetch = FetchType.LAZY,targetEntity = User.class)</span><br><span class="line">//fetch:可取的值有FetchType.EAGER和FetchType.LAZY，前者表示主类被加载时加载，后者表示被访问时才会加载</span><br><span class="line">@JoinTable(name=&quot;users_courses&quot;,uniqueConstraints = &#123;@UniqueConstraint(columnNames = &#123;&quot;u_id&quot;,&quot;c_id&quot;&#125;)&#125;,</span><br><span class="line">joinColumns = &#123;@JoinColumn(name = &quot;u_id&quot;,referencedColumnName = &quot;id&quot;)&#125;,</span><br><span class="line">inverseJoinColumns = &#123;@JoinColumn(name = &quot;c_id&quot;,referencedColumnName = &quot;id&quot;),&#125;</span><br><span class="line">//name:主键名称</span><br><span class="line">//uniqueConstraints:唯一约束的联合主键</span><br><span class="line">//joinColumns:当前对象在中间表中的外键,此处应为id</span><br><span class="line">//inverseJoinColumns:对方对象在中间表中的外键,此处为id</span><br><span class="line">//一个角色有多个课程</span><br><span class="line">private List&lt;Course&gt; courses = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">在另一方的关联字段下面加上如下配置:</span><br><span class="line">//一个课程可以被多个角色选择</span><br><span class="line">//使得course放弃外键的维护权利</span><br><span class="line">@ManyToMany(mappedBy = &quot;courses&quot;,cascade = CascadeType.ALL)</span><br><span class="line">//这个cascade字段定义了级联的类型.主要有:CascadeType.PERSIST（级联新建）、CascadeType.REMOVE（级联删除）、CascadeType.REFRESH（级联刷新）、CascadeType.MERGE（级联更新）、CascadeType.ALL（选择全部）.一般不推荐使用all(?).</span><br><span class="line">private List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h1 id="7-单元测试"><a href="#7-单元测试" class="headerlink" title="7.单元测试:"></a>7.单元测试:</h1><h2 id="7-1-service层测试"><a href="#7-1-service层测试" class="headerlink" title="7.1 service层测试:"></a>7.1 service层测试:</h2><p>对应于不进行数据库和接口访问,只针对某种特定的逻辑(比如测试获取当前时间是否正确等)</p>
<p>在text文件夹下创建测试类,在类前加@SpringBootTest注解.</p>
<p>在这个类下面写方法,每个方法前面加@Test注解,每个方法都可以单独,直接运行进行测试.</p>
<p>注意方法不能有返回值,股返回值的类型是void.</p>
<h1 id="8-其他技术"><a href="#8-其他技术" class="headerlink" title="8.其他技术:"></a>8.其他技术:</h1><p>前七部分已经可以写出一般的业务逻辑,其他的零零碎碎的技术,用于更好地优化逻辑和提升代码质量.</p>
<h2 id="8-1-结果类"><a href="#8-1-结果类" class="headerlink" title="8.1:结果类:"></a>8.1:结果类:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Result&lt;T&gt;&#123;</span><br><span class="line">    //    返回的状态码</span><br><span class="line">    private int code;</span><br><span class="line">    //    返回的状态信息</span><br><span class="line">    private String message;</span><br><span class="line">    //    返回的具体数据</span><br><span class="line">    private T data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后端向前端返回数据时,不直接返回数据,而是一般封装一个结果类进行返回,便于前端获取返回结果的状态(返回成功or出现错误),同时获取返回的具体信息,最后获取返回的数据.由于不知道返回的具体类型,故使用泛型.</p>
<p>传入什么类型均可,在无返回具体数据时可返回null.</p>
<p>给接口传入参数时,框架自动把传入的json转换成java对象,结果返回时,同样由框架把java对象转换成json对象.</p>
<h2 id="8-2-项目配置"><a href="#8-2-项目配置" class="headerlink" title="8.2: 项目配置:"></a>8.2: 项目配置:</h2><p>application的dev和prod配置分开.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  freemarker:</span><br><span class="line">    check-template-location: false</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  jackson:</span><br><span class="line">    time-zone: GMT+8</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      repositories:</span><br><span class="line">        enabled: false</span><br></pre></td></tr></table></figure>

<p>使用主配置文件里profiles字段来选择使用的配置文件.</p>
<h2 id="8-3-项目部署"><a href="#8-3-项目部署" class="headerlink" title="8.3 项目部署:"></a>8.3 项目部署:</h2><h3 id="8-3-1-打包"><a href="#8-3-1-打包" class="headerlink" title="8.3.1: 打包:"></a>8.3.1: 打包:</h3><p>右上角maven图标,依次点击刷新,clean,package,自动在文件目录下生成一个jar包.</p>
<h3 id="8-3-2-连接服务器"><a href="#8-3-2-连接服务器" class="headerlink" title="8.3.2: 连接服务器"></a>8.3.2: 连接服务器</h3><h3 id="8-3-3-部署"><a href="#8-3-3-部署" class="headerlink" title="8.3.3: 部署:"></a>8.3.3: 部署:</h3><p>(1)进入文件夹 cd 文件夹名</p>
<p>(2)上传jar包</p>
<p>(3)运行jar包</p>
<p>nohup java -jar jar包名称.jar &gt; 日志名 2&gt;&amp;1</p>
<p>(4)根据端口查看进程:</p>
<p>lsof -i:端口名</p>
<p>如果不输出即意味着这个端口当前没有进程</p>
<p>(5)杀死进程:</p>
<p>kill -9 进程名</p>
<h2 id="8-4-跨域问题"><a href="#8-4-跨域问题" class="headerlink" title="8.4: 跨域问题:"></a>8.4: 跨域问题:</h2><p>跨域:从一个域名访问另外一个域名时,域名.端口.协议任何一个不一样都会造成无法访问的情况.</p>
<p>预检:进行跨域访问时,首先会发送预检请求,如果服务器允许的话才会再次发送真正的(options)请求.</p>
<p>解决方案:cors:cross-origin resource sharing 一种跨域资源共享方案.</p>
<h4 id="8-4-1-简单请求"><a href="#8-4-1-简单请求" class="headerlink" title="8.4.1 简单请求:"></a>8.4.1 简单请求:</h4><p>没有人为添加字段的get,post,head(?)的请求,解决方式:</p>
<p>在Controller类上方添加@CrossOrigin(origins &#x3D; “*”)注解</p>
<h4 id="8-4-2-复杂请求"><a href="#8-4-2-复杂请求" class="headerlink" title="8.4.2 复杂请求:"></a>8.4.2 复杂请求:</h4><p>当需要在header中添加token等字段时,需要使用全局的跨域配置类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">//表征这是一个配置,只有这个配置才会被框架识别并自动使用.</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter()&#123;</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.setAllowCredentials(false);</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;,corsConfiguration);</span><br><span class="line">        CorsFilter corsFilter = new CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">        return corsFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-5-事务处理"><a href="#8-5-事务处理" class="headerlink" title="8.5: 事务处理:"></a>8.5: 事务处理:</h2><p>事务:对数据库的若干操作构成的集合.</p>
<p>事物的出现是为了操作的可靠性,通过回退机制使数据安全.</p>
<p>事务分为编程式事务(通过手写代码)和声明式事务(通过AOP)两种方式.</p>
<p>声明式事务:在方法或者类(再类上添加表示对类下的所有方法生效)上加@Tranactional注解</p>
<p>当该方法出现异常时,该方法中对数据库的所有的操作不会被提交.</p>
<p>比如在进行取款操作时,如果没有事务,若在从银行取出钱后,发生了异常导致用户没有收到钱,就会导致钱的总数减少从而出现问题,而对这个方法使用事务就可以很好地解决这个问题.</p>
<h2 id="8-6-AOP-面向切面编程"><a href="#8-6-AOP-面向切面编程" class="headerlink" title="8.6: AOP(面向切面编程):"></a>8.6: AOP(面向切面编程):</h2><h4 id="8-6-1-定义"><a href="#8-6-1-定义" class="headerlink" title="8.6.1 定义:"></a>8.6.1 定义:</h4><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP(面向对象编程)的延续，是软件开发中的一个<br>热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高<br>了开发的效率。</p>
<p>简单来说,就是在面向对象的,纵向设计的复杂程序中,横向的关注程序的不同位置中复用代码的地方(切面),进行统一的处理.比如打印程序执行日志之类的.</p>
<h4 id="8-6-2-概念"><a href="#8-6-2-概念" class="headerlink" title="8.6.2 概念:"></a>8.6.2 概念:</h4><p>切面(aspect): 类似于java类,在里面包含着一些pointcut以及对应的advice.</p>
<p>连接点(joint point): 程序中明确定义的点,比如说方法调用,异常处理什么的.一般所有的同类过程都可以被认为是连接点.</p>
<p>切点(point cut): 切面的组成部分,表示一组特定的连接点,advice发生在这些地方.</p>
<p>增强(advice): 表明了对在pointcut里面定义的过程所进行的操作.</p>
<h4 id="8-6-3-基本使用"><a href="#8-6-3-基本使用" class="headerlink" title="8.6.3 基本使用:"></a>8.6.3 基本使用:</h4><p>以打印执行日志为例子.</p>
<h5 id="8-6-3-1-引入依赖"><a href="#8-6-3-1-引入依赖" class="headerlink" title="8.6.3.1 引入依赖:"></a>8.6.3.1 引入依赖:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h5 id="8-6-3-2-新建一个切面类"><a href="#8-6-3-2-新建一个切面类" class="headerlink" title="8.6.3.2 新建一个切面类:"></a>8.6.3.2 新建一个切面类:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//新建切面</span><br><span class="line">@Aspect</span><br><span class="line">//这个注解的作用是表明这是一个切面类</span><br><span class="line">@Component</span><br><span class="line">//这个注解的作用是把当前类注入到Spring容器内</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">    </span><br><span class="line">    //切点:这个注解用来筛选所有的连接点,可以使用通配符.</span><br><span class="line">    @Pointcut(&quot;execution(public * com.controller.*.*(..))&quot;)</span><br><span class="line">    public void LogAspect()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //这是对切点的增强(advice)</span><br><span class="line">    //这些方法的参数是JoinPoint,里面包含了类名,被切面的方法名,被切面的方法参数等信息.</span><br><span class="line">    </span><br><span class="line">    @Before(&quot;LogAspect()&quot;)</span><br><span class="line">    //在方法前执行这个方法</span><br><span class="line">    public void doBefore(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;doBefore&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;LogAspect()&quot;)</span><br><span class="line">    //在方法后执行这个方法</span><br><span class="line">    public void doAfter(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;doAfter&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(&quot;LogAspect()&quot;)</span><br><span class="line">    //在方法执行后,并且返回结果后执行</span><br><span class="line">    public void doAfterReturning(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;doAfterReturning&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(&quot;LogAspect()&quot;)</span><br><span class="line">    //在方法执行后,并且抛出异常后执行</span><br><span class="line">    public void deAfterThrowing(JoinPoint joinPoint)&#123;</span><br><span class="line">        System.out.println(&quot;deAfterThrowing&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;LogAspect()&quot;)</span><br><span class="line">    //环绕:在方法执行前后都执行.参数必须为ProceedingJoinPoint</span><br><span class="line">    public Object deAround(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line">        System.out.println(&quot;deAround&quot;);</span><br><span class="line">       	//获取当前类</span><br><span class="line">        Class&lt;?&gt; clazz = joinPoint.getClass();</span><br><span class="line">        //获取请求参数</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println((&quot;当前类名是:&quot;+clazz.getName()));</span><br><span class="line">        System.out.println(&quot;传入参数是&quot;+ Arrays.toString(args));</span><br><span class="line">        return joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有其他很多种使用方式,后续再一一进行学习.</p>
<h2 id="8-7-异常处理"><a href="#8-7-异常处理" class="headerlink" title="8.7: 异常处理:"></a>8.7: 异常处理:</h2><p>异常处理机制。异常处理机制能让程序在异常发生时，按照代码的预先设定的异常处理逻辑，针对性地处理异常，让程序尽最大可能恢复正常并继续执行，且保持代码的清晰。</p>
<h4 id="8-7-1-Java异常体系结构"><a href="#8-7-1-Java异常体系结构" class="headerlink" title="8.7.1 Java异常体系结构:"></a>8.7.1 Java异常体系结构:</h4><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。Throwable又派生出Error类和Exception类。</p>
<p>错误：Error类以及它的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p>
<p>异常：Exception以及它的子类，代表程序运行时发生的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。</p>
<p>Error和Exception的区别:</p>
<p> Error和Exception都有一个共同的根类是Throwable类。</p>
<p> Error是系统中的错误，程序员是不能改变的和处理的，一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。因此我们编写程序时不需要关心这类错误。</p>
<p> Exception，也就是我们经常见到的一些异常情况，表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv5rOi5ZOp5Liq5rOi,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></h4><p>异常通常分为两类:受检异常和运行异常.</p>
<p>受检异常(checked exception)是编译器要求必须处理的异常,否则编译不会通过.一般是一些发生概率非常高的异常.</p>
<p>运行异常则可处理也可不处理.相对来说一般发生的概率较低.</p>
<p>注意:虽然叫受检异常,但是编译阶段不会发生异常,因为异常就是new 异常对象,而只有运行时才可new对象,所以所有的异常都是程序运行时产生的.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv5rOi5ZOp5Liq5rOi,size_16,color_FFFFFF,t_70,g_se,x_16-1673792028306-1.png" alt="img"></p>
<h4 id="8-7-2-Java异常处理机制1-try-catch-finally结构"><a href="#8-7-2-Java异常处理机制1-try-catch-finally结构" class="headerlink" title="8.7.2 Java异常处理机制1: try-catch-finally结构:"></a>8.7.2 Java异常处理机制1: try-catch-finally结构:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">    try&#123;</span><br><span class="line">        ...... //可能产生异常的代码</span><br><span class="line">    &#125;</span><br><span class="line">    catch( ExceptionName1 e )&#123;</span><br><span class="line">        ...... //当产生ExceptionName1型异常时的处置措施</span><br><span class="line">    &#125;</span><br><span class="line">    catch( ExceptionName2 e )&#123;</span><br><span class="line">        ...... //当产生ExceptionName2型异常时的处置措施</span><br><span class="line">    &#125;</span><br><span class="line">    [ finally&#123;</span><br><span class="line">        ...... //无论是否发生异常，都无条件执行的语句</span><br><span class="line">    &#125; ]</span><br><span class="line"> </span><br><span class="line">语法解释：</span><br><span class="line">    try：</span><br><span class="line">        捕获异常的第一步是用try&#123;…&#125;语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。</span><br><span class="line">        如果发生异常，则尝试去匹配catch块，catch块可以有多个（因为try块可以出现多个不同类型异常）;</span><br><span class="line">        如果执行完try不管有没有发生异常，则接着去执行finally块和finally后面的代码（如果有的话）。			</span><br><span class="line">    catch (Exceptiontype e)：</span><br><span class="line">        在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</span><br><span class="line">        每一个catch块用于捕获并处理一个特定的异常，或者这异常类型的子类。Java可以将多个异常声明在一个catch中。 catch(Exception1 | Exception2 | Exception3 e)</span><br><span class="line">        catch后面的括号定义了异常类型和异常参数。如果异常与之匹配且是最先匹配到的，则虚拟机将使用这个catch块来处理异常。</span><br><span class="line">        在catch块中可以使用这个块的异常参数来获取异常的相关信息。异常参数是这个catch块中的局部变量，其它块不能访问。与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。</span><br><span class="line">            ①、getMessage() 获取异常信息，返回字符串。</span><br><span class="line">            ②、printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。</span><br><span class="line">        如果当前try块中发生的异常在后续的所有catch中都没捕获到，则先去执行finally，然后到这个函数的外部caller中去匹配异常处理器。</span><br><span class="line">        如果try中没有发生异常，则所有的catch块将被忽略。</span><br><span class="line">        注意：如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。比如：可以用 ArithmeticException 类作为参数的地方，就可以用RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。但不能是与ArithmeticException类无关的异常，如NullPointerException（catch中的语句将不会执行）。</span><br><span class="line"> </span><br><span class="line">    finally：</span><br><span class="line">        finally块通常是可选的。捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。</span><br><span class="line">        不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。</span><br><span class="line">        一个try至少要有一个catch块，否则， 至少要有1个finally块。但是finally不是用来处理异常的，finally不会捕获异常。</span><br><span class="line">        finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。 </span><br></pre></td></tr></table></figure>

<h4 id="8-7-2-Java异常处理机制2-throws结构"><a href="#8-7-2-Java异常处理机制2-throws结构" class="headerlink" title="8.7.2 Java异常处理机制2: throws结构:"></a>8.7.2 Java异常处理机制2: throws结构:</h4><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出。首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运行环境)。<br>throw exceptionObject 程序员也可以通过throw语句手动显式的抛出一个异常。throw语句的后面可以抛出的异常必须是Throwable或其子类的实例。throw 语句必须写在函数中，执行throw 语句的地方就是一个异常抛出点，它和由JRE自动形成的异常抛出点没有任何差别。</p>
<p>抛出的异常可以被调用这个方法的方法所捕获,多用于层层嵌套的调用方法的中间环节.比如shiro验证过程中,JWTFilter使用了myRealm进行token的验证,而如果验证出现问题,myRealm会抛出异常,然后会被调用它的JWTFilter所捕获,从而进行下一步的操作.</p>
<h4 id="8-7-3-Springboot异常处理"><a href="#8-7-3-Springboot异常处理" class="headerlink" title="8.7.3 Springboot异常处理:"></a>8.7.3 Springboot异常处理:</h4><p>Springboot对异常的处理内置了多种方式,比较好用的是使用全局异常处理:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//方法增强,只有@RsetController注解下的方法才会调用这个异常处理模式</span><br><span class="line">@RestControllerAdvice(annotations = RestController.class)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这个注解开启日志功能</span><br><span class="line">@Slf4j</span><br><span class="line"></span><br><span class="line">//这个注解注入到spring容器</span><br><span class="line">@Component</span><br><span class="line"></span><br><span class="line">public class GlobalExpectionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(MethodArgumentNotValidException.class)</span><br><span class="line">    //处理参数效验的异常</span><br><span class="line">    public Result handMethodArgumentNotValidException(MethodArgumentNotValidException e)&#123;</span><br><span class="line">        </span><br><span class="line">        //把异常对象e的message变成字符串,在日志上输出</span><br><span class="line">        log.error(&quot;参数效验异常!&quot;,e);</span><br><span class="line">        </span><br><span class="line">        //给前端返回结果</span><br><span class="line">        return new Result(401,e.getMessage(),null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-8-shiro-jwt实现权限验证"><a href="#8-8-shiro-jwt实现权限验证" class="headerlink" title="8.8 :shiro+jwt实现权限验证:"></a>8.8 :shiro+jwt实现权限验证:</h2><h3 id="8-8-1-shiro介绍"><a href="#8-8-1-shiro介绍" class="headerlink" title="8.8.1: shiro介绍:"></a>8.8.1: shiro介绍:</h3><p>shiro是一个java的安全框架,用于身份验证,授权,密码,会话管理等功能.能储存用户的登录凭证:session等,同时使用过滤器(filter)</p>
<p>对每个http请求进行过滤(根据接口和权限等信息限制访问).</p>
<p>shiro由三大部分组成:</p>
<p>(1)subject:当前操作的用户</p>
<p>(2)securitymanager:管理内部组件的实例,提供认证和授权的服务.</p>
<p>(3)realm:领域,是shiro和数据之间的连接器,相当与框架里的数据库.</p>
<h3 id="8-8-2-jwt介绍"><a href="#8-8-2-jwt介绍" class="headerlink" title="8.8.2: jwt介绍:"></a>8.8.2: jwt介绍:</h3><p>jwt是json web token的缩写,是目前最流行的跨域身份认证解决方案.本质上是一个特殊的字符串.</p>
<p>由三部分组成:header(头部),payload(负载),signature(签名).</p>
<p>(1): header:</p>
<p>{</p>
<p> “alg”: 表明签名所使用的算法,一般为hs256.</p>
<p> “typ”: 令牌的类型,一般为”JWT”</p>
<p>}</p>
<p>(2): payload:</p>
<p>这七个字段都是可选的,并没有个数限制.</p>
<p>{</p>
<p> “iss”: 发行</p>
<p> “exp”: 到期时间</p>
<p> “sub”: 主题</p>
<p> “aud”: 用户</p>
<p> “nbf”: 在此之前不可以用</p>
<p> “iat”: 发布时间</p>
<p> “jti”: JWT id</p>
<p>}</p>
<p>这两个部分用base64算法变成两个字符串,由于算法是已知的,故任何人都会对其进行解密,所以不能在里面存储敏感的信息.</p>
<p>(3): signature:签名哈希</p>
<p>生成这部分需要(1)和(2)部分的两个字符串,还需要一个秘钥,储存在服务器中.通过(1)中指定的签名算法,生成第三部分.</p>
<p>第三部分的作用是检验token有没有被篡改.</p>
<p>由于哈希是不可逆的,所以真正进行验证时,会用算法解密前两部分,然后用得到的算法和存储在服务器端的秘钥重新进行加密得到第三部分,然后与客户端所传来的数据进行对比,如果相同就验证成功,如果不同就验证失败.</p>
<h3 id="8-8-3-cookie-session和token"><a href="#8-8-3-cookie-session和token" class="headerlink" title="8.8.3: cookie,session和token:"></a>8.8.3: cookie,session和token:</h3><p>(1)首先我们要知道,网页有静态网页和动态网页之分.静态网页由html编写,网页上所有的内容都已经被指定好了,不能灵活的显示内容,无法根据传入的参数实现动态的变化.而动态网页可以动态的解析参数,从而呈现不同的内容.</p>
<p>(2)无状态http:</p>
<p>一般的网页是由客户端发送请求给服务器,服务器解析请求后返回客户端,中间浏览器不会记录htpp的状态,从而导致很多时候出现浪费资源的问题,比如相应内容的重复问题,导致资源的浪费,为了解决这个问题,就开发出了可以维持浏览器状态的技术.</p>
<p>(3)session和cookie:</p>
<p>session:回话,储存在服务器端.</p>
<p>cookie:储存在客户端本地的数据</p>
<p>当客户端第一次请求服务器时,服务器解析请求的同时会建立session,同时返回响应给客户端,客户端储存cookie保存在本地.</p>
<p>当客户端再次访问服务器时,客户端带着cookie请求发送给服务器,服务器根据cookie找到自己所维护的session,通过解析session判断客户端状态从而发送响应的数据.</p>
<p>但是这种机制有很多问题,首先是服务器要维护用户的session,浪费了部分的资源,而且当后端系统使用负载均衡设计时(同一个系统分布在多台不同的服务器上),若用户在a节点成功登陆,那么他的session存储在a中,当用户在一次登陆时被分配到b节点,而b节点没有存储用户的相关信息,那么用户只能重新登录,这种体验非常不好.所以,jwt应运而生.</p>
<p>(4)jwt处理机制:</p>
<p>当客户端第一次发送请求时,服务器会做出响应,然后把状态信息加密成一个字符串,这就是token,然后把这个token传给客户端,并由客户端本地保存.客户端以后发送请求时携带token,由服务器解析token,并得到相应的状态.然后返回响应的数据.</p>
<p>这种机制把”传递数据”变成了”传递方法”,巧妙地解决了cookie-session这种状态维持的方式所带来的种种问题.</p>
<h3 id="8-8-4-在springboot中使用shiro-jwt"><a href="#8-8-4-在springboot中使用shiro-jwt" class="headerlink" title="8.8.4: 在springboot中使用shiro+jwt:"></a>8.8.4: 在springboot中使用shiro+jwt:</h3><h4 id="8-8-4-1-导入依赖"><a href="#8-8-4-1-导入依赖" class="headerlink" title="8.8.4.1: 导入依赖:"></a>8.8.4.1: 导入依赖:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.auth0/java-jwt --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.18.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-4-2-建立JWTUtil类"><a href="#8-8-4-2-建立JWTUtil类" class="headerlink" title="8.8.4.2: 建立JWTUtil类:"></a>8.8.4.2: 建立JWTUtil类:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.chen.internetplus.config;</span><br><span class="line">import com.auth0.jwt.JWT;</span><br><span class="line">import com.auth0.jwt.JWTVerifier;</span><br><span class="line">import com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line">import com.auth0.jwt.exceptions.JWTDecodeException;</span><br><span class="line">import com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line">import com.chen.internetplus.pojo.User;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JWTUtil &#123;</span><br><span class="line">    //token有效时长:毫秒</span><br><span class="line">    private static final long EXPIRE=7*24*60*60*1000;</span><br><span class="line">    //token的密钥</span><br><span class="line">    private static final String SECRET=&quot;InternetPlus&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static String createToken(User user) throws UnsupportedEncodingException &#123;</span><br><span class="line">        //token过期时间</span><br><span class="line">        Date date=new Date(System.currentTimeMillis()+EXPIRE);</span><br><span class="line"></span><br><span class="line">        //jwt的header部分</span><br><span class="line">        Map&lt;String ,Object&gt;map=new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;alg&quot;,&quot;HS256&quot;);</span><br><span class="line">        map.put(&quot;typ&quot;,&quot;JWT&quot;);</span><br><span class="line"></span><br><span class="line">        //使用jwt的api生成token</span><br><span class="line">        String token= JWT.create()</span><br><span class="line">                .withHeader(map)</span><br><span class="line">                .withClaim(&quot;username&quot;, user.getUsername())//私有声明</span><br><span class="line">                .withExpiresAt(date)//过期时间</span><br><span class="line">                .withIssuedAt(new Date())//签发时间</span><br><span class="line">                .sign(Algorithm.HMAC256(SECRET));//签名</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //校验token的有效性，1、token的header和payload是否没改过；2、没有过期</span><br><span class="line">    public static boolean verify(String token)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //解密</span><br><span class="line">            JWTVerifier verifier=JWT.require(Algorithm.HMAC256(SECRET)).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //无需解密也可以获取token的信息</span><br><span class="line">    public static String getUsername(String token)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DecodedJWT jwt = JWT.decode(token);</span><br><span class="line">            return jwt.getClaim(&quot;username&quot;).asString();</span><br><span class="line">        &#125; catch (JWTDecodeException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类用于处理token的各种操作.</p>
<h4 id="8-8-4-3-封装token"><a href="#8-8-4-3-封装token" class="headerlink" title="8.8.4.3: 封装token"></a>8.8.4.3: 封装token</h4><p>把token这个字符串封装成一个类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.chen.internetplus.config;</span><br><span class="line"></span><br><span class="line">import org.apache.shiro.authc.AuthenticationToken;</span><br><span class="line">//封装token</span><br><span class="line">//shiro并不能够识别字符串的token(就是由JWTUtil中creatToken方法生成的),故要把这个字符串做成一个类</span><br><span class="line">public class JWTToken implements AuthenticationToken &#123;</span><br><span class="line">    private String token;</span><br><span class="line"></span><br><span class="line">    public  JWTToken(String token)&#123;</span><br><span class="line">        this.token = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getPrincipal() &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getCredentials() &#123;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author: lhy</span><br><span class="line"> * 自定义的shiro接口token，可以通过这个类将string的token转型成AuthenticationToken，可供shiro使用</span><br><span class="line"> * 注意：需要重写getPrincipal和getCredentials方法，因为是进行三件套处理的，没有特殊配置shiro无法通过这两个方法获取到用户名和密码，需要直接返回token，之后交给JwtUtil去解析获取。（当然了，可以对realm进行配</span><br><span class="line">置HashedCredentialsMatcher，这里就不这么处理了）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h4 id="8-8-4-4-编写JwtFilter过滤器"><a href="#8-8-4-4-编写JwtFilter过滤器" class="headerlink" title="8.8.4.4:编写JwtFilter过滤器:"></a>8.8.4.4:编写JwtFilter过滤器:</h4><p>用于筛选http请求,对不同的请求进行不同的操作.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.chen.internetplus.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//过滤器:用于更加精确地筛选http请求</span><br><span class="line"></span><br><span class="line">import com.chen.internetplus.pojo.Result;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line">import org.apache.shiro.authc.AuthenticationException;</span><br><span class="line">import org.apache.shiro.authc.ExpiredCredentialsException;</span><br><span class="line">import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;</span><br><span class="line">import org.apache.shiro.web.util.WebUtils;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">//用这个注解把这个类注入到spring容器中</span><br><span class="line">public class JWTFilter extends BasicHttpAuthenticationFilter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //这个方法的作用是判断请求头是否含有token</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) &#123;</span><br><span class="line">        System.out.println(&quot;isLoginAttempt&quot;);</span><br><span class="line">        HttpServletRequest req= (HttpServletRequest) request;</span><br><span class="line">        String token=req.getHeader(&quot;Authorization&quot;);</span><br><span class="line">        return token!=null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123;</span><br><span class="line">        //判断请求的请求头是否带上 &quot;Token&quot;</span><br><span class="line">        if (isLoginAttempt(request, response)) &#123;</span><br><span class="line">            String token = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">                token = req.getHeader(&quot;Authorization&quot;);</span><br><span class="line">                JWTToken jwt = new JWTToken(token);</span><br><span class="line">                //交给自定义的realm对象去登录，如果错误他会抛出异常并被捕获</span><br><span class="line">                getSubject(request, response).login(jwt);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; catch (ExpiredCredentialsException e) &#123;</span><br><span class="line">                Result result = Result.error(500,&quot;Token认证失败!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    out(response, result);</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; catch (AuthenticationException e) &#123;</span><br><span class="line">                Result result = Result.error(500,&quot;Token错误!用户不存在!&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    out(response, result);</span><br><span class="line">                &#125; catch (IOException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //token不存在</span><br><span class="line">        Result result = Result.error(500,&quot;无token,请重新登录!&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            out(response,result);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * json形式返回结果token验证失败信息，无需转发</span><br><span class="line">     */</span><br><span class="line">    private void out(ServletResponse response, Result res) throws IOException &#123;</span><br><span class="line">        HttpServletResponse httpServletResponse = WebUtils.toHttp(response);</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        String jsonRes = mapper.writeValueAsString(res);</span><br><span class="line">        httpServletResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        httpServletResponse.setContentType(&quot;application/json; charset=utf-8&quot;);</span><br><span class="line">        httpServletResponse.getOutputStream().write(jsonRes.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-4-5-编写realm对象"><a href="#8-8-4-5-编写realm对象" class="headerlink" title="8.8.4.5: 编写realm对象:"></a>8.8.4.5: 编写realm对象:</h4><p>用于验证登录状态是否正确.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.chen.internetplus.config;</span><br><span class="line"></span><br><span class="line">import com.chen.internetplus.pojo.User;</span><br><span class="line">import com.chen.internetplus.service.UserService;</span><br><span class="line">import org.apache.shiro.SecurityUtils;</span><br><span class="line">import org.apache.shiro.authc.*;</span><br><span class="line">import org.apache.shiro.authz.AuthorizationInfo;</span><br><span class="line">import org.apache.shiro.realm.AuthorizingRealm;</span><br><span class="line">import org.apache.shiro.subject.PrincipalCollection;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">//realm:是shiro两大功能:认证和授权的入口,通过自定义realm,对认证和授权功能进行自定义处理</span><br><span class="line">public class MyRealm extends AuthorizingRealm&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    //添加注解支持:限定这个realm只能处理JWTToken,不加的话会报错</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supports(AuthenticationToken token)&#123;</span><br><span class="line">        return token instanceof JWTToken;</span><br><span class="line">    &#125;</span><br><span class="line">    //认证</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">        //从刚才封装的JWTToken中重新取出token</span><br><span class="line">        String jwt= (String) token.getCredentials();</span><br><span class="line"></span><br><span class="line">        //验证token</span><br><span class="line">        if (!JWTUtil.verify(jwt))&#123;</span><br><span class="line">            throw new ExpiredCredentialsException(&quot;token认证失效，token错误或者过期，重新登陆&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //获取用户名</span><br><span class="line">        String username= JWTUtil.getUsername(jwt);</span><br><span class="line"></span><br><span class="line">        //获取用户</span><br><span class="line">        User user=userService.getUser(username);</span><br><span class="line">        if (user==null)&#123;</span><br><span class="line">            throw new AuthenticationException(&quot;该用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    //对于获取不到对象的问题,网上搜索栏了很多种方法,这是其中一种,但未解决问题</span><br><span class="line">        SecurityUtils.getSubject().getSession().setAttribute(&quot;User&quot;, user);</span><br><span class="line">    //return new SimpleAuthenticationInfo(jwt,jwt,&quot;MyRealm&quot;);</span><br><span class="line">    //当把第一个参数从jwt变成user对象时,就可以获取当前用户了</span><br><span class="line">        return new SimpleAuthenticationInfo(user,jwt,&quot;MyRealm&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //授权</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-4-6-编写shiro配置"><a href="#8-8-4-6-编写shiro配置" class="headerlink" title="8.8.4.6: 编写shiro配置:"></a>8.8.4.6: 编写shiro配置:</h4><p>最终配置,调用所有组件的地方.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.chen.internetplus.config;</span><br><span class="line"></span><br><span class="line">import com.chen.internetplus.config.JWTFilter;</span><br><span class="line">import com.chen.internetplus.config.MyRealm;</span><br><span class="line">import org.apache.shiro.mgt.DefaultSessionStorageEvaluator;</span><br><span class="line">import org.apache.shiro.mgt.DefaultSubjectDAO;</span><br><span class="line">import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;</span><br><span class="line">import org.apache.shiro.spring.web.ShiroFilterFactoryBean;</span><br><span class="line">import org.apache.shiro.web.mgt.DefaultWebSecurityManager;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class</span><br><span class="line">ShiroConfig &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //1.创建realm对象</span><br><span class="line">    @Bean</span><br><span class="line">    public MyRealm myRealm()&#123;</span><br><span class="line">        return new MyRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.SecurityManager</span><br><span class="line">    @Bean(name = &quot;securityManager&quot;)</span><br><span class="line">    public DefaultWebSecurityManager securityManager(MyRealm myRealm)&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager=new DefaultWebSecurityManager();</span><br><span class="line">        // 设置自定义 realm.</span><br><span class="line">        securityManager.setRealm(myRealm);</span><br><span class="line">        //关闭session</span><br><span class="line">        DefaultSubjectDAO subjectDAO=new DefaultSubjectDAO();</span><br><span class="line">        DefaultSessionStorageEvaluator sessionStorageEvaluator=new DefaultSessionStorageEvaluator();</span><br><span class="line">        sessionStorageEvaluator.setSessionStorageEnabled(false);</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(sessionStorageEvaluator);</span><br><span class="line">        securityManager.setSubjectDAO(subjectDAO);</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建ShiroFilter（用于拦截所有请求，对受限资源进行Shiro的认证和授权判断）</span><br><span class="line">    //Shiro提供了丰富的过滤器（anon等），不过在这里就需要加入我们自定义的JwtFilter了</span><br><span class="line">    //3.配置过滤器</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroFilterFactoryBean factory(@Qualifier(&quot;securityManager&quot;)DefaultWebSecurityManager securityManager)&#123;</span><br><span class="line">        ShiroFilterFactoryBean factoryBean=new ShiroFilterFactoryBean();</span><br><span class="line">        //设置安全管理器</span><br><span class="line">        factoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        //设置我们自定义的JWT过滤器,并注册JWTFilter到ShiroFilterFactoryBean中</span><br><span class="line">        Map&lt;String, Filter&gt; filterMap=new LinkedHashMap&lt;&gt;();</span><br><span class="line">        filterMap.put(&quot;jwt&quot;,new JWTFilter());</span><br><span class="line">        factoryBean.setFilters(filterMap);</span><br><span class="line"></span><br><span class="line">        //配置系统的受限资源以及对应的过滤器</span><br><span class="line">        Map&lt;String, String&gt; ruleMap = new HashMap&lt;&gt;();</span><br><span class="line">        ruleMap.put(&quot;/activity/createActivity&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/activity/myActivity&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/activity/approveActivity&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/activity/lottery&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/activity/show&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/activity/change&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/activity/add&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/user/getuser&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/user/changenickname&quot;,&quot;jwt&quot;);</span><br><span class="line">        ruleMap.put(&quot;/**&quot;,&quot;anon&quot;);</span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(ruleMap);</span><br><span class="line">        return factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开启对 Shiro 注解的支持</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) &#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        advisor.setSecurityManager(securityManager);</span><br><span class="line">        return advisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了配置拦截器,可以拦截器全部放行,通过注解实现拦截:</p>
<p>在接口和Controller类上加@RequiresAuthentication注解:需要token</p>
<p>@RequiresRoles:授权</p>
<h4 id="8-8-4-7-获取当前登录对象"><a href="#8-8-4-7-获取当前登录对象" class="headerlink" title="8.8.4.7: 获取当前登录对象"></a>8.8.4.7: 获取当前登录对象</h4><p>通过shiro框架可以根据token直接获得当前对象,不需要每次调用接口都传入用户名等信息.</p>
<p>SecurityUtils.getSubject().getPrincipal().</p>
<h2 id="8-9-lombok"><a href="#8-9-lombok" class="headerlink" title="8.9: lombok:"></a>8.9: lombok:</h2><h3 id="8-9-1-介绍"><a href="#8-9-1-介绍" class="headerlink" title="8.9.1: 介绍:"></a>8.9.1: 介绍:</h3><p>在Java中,封装是一个非常好的机制,最常见的封装莫过于get,set方法了,无论是Intellij idea 还是Eclipse，都提供了快速生成get,set方法的快捷键,使用起来很是方便，其实,我们还有更方便的办法,就是今天的主角-Lombok.</p>
<p>简而言之,就是帮助我们快速生成重复代码的工具.</p>
<h3 id="8-9-2-导入依赖"><a href="#8-9-2-导入依赖" class="headerlink" title="8.9.2: 导入依赖:"></a>8.9.2: 导入依赖:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-9-3-使用"><a href="#8-9-3-使用" class="headerlink" title="8.9.3: 使用:"></a>8.9.3: 使用:</h3><p>Lombok提供注解方式来提高代码的简洁性,常用注解有:</p>
<ul>
<li>@Data</li>
<li>@Setter @Getter</li>
<li>@NonNull</li>
<li>@Synchronized</li>
<li>@ToString</li>
<li>@EqualsAndHashCode</li>
<li>@Cleanup</li>
<li>@SneakyThrows</li>
</ul>
<p>下面重点介绍其中几个:</p>
<p>@Data:相当于同时添加@Setter @Getter,@ToString,@EqualsAndHashCode这些注解,一般在实体类上使用.</p>
<p>@Setter @Getter:自动为所有属性添加set.get方法.方法名遵循驼峰命名法.</p>
<p>@NonNull:该注解快速判断是否为空,如果为空,则抛出java.lang.NullPointerException.</p>
<p>@ToString:自动生成toString()方法:用String的形式去描述一个类</p>
<h2 id="8-10-Slf4j"><a href="#8-10-Slf4j" class="headerlink" title="8.10: Slf4j:"></a>8.10: Slf4j:</h2><p>使用这个注解,在控制台实现日志的输出.</p>
<p>使用方法:再类的最上方加上@Slf4j这个注解,然后在代码中直接使用log.方法()就可以在控制台输出日志了,非常的方便.</p>
<p>slf4j的日志级别分为五种：info、debug、error、warn、trance.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info:  一般处理业务逻辑的时候使用，就跟 system.err打印一样，用于说明此处是干什么的。slf4j使用的时候是可以动态的传参的，使用占位符 &#123;&#125; 。后边一次加参数，会挨个对应进去。</span><br><span class="line"></span><br><span class="line">debug: 一般放于程序的某个关键点的地方，用于打印一个变量值或者一个方法返回的信息之类的信息</span><br><span class="line"></span><br><span class="line">error： 用户程序报错，必须解决的时候使用此级别打印日志。</span><br><span class="line">    </span><br><span class="line">warn： 警告，不会影响程序的运行，但是值得注意。</span><br><span class="line"></span><br><span class="line">trance: 一般不会使用，在日志里边也不会打印出来，好像是很低的一个日志级别。</span><br><span class="line"></span><br><span class="line">举个例子:</span><br><span class="line">在类上方添加:</span><br><span class="line">@Slf4j</span><br><span class="line">public class UserController &#123;;&#125;</span><br><span class="line">使用时:</span><br><span class="line">public Integer text()&#123;</span><br><span class="line">        log.info(&quot;这样使用日志.处理一般的业务逻辑,在控制台会显示绿色的info(information的缩写,表示提示信息)标识.&quot;);</span><br><span class="line">        log.error(&quot;这是发生错误时的日志使用方式,在控制台会显示出红色的ERROR标识.);</span><br><span class="line">        log.debug(&quot;这是使用debug的日志使用方式.&quot;);</span><br><span class="line">        log.warn(&quot;这是使用警告的日志使用方式,在控制台会显示出黄色的WARN提示.);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-项目实践"><a href="#9-项目实践" class="headerlink" title="9.项目实践:"></a>9.项目实践:</h1><h2 id="9-1-选课系统"><a href="#9-1-选课系统" class="headerlink" title="9.1: 选课系统:"></a>9.1: 选课系统:</h2><h3 id="9-1-1-介绍"><a href="#9-1-1-介绍" class="headerlink" title="9.1.1: 介绍:"></a>9.1.1: 介绍:</h3><p>第一个springboot项目,作为werun实验室的考核大作业.</p>
<h3 id="9-1-2-技术"><a href="#9-1-2-技术" class="headerlink" title="9.1.2: 技术:"></a>9.1.2: 技术:</h3><h4 id="9-1-2-1-find-in-set"><a href="#9-1-2-1-find-in-set" class="headerlink" title="9.1.2.1: find in set:"></a>9.1.2.1: find in set:</h4><p>FIND_IN_SET(str,strlist)</p>
<p>str 要查询的字符串,strlist 字段名 参数以”,”分隔 如 (1,2,6,8),查询字段(strlist)中包含(str)的结果，返回结果为null或记录假如字符串str在由N个子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被 ‘,’ 符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Query(value = &quot;SELECT * FROM Course WHERE FIND_IN_SET(&#x27;已通过&#x27;,status)&quot;)</span><br><span class="line">List&lt;Course&gt; findAllByStatus(String status);</span><br></pre></td></tr></table></figure>

<p>这个函数适用于这种情况:</p>
<p>比如一个字段是一个字符串列表: 1,2,3,还有另一个记录的该字段值是:1,22,33,若用like进行搜索,则会搜索到这两条记录,但是如果用这个函数就只能搜索到第一条记录,作为一种特殊的搜索方式.</p>
<h4 id="9-1-2-2-分页"><a href="#9-1-2-2-分页" class="headerlink" title="9.1.2.2: 分页:"></a>9.1.2.2: 分页:</h4><p>功能举例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/administrator/query&quot;)</span><br><span class="line">//教务功能:查看所有课程</span><br><span class="line">//通过分页的方式呈现,不进行排序所以去掉sort参数</span><br><span class="line">// pageNum是指查询页,默认从0开始</span><br><span class="line">// pageSize是每页的期望行数,设置为10</span><br><span class="line">public Page&lt;Course&gt; administratorQuery(@RequestParam(name = &quot;pageNum&quot;, defaultValue = &quot;0&quot;) Integer pageNum,</span><br><span class="line">                         @RequestParam(name = &quot;pageSize&quot;, defaultValue = &quot;10&quot;) Integer pageSize)&#123;</span><br><span class="line">PageRequest of = PageRequest.of(pageNum, pageSize);</span><br><span class="line">    Page&lt;Course&gt; courses = courseRepository.findAll(of);</span><br><span class="line">    return courses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-云端笔记"><a href="#9-2-云端笔记" class="headerlink" title="9.2: 云端笔记:"></a>9.2: 云端笔记:</h2><h3 id="9-2-1-介绍"><a href="#9-2-1-介绍" class="headerlink" title="9.2.1: 介绍:"></a>9.2.1: 介绍:</h3><p>作为加入实验室后的考核项目,第一次与前端的同学进行合作和对接.</p>
<h3 id="9-2-2-技术"><a href="#9-2-2-技术" class="headerlink" title="9.2.2: 技术:"></a>9.2.2: 技术:</h3><h4 id="9-2-2-1-项目设计过程"><a href="#9-2-2-1-项目设计过程" class="headerlink" title="9.2.2.1: 项目设计过程:"></a>9.2.2.1: 项目设计过程:</h4><p>数据库表设计-实体类设计-服务层设计-接口设计(根据原型图)</p>
<h4 id="9-2-2-2-封装service"><a href="#9-2-2-2-封装service" class="headerlink" title="9.2.2.2: 封装service:"></a>9.2.2.2: 封装service:</h4><p>写service层,在里面实现接口,同时写serviceimpl层进行接口的实现,这样做的好处是在项目需求发生变化时,只需要重新建立serviceimpl,不用修改所有的代码,符合开闭原则(程序对修改关闭,对增添开放)</p>
<p>具体操作:</p>
<p>(1)：在service层中写接口：</p>
<p>public interface NoteService {</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Result&lt;String&gt; addNote(String name, String username, String status, String describe, String content, String type);</span><br><span class="line">Result&lt;List&lt;Note&gt;&gt; noteList(String username);</span><br></pre></td></tr></table></figure>

<p>}</p>
<p>(2): 在serviceimpl类中实现service接口,同时加@service注解.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.example.serviceImp;</span><br><span class="line"></span><br><span class="line">import com.example.dao.NoteRepository;</span><br><span class="line">import com.example.dao.TypeRepository;</span><br><span class="line">import com.example.entity.Note;</span><br><span class="line">import com.example.entity.Type;</span><br><span class="line">import com.example.service.NoteService;</span><br><span class="line">import com.example.util.Result;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import javax.transaction.Transactional;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Transactional</span><br><span class="line">public class NoteServiceImp implements NoteService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private NoteRepository noteRepository;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TypeRepository typeRepository;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result&lt;String&gt; modifyNote(String name,String username,String status,String describe,String content,String type)&#123;</span><br><span class="line">        //修改笔记</span><br><span class="line">        try&#123;</span><br><span class="line">            //首先找到笔记</span><br><span class="line">            Result&lt;Note&gt; result = note(username, type, name);</span><br><span class="line">            Note note = result.getData();</span><br><span class="line">            if(note == null)&#123;</span><br><span class="line">                return new Result&lt;String&gt;(400,&quot;修改笔记失败!笔记不存在&quot;,null);</span><br><span class="line">            &#125;</span><br><span class="line">            //修改笔记</span><br><span class="line">            note.setNotecontent(content);</span><br><span class="line">            note.setNotedescribe(describe);</span><br><span class="line">            note.setNotestatus(status);</span><br><span class="line">            note.setNotetype(type);</span><br><span class="line">            note.setNotename(name);</span><br><span class="line">            note.setUsername(username);</span><br><span class="line"></span><br><span class="line">            //重新获取时间</span><br><span class="line">            SimpleDateFormat sdf = new SimpleDateFormat();</span><br><span class="line">            sdf.applyPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">            Date date = new Date();</span><br><span class="line">            String data = sdf.format(date);</span><br><span class="line">            note.setNotetime(data);</span><br><span class="line"></span><br><span class="line">            //保存</span><br><span class="line">            noteRepository.save(note);</span><br><span class="line">            return new Result&lt;String&gt;(200,&quot;修改笔记成功!&quot;,null);</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            return new Result&lt;String&gt;(500,&quot;修改笔记失败!&quot;,null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3): 在controller类中调用时,注入接口类,内部会自动注入其实现类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">//写的是注入接口,事实上是注入了实现类</span><br><span class="line">NoteService noteService;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-抗疫志愿者信息化应用平台"><a href="#9-3-抗疫志愿者信息化应用平台" class="headerlink" title="9.3: 抗疫志愿者信息化应用平台:"></a>9.3: 抗疫志愿者信息化应用平台:</h2><h3 id="9-3-1-介绍"><a href="#9-3-1-介绍" class="headerlink" title="9.3.1: 介绍:"></a>9.3.1: 介绍:</h3><p>参加互联网＋创新创业大赛的项目,第一次设计项目,第一次领导项目.</p>
<h3 id="9-3-2-技术"><a href="#9-3-2-技术" class="headerlink" title="9.3.2: 技术:"></a>9.3.2: 技术:</h3><h4 id="9-3-2-1：注解AOP："><a href="#9-3-2-1：注解AOP：" class="headerlink" title="9.3.2.1：注解AOP："></a>9.3.2.1：注解AOP：</h4><p>通过注解自定义aop进行全局异常处理.再出现异常时,同时实现向前端的返回和向控制台的输出.</p>
<p>（1）：自定义注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">public @interface BearLogger &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）：自定义切面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.chen.internetplus.utils.manageResult;</span><br><span class="line"></span><br><span class="line">import com.chen.internetplus.pojo.Result;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.slf4j.ILoggerFactory;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.core.DefaultParameterNameDiscoverer;</span><br><span class="line">import org.springframework.core.ParameterNameDiscoverer;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component//注意一定要将此切面设入spring容器中，否则无法调用进行方法增强</span><br><span class="line">public class MyPointcuts &#123;</span><br><span class="line">    @Pointcut(&quot;@annotation(BearLogger)&quot;)</span><br><span class="line">    public void logBefore()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">//    @Around(&quot;@annotation(BearLogger)&quot;)</span><br><span class="line">//    通过这个注解进行环绕，这样在想使用这个的地方加上这个注解即可.</span><br><span class="line">    @Around(&quot;execution(* com.chen.internetplus.controller.*.*(..))&quot;)</span><br><span class="line">    //可以用 @Around(&quot;execution(* com.chen.studyaop.controllers.HelloController.*(..))&quot;)指定某个类下所有方法</span><br><span class="line">    private Result bearLog(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">        ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();</span><br><span class="line">        Logger logger = loggerFactory.getLogger(&quot;&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            String classType = joinPoint.getTarget().getClass().getName();</span><br><span class="line">            String methodName = joinPoint.getSignature().getName();</span><br><span class="line">            // 参数</span><br><span class="line">            Object[] args = joinPoint.getArgs();</span><br><span class="line">            Class&lt;?&gt;[] classes = new Class[args.length];</span><br><span class="line">            for (int k = 0; k &lt; args.length; k++) &#123;</span><br><span class="line">                if (!args[k].getClass().isPrimitive()) &#123;</span><br><span class="line">                    // 获取的是封装类型而不是基础类型</span><br><span class="line">                    String result = args[k].getClass().getName();</span><br><span class="line">                    Class s = map.get(result);</span><br><span class="line">                    classes[k] = s == null ? args[k].getClass() : s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ParameterNameDiscoverer pnd = new DefaultParameterNameDiscoverer();</span><br><span class="line">            // 获取指定的方法，第二个参数可以不传，但是为了防止有重载的现象，还是需要传入参数的类型</span><br><span class="line">            Method method = Class.forName(classType).getMethod(methodName, classes);</span><br><span class="line">            // 参数名</span><br><span class="line">            String[] parameterNames = pnd.getParameterNames(method);</span><br><span class="line">            // 通过map封装参数和参数值</span><br><span class="line">            HashMap&lt;String, Object&gt; paramMap = new HashMap();</span><br><span class="line">            for (int i = 0; i &lt; parameterNames.length; i++) &#123;</span><br><span class="line">                paramMap.put(parameterNames[i], args[i]);</span><br><span class="line">                logger.info(&quot;参数名：&quot;+parameterNames[i]+&quot;  参数值&quot;+args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            return (Result) joinPoint.proceed();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (e instanceof GlobalException) &#123;</span><br><span class="line"></span><br><span class="line">                logger.error(e.getMessage());</span><br><span class="line">                logger.error(&quot;执行方法调用失败,此失败来源于代码内手动抛出&quot;);</span><br><span class="line">                return Result.error(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            logger.error(e.getMessage());</span><br><span class="line">            logger.error(&quot;未排除失败来源于系统性失败&quot;);</span><br><span class="line">            return Result.error(&quot;服务器端错误,来源于代码错误&quot;+&quot;错误内容如下&quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static HashMap&lt;String, Class&gt; map = new HashMap&lt;String, Class&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put(&quot;java.lang.Integer&quot;, int.class);</span><br><span class="line">            put(&quot;java.lang.Double&quot;, double.class);</span><br><span class="line">            put(&quot;java.lang.Float&quot;, float.class);</span><br><span class="line">            put(&quot;java.lang.Long&quot;, Long.class);</span><br><span class="line">            put(&quot;java.lang.Short&quot;, short.class);</span><br><span class="line">            put(&quot;java.lang.Boolean&quot;, boolean.class);</span><br><span class="line">            put(&quot;java.lang.Char&quot;, char.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前并未完全理解这段代码，后续慢慢学习.</p>
<h4 id="9-3-2-2-生成不重复的随机数："><a href="#9-3-2-2-生成不重复的随机数：" class="headerlink" title="9.3.2.2: 生成不重复的随机数："></a>9.3.2.2: 生成不重复的随机数：</h4><p>可以按照传入的数量生成一组随机数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.chen.internetplus.utils.manageResult;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line">import java.util.Random;</span><br><span class="line">public class MyRandom &#123;</span><br><span class="line"></span><br><span class="line">     public  int[] getTheRandomArray(int count) throws NoSuchAlgorithmException &#123;</span><br><span class="line">            //采用更随机的生成随机数的方式,生成任意数量个不重复的随机数</span><br><span class="line">            SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">            int array[] = new int[count];</span><br><span class="line">            //首先 Random类中的nextInt(int bound)方法是产生一个从0到bound-1的一个随机数</span><br><span class="line">            //为了防止第一个数是0而无法放入,所以我选择不使用数组默认的初始化方式,而是选择让所有的数值都为bound值。</span><br><span class="line">            for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">                array[i] = count;</span><br><span class="line">            &#125;</span><br><span class="line">            //这是一个标志,当flag的值为false时,</span><br><span class="line">            //说明新产生的随机数没有与数组当中的数值重复，跳出while循环。</span><br><span class="line">            boolean flag = false;</span><br><span class="line">            //这是一个for循环进行赋值</span><br><span class="line">            for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">                //这个变量的作用有必要说明一下</span><br><span class="line">                //我们的flag一开始是false值,为了保证我们的while循环第一次可以执行,我们设置了这样一个变量。</span><br><span class="line">                int start = 0;</span><br><span class="line">                int temp = count ;</span><br><span class="line">                while(/**三目表达式,这个地方体现了start变量的价值*/start==0?true:flag)&#123;</span><br><span class="line">                    //我们的测试循环很简单,一旦发现新生成的随机数和之前在数组中的随机数重复</span><br><span class="line">                    //马上重新生成并重新进行比较</span><br><span class="line">                    //当发现重复时我们会将flag设置为true值,这样while循环得以执行</span><br><span class="line">                    //当开始下一次的while循环时,我们就需要将flag设置为false值</span><br><span class="line">                    //这样是为了防止即使新产生的temp值并没有出现重复,由于flag依旧为true从而陷入死循环</span><br><span class="line">                    flag = false;</span><br><span class="line">                    temp = random.nextInt(count);</span><br><span class="line">                    for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                        if(temp ==array[j])&#123;</span><br><span class="line">                            flag = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //一次while循环结束后,对start变量进行递增</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">                //while循环执行结束后,说明新产生的temp随机变量并不会重复,将它放在数组中即可</span><br><span class="line">                array[i]  = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            return array;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-3-获取时间和时间比较："><a href="#9-3-2-3-获取时间和时间比较：" class="headerlink" title="9.3.2.3: 获取时间和时间比较："></a>9.3.2.3: 获取时间和时间比较：</h4><p>通过calendar进行比较.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取当前时间,转换为calendar</span><br><span class="line">Date d = new Date();</span><br><span class="line">SimpleDateFormat time = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Calendar nowTime = Calendar.getInstance();</span><br><span class="line">nowTime.setTime(time.parse(time.format(d)));</span><br><span class="line"></span><br><span class="line">//获取招募时间段,转换为calendar</span><br><span class="line">Activity activity = activityRepository.findByTitle(title);</span><br><span class="line">String start = activity.getStarttime();</span><br><span class="line">String end = activity.getEndtime();</span><br><span class="line">Date start1 = time.parse(start);</span><br><span class="line">Date end1 = time.parse(end);</span><br><span class="line">Calendar startTime = Calendar.getInstance();</span><br><span class="line">startTime.setTime(start1);</span><br><span class="line">Calendar endTime = Calendar.getInstance();</span><br><span class="line">endTime.setTime(end1);</span><br><span class="line"></span><br><span class="line">//比较时间</span><br><span class="line">if (nowTime.after(endTime) || nowTime.before(startTime)) &#123;</span><br><span class="line">    return Result.error(500, &quot;报名失败!,不在报名时间段内!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-4-swagger-ui"><a href="#9-3-2-4-swagger-ui" class="headerlink" title="9.3.2.4: swagger-ui:"></a>9.3.2.4: swagger-ui:</h4><p>swagger-ui是一个可以自动为controller类的接口生成接口文档的组件，通过简单的配置自动生成接口文档，方便与前端的同学进行对接.</p>
<p>(1)配置swagger：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line"></span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;互联网加 Api&quot;)</span><br><span class="line">                //swagger的标题</span><br><span class="line">                .description(&quot;需要token的接口均为web前端操作部分&quot;)</span><br><span class="line">                //swagger的提示</span><br><span class="line">                .termsOfServiceUrl(&quot;&quot;)</span><br><span class="line">                .contact(new Contact(&quot;Spring Cloud --&gt; =.=#&quot;, &quot;http://spring.io/projects/spring-boot&quot;, &quot;&quot;))</span><br><span class="line">                .version(&quot;2.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        // 解决静态资源无法访问</span><br><span class="line">        registry.addResourceHandler(&quot;/**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/static/&quot;);</span><br><span class="line">        // 解决swagger无法访问</span><br><span class="line">        registry.addResourceHandler(&quot;/swagger-ui.html&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/META-INF/resources/&quot;);</span><br><span class="line">        // 解决swagger的js文件无法访问</span><br><span class="line">        registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）在具体实体类上使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ApiModelProperty(&quot;活动标题&quot;)</span><br><span class="line">//加上这个注解，表明实体类的意义.</span><br><span class="line">@Column(name = &quot;title&quot;, precision = 255)</span><br><span class="line">private String title;</span><br></pre></td></tr></table></figure>

<p>(3) 在接口上使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;approveActivity&quot;)</span><br><span class="line">@ApiOperation(&quot;通过活动id批准活动进行&quot;)</span><br><span class="line">//这个注解表明接口的作用</span><br><span class="line">public Result approveActivity(@ApiParam(&quot;活动标题&quot;) </span><br><span class="line">							//这个接口表明这个参数的意义。还可添加提示信息等.</span><br><span class="line">						@RequestParam(&quot;title&quot;) String title,</span><br><span class="line">                              @ApiParam(&quot;审批类型,默认为0未审批,1为审批通过,2为审批未通过&quot;) @RequestParam(&quot;type&quot;) Integer type)&#123;</span><br><span class="line">    return activityService.approveActivity(title, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-5-图片处理："><a href="#9-3-2-5-图片处理：" class="headerlink" title="9.3.2.5: 图片处理："></a>9.3.2.5: 图片处理：</h4><p>大体思路是:上传图片后,不把图片存放进入数据库,那样效率太低,而是存进服务器.然后返回一个url,当需要这个图片时,访问这个url就可以得到这张图片.</p>
<h5 id="9-3-2-5-1-新建文件工具类"><a href="#9-3-2-5-1-新建文件工具类" class="headerlink" title="9.3.2.5.1: 新建文件工具类:"></a>9.3.2.5.1: 新建文件工具类:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class FileUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static String basePath = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">    private static String s = File.separator;</span><br><span class="line">    public static String generateFile(MultipartFile file, String uniqueString, String name) throws IOException &#123;</span><br><span class="line">        String ip_port = &quot;3.36.73.0&quot; + &quot;:&quot; + &quot;8080&quot; + &quot;/file/getFIleByURL?code=&quot;;</span><br><span class="line">        //这是要储存的公网的ip.</span><br><span class="line">        if (file == null) &#123;</span><br><span class="line">            throw new IOException(&quot;未选择文件&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String type = file.getContentType();</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &quot;image/jpeg&quot;:</span><br><span class="line">                type = &quot;.jpg&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;image/gif&quot;:</span><br><span class="line">                type = &quot;.gif&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;image/png&quot;:</span><br><span class="line">                type = &quot;.png&quot;;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                throw new IOException(&quot;不接受的文件类型,只接受jpg,gif,png格式&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        File newFile = new File(basePath + s + &quot;data&quot; + s + name + s + uniqueString + s + &quot;ininame&quot;+type);</span><br><span class="line">        if (newFile.exists()) &#123;</span><br><span class="line">            newFile.delete();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        newFile.createNewFile();</span><br><span class="line">        file.transferTo(newFile);</span><br><span class="line">        Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">        String code = encoder.encodeToString(newFile.getAbsolutePath().getBytes(Charset.forName(&quot;GBK&quot;)));</span><br><span class="line">        return ip_port + code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-3-2-5-2-新建上传图片实现类"><a href="#9-3-2-5-2-新建上传图片实现类" class="headerlink" title="9.3.2.5.2: 新建上传图片实现类:"></a>9.3.2.5.2: 新建上传图片实现类:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Result uploadUserPicture(MultipartFile file,String username);</span><br><span class="line">@Override</span><br><span class="line">   public Result uploadUserPicture(MultipartFile file, String username) &#123;</span><br><span class="line">       String url;</span><br><span class="line">       try&#123;</span><br><span class="line">           url = FileUtil.generateFile(file,username,&quot;personImg&quot;);</span><br><span class="line">           User user = userRepository.findUserByUserName(username);</span><br><span class="line">           user.setUrl(url);</span><br><span class="line">           userRepository.save(user);</span><br><span class="line">       &#125;catch (IOException e)&#123;</span><br><span class="line">           return Result.error(400,e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">       return Result.success(&quot;文件上传成功:&quot;,url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-3-2-5-3-新建上传图片接口"><a href="#9-3-2-5-3-新建上传图片接口" class="headerlink" title="9.3.2.5.3: 新建上传图片接口:"></a>9.3.2.5.3: 新建上传图片接口:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/user/uploadUserPicture&quot;)</span><br><span class="line">   @ApiOperation(&quot;用户上传头像，上传后会生成一串路径存在用户信息中属性名url，直接访问路径即可得到图片&quot;)</span><br><span class="line">   public Result uploadUserPicture(@RequestBody MultipartFile file, @RequestParam String username) &#123;</span><br><span class="line">       return userService.uploadUserPicture(file, username);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>图片上传后,可以选择情况把图片的url储存到数据库或者其他方案.</p>
<h5 id="9-3-2-5-4-新建获取图片接口"><a href="#9-3-2-5-4-新建获取图片接口" class="headerlink" title="9.3.2.5.4: 新建获取图片接口:"></a>9.3.2.5.4: 新建获取图片接口:</h5><p>按照上文的url访问这个接口,可以获取图片.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(value = &quot;/file/getFIleByURL&quot;,produces = MediaType.IMAGE_JPEG_VALUE)</span><br><span class="line"> @ApiOperation(&quot;统一获取图片接口&quot;)</span><br><span class="line"> public byte[] getMyFIle(@RequestParam String code) throws IOException &#123;</span><br><span class="line">     Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line">     code = code.replaceAll(&quot; &quot;, &quot;+&quot;);</span><br><span class="line">     String url = new String(decoder.decode(code));</span><br><span class="line">     System.out.println(&quot;url:&quot; + url);</span><br><span class="line">     BufferedImage bufferedImage = ImageIO.read(new FileInputStream(url));</span><br><span class="line">     ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">     ImageIO.write(bufferedImage, &quot;png&quot;, out);</span><br><span class="line">     return out.toByteArray();</span><br></pre></td></tr></table></figure>

<p>}</p>
<h5 id="9-3-2-5-5-文件上传优化"><a href="#9-3-2-5-5-文件上传优化" class="headerlink" title="9.3.2.5.5: 文件上传优化:"></a>9.3.2.5.5: 文件上传优化:</h5><p>原先的代码没有经过优化和测试,现在在经过测试和学习之后,优化过的文件上传代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.controller;</span><br><span class="line"></span><br><span class="line">import com.pojo.User;</span><br><span class="line">import com.repository.UserRepository;</span><br><span class="line">import com.service.UserService;</span><br><span class="line">import com.util.Result;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.http.MediaType;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.charset.Charset;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@CrossOrigin(origins = &quot;*&quot;)</span><br><span class="line">@RequestMapping(&quot;user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/upPicture&quot;)</span><br><span class="line">    @ApiOperation(&quot;用户上传头像，上传后会生成一串路径存在用户信息中属性名url，直接访问路径即可得到图片&quot;)</span><br><span class="line">    public Result uploadUserPicture(@RequestBody MultipartFile file) &#123;</span><br><span class="line">//      User user = userRepository.findUserByUserName(username);</span><br><span class="line">        try&#123;</span><br><span class="line"></span><br><span class="line">            //通过这个方法获得当前目录.相对路径</span><br><span class="line">            String basePath = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line"></span><br><span class="line">            //因为不同操作系统下分隔符不同,所以通过这个方法获取当前系统的分隔符</span><br><span class="line">            //File类中的 public static final String separator. 类的静态成员和静态方法可以直接访问,而不需要实例化.所以可以将很多工具类里面的方法设置为静态方法.</span><br><span class="line">            String s = File.separator;</span><br><span class="line"></span><br><span class="line">            String ip_port = &quot;localhost&quot; + &quot;:&quot; + &quot;8080&quot; + &quot;/file/getFIleByURL?code=&quot;;</span><br><span class="line">            if (file == null) &#123;</span><br><span class="line">                    throw new IOException(&quot;未选择文件&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取文件原名</span><br><span class="line">            String name = file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">            //获取文件的类型</span><br><span class="line">            String type = file.getContentType();</span><br><span class="line">            switch (type) &#123;</span><br><span class="line">                case &quot;image/jpeg&quot;:</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;image/gif&quot;:</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;image/png&quot;:</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    throw new IOException(&quot;不接受的文件类型,只接受jpg,gif,png格式&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">//            //以pathname为路径创建file对象</span><br><span class="line">//            //创建的file可能是文件 也可能是文件夹,取决于后面的方法</span><br><span class="line">//            //进入路径的逻辑是到文件为止,比如要在某个文件夹下创建文件,这个路径就要精确到要创建的那个文件的名字.与Linux进入文件夹的方式不同.</span><br><span class="line">//           File newFile = new File(basePath  + s +&quot;用户图片&quot;);</span><br><span class="line">//            //判断文件夹是否存在</span><br><span class="line">//           if (!newFile.exists()) &#123;</span><br><span class="line">//            //共有mkdir和mkdirs两个方法,第一个方法如果路径中的文件夹不存在会报错,建立不了文件或文件夹,第二个方法会依次建立所有的父类.然后再建立文件夹.</span><br><span class="line">//               newFile.mkdirs();</span><br><span class="line">//           &#125;</span><br><span class="line">           File file1 = new File(basePath+ s+ &quot;src&quot; + s + &quot;main&quot; +  s  + &quot;resources&quot; + s + &quot;static&quot; + s + name);</span><br><span class="line">           //创建文件</span><br><span class="line">           file1.createNewFile();</span><br><span class="line"></span><br><span class="line">           //写入文件</span><br><span class="line">           file.transferTo(file1);</span><br><span class="line">//           Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">//           String code = encoder.encodeToString(newFile.getAbsolutePath().getBytes(Charset.forName(&quot;GBK&quot;)));</span><br><span class="line">//           String url =  ip_port + code;</span><br><span class="line">//           user.setUrl(url);</span><br><span class="line">//           userRepository.save(user);</span><br><span class="line">            return Result.success(&quot;文件上传成功:&quot;,name);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            return Result.success(&quot;文件上传失败!:&quot;,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-3-2-5-6-文件获取问题"><a href="#9-3-2-5-6-文件获取问题" class="headerlink" title="9.3.2.5.6: 文件获取问题:"></a>9.3.2.5.6: 文件获取问题:</h5><p><code>Spring Boot</code> 默认将 <code>/</code> 的所有访问映射到以下目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classpath:/static</span><br><span class="line">classpath:/public</span><br><span class="line">classpath:/resources</span><br><span class="line">classpath:/META-INF/resources</span><br></pre></td></tr></table></figure>

<p>classpath可以简单地理解为文件存储的目录.</p>
<p>比如把图片0.jpg存放到src&#x2F;main&#x2F;resources&#x2F;static文件夹下.然后使用<a href="http://localhost:端口名/0.jpg访问既可以得到该图片">http://localhost:端口名/0.jpg访问既可以得到该图片</a>.</p>
<p>如果想自己配置自定义的资源访问映射,有两种方式,一是通过yml文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/dbaddscore</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    show-sql: true</span><br><span class="line">  mvc:</span><br><span class="line">    log-request-details: true</span><br><span class="line">#   static-path-pattern: /image/**   #想要访问的路径</span><br><span class="line"># web:</span><br><span class="line">#   resources:</span><br><span class="line">#      static-locations: file:C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\项目\JAVA\校园二手交易及失物招领平台\用户图片  #图片存储的路径</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">debug: true</span><br><span class="line">location:</span><br><span class="line">  file:C:\Users\wpy\Documents\Tencent Files\2669184984\FileRecv\Farewell Light\学习\项目\JAVA\校园二手交易及失物招领平台\用户图片\</span><br></pre></td></tr></table></figure>

<p>加#的即为相关配置.</p>
<p>还有一种方式是通过重写拦截器.代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Configurable;</span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line">import org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line">@PropertySource(&quot;classpath:application.yml&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//引用上文配置中yml里的字段</span><br><span class="line">    //引用yml字段的方式,避免在本地测试与服务器端运行的时候需要频繁修改内部代码的问题</span><br><span class="line">    @Value(&quot;$&#123;location&#125;&quot;)</span><br><span class="line">    private String location;</span><br><span class="line"></span><br><span class="line">    //访问不了 一直是404 不知什么原因</span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        // 解决静态资源无法访问</span><br><span class="line">        registry.addResourceHandler(&quot;/**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;classpath:/static/&quot;);</span><br><span class="line">        //第一个字段是网页访问的地址,第二个字段是存储的地址</span><br><span class="line">        registry.addResourceHandler(&quot;/img/**&quot;).addResourceLocations(&quot;file:D:\\PIC\\&quot;);</span><br><span class="line">        //一定要注意最后也要加斜线.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但在测试中,均未能解决问题,尝试了诸多方法,都在代码里体现,但仍然一直404报错.</p>
<h5 id="9-3-2-5-7-上传图片过大问题"><a href="#9-3-2-5-7-上传图片过大问题" class="headerlink" title="9.3.2.5.7:上传图片过大问题:"></a>9.3.2.5.7:上传图片过大问题:</h5><p>通过yml配置解决.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  servlet:</span><br><span class="line">    multipart:</span><br><span class="line">      max-file-size: 10MB  # 单个文件的大小</span><br><span class="line">      max-request-size: 100MB  # 上传文件的总大小</span><br></pre></td></tr></table></figure>

<h2 id="9-4-加分系统："><a href="#9-4-加分系统：" class="headerlink" title="9.4: 加分系统："></a>9.4: 加分系统：</h2><h3 id="9-4-1-介绍："><a href="#9-4-1-介绍：" class="headerlink" title="9.4.1: 介绍："></a>9.4.1: 介绍：</h3><p>校团委的项目,自己的idea,实际应用的项目.</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Web基本原理</title>
    <url>/2023/01/17/Web%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论:"></a>1.绪论:</h1><h2 id="1-1-b-x2F-s架构："><a href="#1-1-b-x2F-s架构：" class="headerlink" title="1.1 b&#x2F;s架构："></a>1.1 b&#x2F;s架构：</h2><p>B&#x2F;S 架构：Browser&#x2F;Server，浏览器&#x2F;服务器 架构模式。</p>
<p>客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可。</p>
<h2 id="1-2-web应用"><a href="#1-2-web应用" class="headerlink" title="1.2 web应用"></a>1.2 web应用</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524094118036.png" alt="image-20230524094118036"></p>
<p>静态资源直接返回，动态资源转化为静态资源后再返回.</p>
<h2 id="1-3-前中后台："><a href="#1-3-前中后台：" class="headerlink" title="1.3 前中后台："></a>1.3 前中后台：</h2><p>前台：即包括与用户直接交互的界面，如：web页、app；也包括服务端各种实时响应用户请求的业务逻辑，如：商品查询、订单系统等。后台：面向内部运营人员的管理系统、配置系统，如：电商配置后台的商品管理、订单管理、会员管理、财务管理等。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524094249596.png" alt="image-20230524094249596"></p>
<h1 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2.HTML:"></a>2.HTML:</h1><h2 id="2-1-语法："><a href="#2-1-语法：" class="headerlink" title="2.1 语法："></a>2.1 语法：</h2><h3 id="2-1-1-文字"><a href="#2-1-1-文字" class="headerlink" title="2.1.1 文字:"></a>2.1.1 文字:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524094525694.png" alt="image-20230524094525694"></p>
<h3 id="2-1-2图片"><a href="#2-1-2图片" class="headerlink" title="2.1.2图片:"></a>2.1.2图片:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524094556727.png" alt="image-20230524094556727"></p>
<h3 id="2-1-3-标签"><a href="#2-1-3-标签" class="headerlink" title="2.1.3 标签:"></a>2.1.3 标签:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524094624293.png" alt="image-20230524094624293"></p>
<h3 id="2-1-4-表格"><a href="#2-1-4-表格" class="headerlink" title="2.1.4 表格:"></a>2.1.4 表格:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524094729208.png" alt="image-20230524094729208"></p>
<h3 id="2-1-5-表单"><a href="#2-1-5-表单" class="headerlink" title="2.1.5 表单:"></a>2.1.5 表单:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524094832142.png" alt="image-20230524094832142"></p>
<h1 id="3-css"><a href="#3-css" class="headerlink" title="3.css:"></a>3.css:</h1><p>Cascading Style Sheets.层叠样式表.</p>
<h2 id="3-1-页面构成"><a href="#3-1-页面构成" class="headerlink" title="3.1 页面构成:"></a>3.1 页面构成:</h2><p>HTML标签只用于搭建网页的基础结构；样式交由CSS来设置。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524095021130.png" alt="image-20230524095021130"></p>
<h2 id="3-2-引用方式"><a href="#3-2-引用方式" class="headerlink" title="3.2 引用方式:"></a>3.2 引用方式:</h2><h3 id="3-2-1-行内式"><a href="#3-2-1-行内式" class="headerlink" title="3.2.1 行内式:"></a>3.2.1 行内式:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html标签名 style=&quot;属性1:属性值1; 属性2:属性值2; &quot;&gt;    </span><br><span class="line">内容 </span><br><span class="line">&lt;/html标签名&gt;</span><br><span class="line"></span><br><span class="line">&lt;div style=&quot;color: red; font-size: 12px;“ &gt;</span><br><span class="line">      日出江花红胜火</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-内嵌式"><a href="#3-2-2-内嵌式" class="headerlink" title="3.2.2 内嵌式:"></a>3.2.2 内嵌式:</h3><p>放在head开头:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524095327215.png" alt="image-20230524095327215"></p>
<h3 id="3-2-3-外链式"><a href="#3-2-3-外链式" class="headerlink" title="3.2.3 外链式:"></a>3.2.3 外链式:</h3><p>放在新的文件中. .css结尾 </p>
<p>这个文件里面的内容和head里面的style内容是一样的,引用这个文件发生在html的head中.</p>
<h2 id="3-3-语法"><a href="#3-3-语法" class="headerlink" title="3.3 语法:"></a>3.3 语法:</h2><h3 id="3-3-1-普通选择器："><a href="#3-3-1-普通选择器：" class="headerlink" title="3.3.1 普通选择器："></a>3.3.1 普通选择器：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器 &#123; 属性1:属性值1; 属性2:属性值2; … &#125;</span><br></pre></td></tr></table></figure>

<p>选择器类型：</p>
<p>1.根据html标签选择。</p>
<p>2.把css样式写成类，在html的每一个标签上引用：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524095829423.png" alt="image-20230524095829423"></p>
<p>3.id：</p>
<p>和类差不多 不过是唯一的。就是只能被引用一次</p>
<p>定义时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#blue&#123;</span><br><span class="line">	color: #000ff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.通配：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100103883.png" alt="image-20230524100103883"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100020569.png" alt="image-20230524100020569"></p>
<h3 id="3-3-2-特殊选择器："><a href="#3-3-2-特殊选择器：" class="headerlink" title="3.3.2 特殊选择器："></a>3.3.2 特殊选择器：</h3><p>1.后代：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100210856.png" alt="image-20230524100210856"></p>
<p>不管嵌套了多少标签 统称为后代，而直接标签的后代成为儿子标签。</p>
<p>2.儿子：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100333199.png" alt="image-20230524100333199"></p>
<p>3.并集：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100419631.png" alt="image-20230524100419631"></p>
<p>4.交集：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100503788.png" alt="image-20230524100503788"></p>
<h2 id="3-4-盒子模型："><a href="#3-4-盒子模型：" class="headerlink" title="3.4 盒子模型："></a>3.4 盒子模型：</h2><p>html中的每一个元素可以看作一个盒子。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100615921.png" alt="image-20230524100615921"></p>
<h2 id="3-5-三大特征："><a href="#3-5-三大特征：" class="headerlink" title="3.5 三大特征："></a>3.5 三大特征：</h2><h3 id="3-5-1-层叠性："><a href="#3-5-1-层叠性：" class="headerlink" title="3.5.1 层叠性："></a>3.5.1 层叠性：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100719874.png" alt="image-20230524100719874"></p>
<h3 id="3-5-2-继承性："><a href="#3-5-2-继承性：" class="headerlink" title="3.5.2 继承性："></a>3.5.2 继承性：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524100753450.png" alt="image-20230524100753450"></p>
<h3 id="3-5-3-优先级："><a href="#3-5-3-优先级：" class="headerlink" title="3.5.3 优先级："></a>3.5.3 优先级：</h3><p>根据上文选择器顺序判断。</p>
<h1 id="4-javascript"><a href="#4-javascript" class="headerlink" title="4.javascript:"></a>4.javascript:</h1><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介:"></a>4.1 简介:</h2><p>JavaScript 是一门跨平台、面向对象的脚本语言，用来控制网页行为，使网页可交互。JavaScript 和 Java 是完全不同的语言，不论是概念还是设计。但是基础语法类似。</p>
<p>JavaScript可以改变页面内容,展示动态的相关信息,变更图片,对表单进行校验等等.</p>
<h2 id="4-2-引入方式"><a href="#4-2-引入方式" class="headerlink" title="4.2 引入方式:"></a>4.2 引入方式:</h2><h3 id="4-2-1-内部脚本"><a href="#4-2-1-内部脚本" class="headerlink" title="4.2.1 内部脚本:"></a>4.2.1 内部脚本:</h3><p>定义在html页面中.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525195643499.png" alt="image-20230525195643499"></p>
<p>此类标签可以出现在任何地方,一般位于最底部.因为浏览器在加载页面的时候会从上往下进行加载并解析。我们应该让用户看到页面内容，然后再展示动态的效果。</p>
<h3 id="4-2-2-外部脚本"><a href="#4-2-2-外部脚本" class="headerlink" title="4.2.2 外部脚本:"></a>4.2.2 外部脚本:</h3><p>通过编写js文件的方式,引入js.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525195832237.png" alt="image-20230525195832237"></p>
<h2 id="4-3-基础语法"><a href="#4-3-基础语法" class="headerlink" title="4.3 基础语法:"></a>4.3 基础语法:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;            </span><br><span class="line"></span><br><span class="line">//写入警告框            </span><br><span class="line">window.alert(&quot;hello js1~&quot;);            </span><br><span class="line"></span><br><span class="line">//写入html页面     </span><br><span class="line">document.write(&quot;hello js2~&quot;);   </span><br><span class="line"></span><br><span class="line">//写入浏览器的控制台    </span><br><span class="line">console.log(&quot;hello js3~&quot;);   </span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">var test = 20;</span><br><span class="line">test = &quot;张三&quot;;</span><br><span class="line">alert(test);</span><br><span class="line"></span><br><span class="line">//var定义的变量是全局变量,可以重复定义.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 函数定义方式1    </span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">        return a + b;    </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">// 函数定义方式2</span><br><span class="line">var sub = function (a, b) &#123;</span><br><span class="line">return a - b;  &#125;</span><br><span class="line">var subResult = sub(3,5)    </span><br><span class="line">alert(subResult);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-4-BOM"><a href="#4-4-BOM" class="headerlink" title="4.4 BOM:"></a>4.4 BOM:</h2><p>Browser Object Model 浏览器对象模型.</p>
<p>也就是 JavaScript 将浏览器的各个组成部分封装为对象。操作浏览器的各个组成部分就可以通过操作 BOM 中的对象来实现。<br><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525200410879.png" alt="image-20230525200410879"></p>
<h2 id="4-5-DOM"><a href="#4-5-DOM" class="headerlink" title="4.5 DOM:"></a>4.5 DOM:</h2><p>Document Object Model 文档对象模型.</p>
<p>Document Object Model 文档对象模型。即： JavaScript 将 HTML 文档的各个组成部分封装为对象封装的对象分为：document：整个文档对象element：元素对象attribute：属性对象text：文本对象comment：注释对象.</p>
<p>通过DOM,可以对html进行操作.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525200624000.png" alt="image-20230525200624000"></p>
<p>使用举例:点亮图片:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525200726476.png" alt="image-20230525200726476"></p>
<h2 id="4-6-事件监听"><a href="#4-6-事件监听" class="headerlink" title="4.6 事件监听:"></a>4.6 事件监听:</h2><p>HTML 事件是发生在 HTML 元素上的“事情”。比如：页面上的 按钮被点击、鼠标移动到元素之上、按下键盘按键等都是事件。</p>
<p>事件监听是 JavaScript 可以在 事件被侦测到时 执行一段逻辑代码。</p>
<h1 id="5-http"><a href="#5-http" class="headerlink" title="5.http:"></a>5.http:</h1><h2 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1: 定义:"></a>5.1: 定义:</h2><p>Hyper Text Transfer Protocol 超文本传输协议</p>
<h2 id="5-2-特点"><a href="#5-2-特点" class="headerlink" title="5.2 特点:"></a>5.2 特点:</h2><p>基于TCP协议：面向连接，安全。</p>
<p>基于请求&#x2F;响应模型的：一次请求对应一次响应无状态：对于事务处理没有记忆能力。每次请求-响应之间相互独立。</p>
<p>优点：速度快</p>
<p>缺点：多次请求间不能共享数据。</p>
<h2 id="5-3-消息格式"><a href="#5-3-消息格式" class="headerlink" title="5.3 消息格式:"></a>5.3 消息格式:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524101342314.png"></p>
<p>空行的作用是分割正文和请求头.</p>
<p>响应:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524101438649.png" alt="image-20230524101438649"></p>
<h1 id="6-tomcat"><a href="#6-tomcat" class="headerlink" title="6.tomcat:"></a>6.tomcat:</h1><h2 id="6-1-web服务器"><a href="#6-1-web服务器" class="headerlink" title="6.1 web服务器:"></a>6.1 web服务器:</h2><p>Web服务器是一个应用程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是 ”提供网上信息浏览服务 ”.</p>
<h2 id="6-2-介绍"><a href="#6-2-介绍" class="headerlink" title="6.2 介绍:"></a>6.2 介绍:</h2><p>Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范。</p>
<h2 id="6-3-项目结构"><a href="#6-3-项目结构" class="headerlink" title="6.3 项目结构:"></a>6.3 项目结构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524101627252.png" alt="image-20230524101627252"></p>
<h2 id="6-4-启动与部署"><a href="#6-4-启动与部署" class="headerlink" title="6.4 启动与部署:"></a>6.4 启动与部署:</h2><p>启动:</p>
<p>点击bin下 startup.bat.</p>
<p>部署:</p>
<p>拷贝到webapps下,也可以打包成war包在进行拷贝.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524101919152.png" alt="image-20230524101919152"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524101952986.png" alt="image-20230524101952986"></p>
<h1 id="7-Servlet"><a href="#7-Servlet" class="headerlink" title="7.Servlet:"></a>7.Servlet:</h1><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍:"></a>7.1 介绍:</h2><p>Servlet 是 java 提供的一门 动态 web资源开发技术。Servlet 是 Java EE 规范之一，是一个接口。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524102931979.png" alt="image-20230524102931979"></p>
<h2 id="7-2-生命周期"><a href="#7-2-生命周期" class="headerlink" title="7.2 生命周期:"></a>7.2 生命周期:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524165458955.png" alt="image-20230524165458955"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524165522763.png" alt="image-20230524165522763"></p>
<h2 id="7-3-HTTPServlet"><a href="#7-3-HTTPServlet" class="headerlink" title="7.3 HTTPServlet:"></a>7.3 HTTPServlet:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524165611678.png" alt="image-20230524165611678"></p>
<p>还有xml的配置方式:</p>
<p><strong><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524165714050.png" alt="image-20230524165714050"></strong></p>
<h1 id="8-xml"><a href="#8-xml" class="headerlink" title="8.xml:"></a>8.xml:</h1><p>XML（ Extensible Markup Language），可扩展标记语言。是由 W3C 推出一种类似于 HTML 的标记语言。 可扩展体现在：标签都是自定义的。</p>
<h2 id="8-1-基本格式"><a href="#8-1-基本格式" class="headerlink" title="8.1 基本格式:"></a>8.1 基本格式:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524165948944.png" alt="image-20230524165948944"></p>
<h2 id="8-2-约束"><a href="#8-2-约束" class="headerlink" title="8.2 约束:"></a>8.2 约束:</h2><h3 id="8-2-1-DTD"><a href="#8-2-1-DTD" class="headerlink" title="8.2.1 DTD:"></a>8.2.1 DTD:</h3><p>为了规范xml的标签的格式.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170104514.png" alt="image-20230524170104514"></p>
<h3 id="8-2-2-Schema"><a href="#8-2-2-Schema" class="headerlink" title="8.2.2 Schema:"></a>8.2.2 Schema:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170236775.png" alt="image-20230524170236775"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170255144.png" alt="image-20230524170255144"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170317951.png" alt="image-20230524170317951"></p>
<h1 id="9-Maven"><a href="#9-Maven" class="headerlink" title="9.Maven:"></a>9.Maven:</h1><h2 id="9-1-简介"><a href="#9-1-简介" class="headerlink" title="9.1 简介:"></a>9.1 简介:</h2><p>Maven 是专门用于管理和构建 Java 项目的工具。主要功能提供了一套标准化的项目结构提供了一套标准化的构建流程（编译，测试，打包，发布……）提供了一套依赖管理机制.</p>
<h2 id="9-2-项目结构"><a href="#9-2-项目结构" class="headerlink" title="9.2 项目结构:"></a>9.2 项目结构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170505576.png" alt="image-20230524170505576"></p>
<h2 id="9-3-POM"><a href="#9-3-POM" class="headerlink" title="9.3 POM:"></a>9.3 POM:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170549767.png" alt="image-20230524170549767"></p>
<h2 id="9-4-仓库"><a href="#9-4-仓库" class="headerlink" title="9.4 仓库:"></a>9.4 仓库:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170641960.png" alt="image-20230524170641960"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170657281.png" alt="image-20230524170657281"></p>
<h2 id="9-5-生命周期"><a href="#9-5-生命周期" class="headerlink" title="9.5 生命周期:"></a>9.5 生命周期:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170726626.png" alt="image-20230524170726626"></p>
<h1 id="10-request-amp-response"><a href="#10-request-amp-response" class="headerlink" title="10. request&amp;response:"></a>10. request&amp;response:</h1><h2 id="10-1-语法"><a href="#10-1-语法" class="headerlink" title="10.1: 语法:"></a>10.1: 语法:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524170853865.png" alt="image-20230524170853865"></p>
<h2 id="10-2-访问过程"><a href="#10-2-访问过程" class="headerlink" title="10.2 访问过程:"></a>10.2 访问过程:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524171015404.png" alt="image-20230524171015404"></p>
<h1 id="11-JDBC"><a href="#11-JDBC" class="headerlink" title="11.JDBC:"></a>11.JDBC:</h1><h2 id="11-1-简介"><a href="#11-1-简介" class="headerlink" title="11.1 简介:"></a>11.1 简介:</h2><p>JDBC：使用Java语言操作关系型数据库的一套API。全称：( Java DataBase Connectivity ) Java 数据库连接</p>
<h2 id="11-2-语法"><a href="#11-2-语法" class="headerlink" title="11.2 语法:"></a>11.2 语法:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524171326623.png" alt="image-20230524171326623"></p>
<h2 id="11-3-数据库连接池"><a href="#11-3-数据库连接池" class="headerlink" title="11.3 数据库连接池:"></a>11.3 数据库连接池:</h2><p>池化技术.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524171619940.png" alt="image-20230524171619940"></p>
<h2 id="11-4-druid"><a href="#11-4-druid" class="headerlink" title="11.4 druid:"></a>11.4 druid:</h2><p>Druid 连接池是阿里巴巴开源的数据库连接池项目功能强大，性能优秀是 Java 语言最好的数据库连接池之一.</p>
<h3 id="11-4-1-写配置-引依赖"><a href="#11-4-1-写配置-引依赖" class="headerlink" title="11.4.1 写配置 引依赖."></a>11.4.1 写配置 引依赖.</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524171704094.png" alt="image-20230524171704094"></p>
<h3 id="11-4-2-代码连接"><a href="#11-4-2-代码连接" class="headerlink" title="11.4.2 代码连接:"></a>11.4.2 代码连接:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524171756673.png" alt="image-20230524171756673"></p>
<h2 id="11-5-jdbcTemplate"><a href="#11-5-jdbcTemplate" class="headerlink" title="11.5 jdbcTemplate:"></a>11.5 jdbcTemplate:</h2><p>简化操作:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524171947128.png" alt="image-20230524171947128"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230524172017726.png" alt="image-20230524172017726"></p>
<h1 id="12-MVC架构"><a href="#12-MVC架构" class="headerlink" title="12.MVC架构:"></a>12.MVC架构:</h1><p>架构示例图:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525164114821.png" alt="image-20230525164114821"></p>
<h1 id="13-会话技术"><a href="#13-会话技术" class="headerlink" title="13. 会话技术:"></a>13. 会话技术:</h1><h2 id="13-1-会话跟踪"><a href="#13-1-会话跟踪" class="headerlink" title="13.1 会话跟踪:"></a>13.1 会话跟踪:</h2><p>浏览器无状态,会话跟踪技术是为了解决这个问题出现的技术.</p>
<h2 id="13-2-cookie"><a href="#13-2-cookie" class="headerlink" title="13.2 cookie:"></a>13.2 cookie:</h2><p>存储在客户端.认证过程如下:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/web_1684982156224.png" alt="web_1684982156224"></p>
<h2 id="13-3-session"><a href="#13-3-session" class="headerlink" title="13.3 session:"></a>13.3 session:</h2><p>cookie的升级版,存储在服务器端.认证过程如下:<br><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/web_1684982167273.png" alt="web_1684982167273"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/Screenshot_20230525_103517.jpg" alt="Screenshot_20230525_103517"></p>
<p>基本使用:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525165325065.png" alt="image-20230525165325065"></p>
<h3 id="13-3-1-钝化和活化"><a href="#13-3-1-钝化和活化" class="headerlink" title="13.3.1 钝化和活化:"></a>13.3.1 钝化和活化:</h3><p>钝化：在服务器正常关闭后，Tomcat 会自动将 Session 数据写入硬盘的文件中。钝化的数据路径为: 项目目录\target\tomcat\work\Tomcat\ localhost\项目名称\SESSIONS.ser.</p>
<p>活化：再次启动服务器后，从文件中加载数据到 Session 中.</p>
<h2 id="13-4-小结"><a href="#13-4-小结" class="headerlink" title="13.4 小结:"></a>13.4 小结:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525165429477.png" alt="image-20230525165429477"></p>
<h1 id="14-Filter"><a href="#14-Filter" class="headerlink" title="14. Filter:"></a>14. Filter:</h1><h2 id="14-1-简介"><a href="#14-1-简介" class="headerlink" title="14.1 简介:"></a>14.1 简介:</h2><p>拦截特定的请求,并进行一系列操作.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525165614821.png" alt="image-20230525165614821"></p>
<h2 id="14-2-开发"><a href="#14-2-开发" class="headerlink" title="14.2 开发:"></a>14.2 开发:</h2><h3 id="14-2-1-demo"><a href="#14-2-1-demo" class="headerlink" title="14.2.1 demo:"></a>14.2.1 demo:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//配置拦截路径.也可以通过xml的方式进行配置</span><br><span class="line">@WebFilter(&quot;/*&quot;)</span><br><span class="line"></span><br><span class="line">//实现filer接口</span><br><span class="line">public class FilterDemo1 implements Filter &#123;    </span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">@Override    </span><br><span class="line">public void init(FilterConfig filterConfig) throws ServletException &#123;    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//拦截的具体方法</span><br><span class="line">@Override    </span><br><span class="line">public void doFilter(ServletRequest servletRequest,ServletResponse servletResponse,FilterChainfilterChain)throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">//具体逻辑</span><br><span class="line">System.out.println(“filterDemo1 过滤....&quot;);       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//放行语句</span><br><span class="line">filterChain.doFilter(servletRequest,servletResponse);    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">//销毁</span><br><span class="line">@Override    public void destroy() &#123;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-3-过滤器链"><a href="#14-3-过滤器链" class="headerlink" title="14.3 过滤器链:"></a>14.3 过滤器链:</h2><p>当配置多个过滤器时,称为过滤器链.</p>
<p>执行顺序:</p>
<p>注解配置时过滤器执行顺序：当使用注解配置多个 Filter 时，用户无法控制它们的执行顺序，Filter的执行顺序按照类名的字符串比较规则比较，值小的先执行AFilter 和 BFilter，AFilter就先执行web.xml配置： <filter-mapping>谁定义在上边，谁先执行</p>
<h1 id="15-Ajax"><a href="#15-Ajax" class="headerlink" title="15.Ajax:"></a>15.Ajax:</h1><p>Ajax：ASynchronous JavaScript And XML：异步 的 JavaScript 和 XML。</p>
<p>JavaScript 表明该技术和前端相关XML 是指以此进行数据交换.</p>
<p>Ajax 的作用：与服务器进行数据交换异步交互.</p>
<h2 id="15-1-同步-异步交互"><a href="#15-1-同步-异步交互" class="headerlink" title="15.1 同步.异步交互:"></a>15.1 同步.异步交互:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525170425027.png" alt="image-20230525170425027"></p>
<h2 id="15-2-体系结构"><a href="#15-2-体系结构" class="headerlink" title="15.2 体系结构:"></a>15.2 体系结构:</h2><p>通过ajax,后端可以不向前端发送html文件,而是发送特定格式的数据.避免了在Java中编写html的复杂情况出现.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525170452141.png" alt="image-20230525170452141"></p>
<h2 id="15-3-入门"><a href="#15-3-入门" class="headerlink" title="15.3 入门:"></a>15.3 入门:</h2><p>服务端:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@WebServlet(&quot;/selectUserServlet&quot;)</span><br><span class="line">public class SelectUserServlet extends HttpServlet &#123;    </span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"> //1. 接收用户名        </span><br><span class="line"> String username = request.getParameter(&quot;username&quot;);       </span><br><span class="line"> //2. 此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用        </span><br><span class="line"> boolean flag = true;        </span><br><span class="line"> //3. 响应标记        </span><br><span class="line"> response.getWriter().write(&quot;&quot; + flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Override    </span><br><span class="line">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">this.doGet(request, response);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1. 给用户名输入框绑定 失去焦点事件</span><br><span class="line">document.getElementById(&quot;username&quot;).onblur = function () &#123;</span><br><span class="line"></span><br><span class="line">//2. 发送ajax请求    </span><br><span class="line"></span><br><span class="line">// 获取用户名的值    </span><br><span class="line">var username = this.value;    </span><br><span class="line"></span><br><span class="line">//2.1. 创建核心对象    var xhttp;    </span><br><span class="line"></span><br><span class="line">if (window.XMLHttpRequest) &#123;        </span><br><span class="line">xhttp = new XMLHttpRequest();    </span><br><span class="line">&#125;else &#123;</span><br><span class="line">xhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">//2.2. 发送请求    </span><br><span class="line">xhttp.open(&quot;GET&quot;, &quot;http://localhost:8080/ajax-demo/selectUserServlet?username=&quot;+username);    </span><br><span class="line">xhttp.send();    </span><br><span class="line"></span><br><span class="line">//2.3. 获取响应    </span><br><span class="line">xhttp.onreadystatechange = function() &#123;</span><br><span class="line">if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;</span><br><span class="line"></span><br><span class="line">if(this.responseText == &quot;true&quot;)&#123;                </span><br><span class="line">//用户名存在，显示提示信息                </span><br><span class="line">document.getElementById(&quot;username_err&quot;).style.display = &#x27;&#x27;;            </span><br><span class="line">&#125;else &#123;</span><br><span class="line">//用户名不存在 ，清楚提示信息</span><br><span class="line">document.getElementById(&quot;username_err&quot;).style.display = &#x27;none&#x27;;            </span><br><span class="line"></span><br><span class="line">&#125;        </span><br><span class="line">&#125;    </span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-4-JQuery"><a href="#15-4-JQuery" class="headerlink" title="15.4 JQuery:"></a>15.4 JQuery:</h2><p>主要包括:</p>
<p>$.ajax() &#x2F;&#x2F; jQuery 底层 AJAX 实现</p>
<p>$.get()  &#x2F;&#x2F; get方式</p>
<p>$.post() &#x2F;&#x2F; post方式</p>
<p>对原生的ajax进行了封装,使用变得更加的便捷.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525172055054.png" alt="image-20230525172055054"></p>
<p>success和error的值是回调函数:在函数内部定义并使用的函数.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525172408869.png" alt="image-20230525172408869"></p>
<p>post与get类似,只是把.get换成.post.</p>
<h2 id="15-5-axios"><a href="#15-5-axios" class="headerlink" title="15.5 axios:"></a>15.5 axios:</h2><p>同样是对原生的ajax进行封装没达到简化书写的目的.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525172616668.png" alt="image-20230525172616668"></p>
<p>.then是回调函数.在请求成功响应过后才会被调用. resp是对后端返回的数据进行封装过后的对象.</p>
<h2 id="15-6-JSON"><a href="#15-6-JSON" class="headerlink" title="15.6 JSON:"></a>15.6 JSON:</h2><p> JavaScript Object Notation:JavaScript 对象表示法</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230525174907410.png" alt="image-20230525174907410"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从IOC到java架构</title>
    <url>/2023/03/18/%E4%BB%8EIOC%E5%88%B0Java%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="从SpringIOC到架构设计"><a href="#从SpringIOC到架构设计" class="headerlink" title="从SpringIOC到架构设计"></a>从SpringIOC到架构设计</h1><h1 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的:"></a>1.目的:</h1><p>从Spring框架的IOC,DI,SpringBoot的自动装配原理产生原因,作用,实现原理入手,浅析框架的简化开发作用,以及框架的设计思路.</p>
<h1 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程:"></a>2.流程:</h1><h2 id="2-1-引入"><a href="#2-1-引入" class="headerlink" title="2.1 引入:"></a>2.1 引入:</h2><h5 id="使用框架的感受-SpringBoot框架"><a href="#使用框架的感受-SpringBoot框架" class="headerlink" title="使用框架的感受?(SpringBoot框架)"></a>使用框架的感受?(SpringBoot框架)</h5><p>方便快捷.快速开发,调试,部署.</p>
<p>编程语言从汇编语言到高级语言,程序员开发的工具越来越简单.而现在的主流开发,尤其是后端开发,越来越依赖于框架.框架的作用有很多,其核心目的就是简化开发.使编程人员能够更加专注于业务逻辑而最大程度上忽略其他的东西.</p>
<p>如何简化开发?不同的语言的框架,有很多不同的实现方式.接下来我们主要关注Java语言.</p>
<h5 id="Java语言的核心是什么"><a href="#Java语言的核心是什么" class="headerlink" title="Java语言的核心是什么?"></a>Java语言的核心是什么?</h5><p> 面向对象程序设计,一切皆对象,在所有的程序中都会出现的一点就是类和对象的管理.同时这也是java程序所面临的最大的问题.</p>
<p>对象管理包括:</p>
<p>1.对象的产生</p>
<p>2.对象的使用</p>
<p>3.对象的销毁</p>
<p>我们先来看对象的销毁.</p>
<h5 id="首先-回答一下c语言和c-的对象的销毁方式"><a href="#首先-回答一下c语言和c-的对象的销毁方式" class="headerlink" title="首先,回答一下c语言和c++的对象的销毁方式,"></a>首先,回答一下c语言和c++的对象的销毁方式,</h5><p>是由程序主动关闭.</p>
<p>而Java程序对象是如何销毁的?是由JVM自动进行垃圾回收的.这就是简化开发的角度上java比c和c++先进的地方,但是现在,对象的销毁问题解决了,对象的创建和使用问题怎么办呢?这是单纯地Java所不能解决的.</p>
<h2 id="2-2-DI"><a href="#2-2-DI" class="headerlink" title="2.2 DI:"></a>2.2 DI:</h2><p>先来看两段代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class Car()&#123;</span><br><span class="line"></span><br><span class="line">	private Bottom bottom;</span><br><span class="line">	</span><br><span class="line">	public Car()&#123;</span><br><span class="line">	this.bottom = new Bottom();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Class Bottom()&#123;</span><br><span class="line"></span><br><span class="line">	int a;</span><br><span class="line">	</span><br><span class="line">	public Bottom()&#123;</span><br><span class="line">	this.a = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class Car()&#123;</span><br><span class="line"></span><br><span class="line">	private Bottom bottom;</span><br><span class="line">	</span><br><span class="line">	public Car(Bottom bottom)&#123;</span><br><span class="line">	this.bottom = Bottom bottom;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Class Bottom()&#123;</span><br><span class="line">	int a;</span><br><span class="line">	</span><br><span class="line">	public Bottom()&#123;</span><br><span class="line">	this.a = 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种写法在程序的调用时候略有不同，第一种是在主程序中直接new一个car（）对象就完成了。而第二种则需要先new一个bottom对象，然后再new一个car对象。这样看来，似乎第一种写法更加简练一些，可是，事实真的是如此吗？</p>
<p>让我们考虑一种情况：</p>
<p>当bottom发生修改时，比如a的值通过传入一个变量来确定的时候，这样对于第一种写法，所有的构造函数全部都需要修改，而对于第二种方式则只需要修改一个构造函数即可。</p>
<p>对于第一种设计来说，<strong>这样的设计基本是不可维护的</strong>，因为在实际工程中，有些类会有几千个底层，如果要一一修改，所耗费的成本太大了。</p>
<p>而且，在第一种写法中，创建car对象必然会创建一个新的bottom对象，纵使会被销毁，但是也在一定程度上增加了开销。</p>
<p>所以现在我们知道，采用第二种写法是比较合理的，即：</p>
<h5 id="所有的new对象的过程都写在程序运行时，而不是再类的构造方法中。构造方法中统一更改为传入所需要的类的对象这种格式。"><a href="#所有的new对象的过程都写在程序运行时，而不是再类的构造方法中。构造方法中统一更改为传入所需要的类的对象这种格式。" class="headerlink" title="所有的new对象的过程都写在程序运行时，而不是再类的构造方法中。构造方法中统一更改为传入所需要的类的对象这种格式。"></a>所有的new对象的过程都写在程序运行时，而不是再类的构造方法中。构造方法中统一更改为传入所需要的类的对象这种格式。</h5><h5 id="这就是依赖注入（Dependency-Injection）。"><a href="#这就是依赖注入（Dependency-Injection）。" class="headerlink" title="这就是依赖注入（Dependency Injection）。"></a>这就是依赖注入（<strong>Dependency Injection</strong>）。</h5><p>依赖注入的主谓宾补充完整，就是将调用者所依赖的类实例对象注入到调用者类。而在这个例子中，car依赖于bottom，car开放了一个接口（这里其实是构造方法）使它的依赖bottom对象可以注入到自己的对象中来。提高了系统的可维护性和可扩展性。</p>
<h2 id="2-3-IOC："><a href="#2-3-IOC：" class="headerlink" title="2.3 IOC："></a>2.3 IOC：</h2><p>好了，在有了上面的基础之后，我们再来看我们的程序，现在它已经变成了大概这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    A a  = new A();</span><br><span class="line">    //a发挥作用</span><br><span class="line">    B b = new B();</span><br><span class="line">    //b发挥作用</span><br><span class="line">    C c = new C():</span><br><span class="line">    //c发挥作用</span><br><span class="line">    ......</span><br><span class="line">    A a  = new A();</span><br><span class="line">    //a发挥作用</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这样，仍然会出现很多问题.</p>
<p>如果a是某个接口的实现类，现在需要修改a的实现类，换成另一个类，这样就需要修改所有的new A的方法，这样仍然是十分复杂而不可维护的。</p>
<p>那么，能不能有一种机制来解决这个问题呢？这就体现出框架的作用了。</p>
<h5 id="框架可以帮助我们创建对象"><a href="#框架可以帮助我们创建对象" class="headerlink" title="框架可以帮助我们创建对象."></a>框架可以帮助我们创建对象.</h5><p>只需要我们通过一些语法告诉框架我们需要什么样的对象，它的名字是什么，它的类在什么地方，程序就会自动的帮我们创建对象，我们只需要在需要这个对象的时候问框架要这个对象就可以了. 来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.spring.demo;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">	&lt;bean id=&quot;person&quot; class=&quot;com.spring.demo.Person&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;name&quot; value=&quot;zje&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.spring.demo;</span><br><span class="line"> </span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line">public class TextIoc &#123;</span><br><span class="line">	@Test</span><br><span class="line">	public void textUser()</span><br><span class="line">	&#123;</span><br><span class="line">		//1.获取spring配置文件</span><br><span class="line">		 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Bean.xml&quot;);</span><br><span class="line">		 //2.由配置文件返回对象</span><br><span class="line">		 Person p = (Person)context.getBean(&quot;person&quot;);</span><br><span class="line">		 System.out.println(p);</span><br><span class="line">		 p.info();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种机制主要由三个组成:</p>
<p>1.框架读取配置文件(也有可能是某些注解),获取类的有关信息.</p>
<p>2.根据类文件生成对象(bean)</p>
<p>3.在程序中通过(bean)方法获取对象.</p>
<p>这样在发生修改时,只需要修改配置文件中的相关信息,就可以实现修改,而不需要修改代码中的所有new 语句.</p>
<p>在这种框架下,我们再也不需要手动的创建对象,而是由框架帮我们创建对象,换句话说,我们把对象的控制权完全的交给了程序(框架)(以前是销毁权利,现在是全部的权利).</p>
<h5 id="这就是控制反转（Inversion-of-Control）-同样也是轻量级的Spring框架的核心。"><a href="#这就是控制反转（Inversion-of-Control）-同样也是轻量级的Spring框架的核心。" class="headerlink" title="这就是控制反转（Inversion of Control）.同样也是轻量级的Spring框架的核心。"></a>这就是控制反转（Inversion of Control）.同样也是轻量级的Spring框架的核心。</h5><p>不同的教程和文章对这两个词有很多种不同的解读,我认为,这样解读是最通俗易懂和符合常理的一种方式.</p>
<p>接下来我们主要关注Java语言,Java语言的核心是面向对象设计,在Java中,一切皆对象,在所有的程序中都会出现的一点就是类和对象的管理.同时这也是java程序所面临的最大的问题.</p>
<h5 id="这样，我们就把java的对象创建和使用的问题，变成了bean的创建和获取的问题。"><a href="#这样，我们就把java的对象创建和使用的问题，变成了bean的创建和获取的问题。" class="headerlink" title="这样，我们就把java的对象创建和使用的问题，变成了bean的创建和获取的问题。"></a>这样，我们就把java的对象创建和使用的问题，变成了bean的创建和获取的问题。</h5><h3 id="2-3-1-简单的手写一个IOC容器"><a href="#2-3-1-简单的手写一个IOC容器" class="headerlink" title="2.3.1 简单的手写一个IOC容器:"></a>2.3.1 简单的手写一个IOC容器:</h3><p>容器类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class IOCContainer &#123;</span><br><span class="line">    private Map&lt;String, Object&gt; beans; // 存储对象实例的 Map</span><br><span class="line"></span><br><span class="line">​    //初始化</span><br><span class="line">​    public IOCContainer() &#123;</span><br><span class="line">​        beans = new HashMap&lt;&gt;();</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 获取 bean 对象</span><br><span class="line">    public Object getBean(String name) &#123;</span><br><span class="line">        return beans.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">​    // 注册 bean 到容器中</span><br><span class="line">​    private Object registerBean(String name,Class&lt;?&gt; clazz, Map&lt;String, Object&gt; properties) throws Exception &#123;</span><br><span class="line">​        try &#123;</span><br><span class="line">​            // 获取无参数的构造函数</span><br><span class="line">​            Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">​            Constructor&lt;?&gt; constructor = null;</span><br><span class="line">​            for (Constructor&lt;?&gt; c : constructors) &#123;</span><br><span class="line">​                if (c.getParameterCount() == 0) &#123;</span><br><span class="line">​                    constructor = c;</span><br><span class="line">​                    break;</span><br><span class="line">​                &#125;</span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            if (constructor == null) &#123;</span><br><span class="line">​                throw new RuntimeException(&quot;No default constructor found for bean: &quot; + clazz);</span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            //生成实例</span><br><span class="line">​            Object bean = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">​            // 获取变量属性，进行注入</span><br><span class="line">​            for (Field field : clazz.getDeclaredFields()) &#123;</span><br><span class="line">​                if (properties.containsKey(field.getName())) &#123;</span><br><span class="line">​                    field.setAccessible(true);</span><br><span class="line">​                    field.set(bean, properties.get(field.getName()));</span><br><span class="line">​                &#125;</span><br><span class="line">​            &#125;</span><br><span class="line"></span><br><span class="line">​            //注册到bean容器中</span><br><span class="line">​            beans.put(name,bean);</span><br><span class="line">​            return bean;</span><br><span class="line"></span><br><span class="line">​        &#125; catch (Exception e) &#123;</span><br><span class="line">​            throw new RuntimeException(&quot;Failed to create bean: &quot; + clazz, e);</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">​        IOCContainer iocContainer = new IOCContainer();</span><br><span class="line"></span><br><span class="line">​        // 注册 test到容器中</span><br><span class="line">​        Map&lt;String, Object&gt; testProperties = new HashMap&lt;&gt;();</span><br><span class="line">​        testProperties.put(&quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">​        iocContainer.registerBean(&quot;test&quot;, Test.class, testProperties);</span><br><span class="line"></span><br><span class="line">​        // 获取 test对象并调用方法</span><br><span class="line">​        Test test = (Test) iocContainer.getBean(&quot;test&quot;);</span><br><span class="line">​        test.Hello();</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">​    private String name;</span><br><span class="line">​    public void Hello()&#123;</span><br><span class="line">​        System.*out*.println(&quot;Hello!&quot;+this.name);</span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    public  Test()&#123;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-Autowried"><a href="#2-4-Autowried" class="headerlink" title="2.4 @Autowried:"></a>2.4 @Autowried:</h2><p>我们先来看bean的获取。</p>
<p>现在,我们的程序已经变成了这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     A a  = （A） context.getBean(&quot;A&quot;);</span><br><span class="line">     //a发挥作用</span><br><span class="line">     B b = (B) context.getBean(&quot;A&quot;);</span><br><span class="line">     //b发挥作用</span><br><span class="line">     C c = (C) context.getBean(&quot;A&quot;):</span><br><span class="line">     //c发挥作用</span><br><span class="line">     ......</span><br><span class="line">     A a  = (A) context.getBean(&quot;A&quot;);</span><br><span class="line">     //a发挥作用</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class MyApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        MyBean myBean = (MyBean) context.getBean(&quot;myBean&quot;);</span><br><span class="line">        myBean.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样手动获取bean的方式仍然是非常繁琐和容易出错的，因为我们需要同时指定bean的类型和名称。</p>
<p>那么可不可以自动的获取bean呢？只要我创建一个变量就好了。</p>
<p>使用自动装配（<code>@Autowired</code>注解）的好处包括：</p>
<ol>
<li><p>简化代码：自动装配可以大大减少手动装配的代码，特别是在大型应用程序中，手动装配可能非常繁琐和易错。</p>
</li>
<li><p>更加可读性：通过使用自动装配，代码可以更加清晰和易于理解。不再需要在代码中指定显式的依赖注入，而是通过注解告诉Spring容器应该注入哪些依赖项。</p>
</li>
<li><p>更加灵活：使用自动装配可以使代码更加灵活，因为它可以在运行时自动解析依赖关系。这使得代码更加易于维护和测试，因为您不需要手动维护依赖关系。</p>
</li>
<li><p>可扩展性：使用自动装配可以使代码更加易于扩展。例如，如果您需要添加新的组件或服务，您可以使用自动装配来自动解析它们的依赖关系，而不需要手动修改现有代码。</p>
</li>
<li><p>更高的生产率：使用自动装配可以提高生产率，因为它可以使您的代码更加简洁、易于理解和易于维护。这意味着您可以更快地编写代码，并且更容易开发和维护复杂的应用程序。</p>
</li>
</ol>
<p>这就是@Autowried注解，它的意思是自动注入，补充完整是自动把IOC中的bean注入到它所需要的地方去。请注意这里的自动注入和下文的自动装配，和上文的依赖注入都有所区别，注意区分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">UserScoreRecordRepository userScoreRecordRepository;</span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;/addstrip&quot;)</span><br><span class="line">public Result addScore(@RequestParam(&quot;name&quot;) String name,</span><br><span class="line">                       @RequestBody() List&lt;AddStrip&gt; addStrips) &#123;</span><br><span class="line">    return activityService.addScore(name, addStrips);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;/searchActivity&quot;)</span><br><span class="line">@RequestParam(&quot;status&quot;) Integer status) &#123;</span><br><span class="line">        return activityService.searchScore(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-5-自动装配："><a href="#2-5-自动装配：" class="headerlink" title="2.5 自动装配："></a>2.5 自动装配：</h2><p>现在看来，似乎一切都非常完美……除了各种恶心的配置.</p>
<p>现在我们的开发过程是怎么样的呢? 新建项目,引入依赖,编写各种xml配置文件或者JavaConfig类,然后开始代码开发.</p>
<p>这是一个实际组件的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = new</span><br><span class="line">                UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">        corsConfiguration.setAllowCredentials(false);</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration);</span><br><span class="line">        CorsFilter corsFilter = new CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">        return corsFilter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是,在实际的开发中,我们需要依赖的第三方组件是非常多的,比如tommat,mybatis等等,每当我引入这些依赖的时候,由于这协议来本身还依赖于其他的一些bean,我就需要写一大堆的配置才能完整配置,然后进行开发.</p>
<p>但是在很多时候,我们可以发现,在大多数情况下,所写出来的配置文件的细节都是差不多的,这时候就不禁引起我们思考了:能不能自动的导入这些配置文件呢?</p>
<h5 id="这就是自动装配-简单来说-就是在约定大于配置的基础上-在第三方组件引入的时候-自动的带上一份配置文件-然后由框架自动的加载这些配置文件-自动的注入IOC容器生成bean"><a href="#这就是自动装配-简单来说-就是在约定大于配置的基础上-在第三方组件引入的时候-自动的带上一份配置文件-然后由框架自动的加载这些配置文件-自动的注入IOC容器生成bean" class="headerlink" title="这就是自动装配.简单来说,就是在约定大于配置的基础上,在第三方组件引入的时候,自动的带上一份配置文件,然后由框架自动的加载这些配置文件,自动的注入IOC容器生成bean."></a>这就是自动装配.简单来说,就是在约定大于配置的基础上,在第三方组件引入的时候,自动的带上一份配置文件,然后由框架自动的加载这些配置文件,自动的注入IOC容器生成bean.</h5><p>这样就不需要我们为大多数组件手动的配置编写配置文件了。</p>
<p>这里就有同学要问了，那我在spingboot中为那些组件写的@bean注解是什么？不是已经有自动装配了吗？</p>
<p>但是在一些特定的情况下,仍然需要我们手动的配置文件.</p>
<ol>
<li>需要使用自定义的第三方组件，而该组件的配置无法通过自动配置来完成。</li>
<li>需要使用一些较为复杂的配置，比如多数据源配置、分布式事务配置等。</li>
<li>需要对一些组件的配置进行细粒度的控制，比如缓存的 TTL、连接池的大小等。</li>
<li>需要对一些组件进行自定义扩展，比如自定义错误处理、自定义消息转换等。</li>
</ol>
<p>就像在上文的跨域配置中，因为需要配置的东西特别多，而且在不同的应用场景下不太一样，所以仍然需要自己手动配置。</p>
<p>浅浅总结一下：</p>
<p>Spring Boot的自动装配和<code>@Autowired</code>注解都是基于Spring框架的IoC容器实现的，不同的是它们自动化的实现方式略有不同。</p>
<p>在Spring Boot中，自动装配的核心是自动读取并配置各种组件和依赖项。Spring Boot会自动扫描应用程序的类路径，查找并读取各种配置文件（例如<code>application.properties</code>或<code>application.yml</code>），并根据这些配置信息自动配置和初始化各种组件和依赖项。这样，我们就不需要手动配置和初始化每个组件和依赖项，从而简化了应用程序的开发和部署。</p>
<p>而<code>@Autowired</code>注解的自动则是指自动查找和注入符合类型要求的Bean对象。当我们在代码中使用<code>@Autowired</code>注解时，Spring IoC容器会自动查找并创建符合类型要求的Bean对象，并将它们注入到我们的类中。这样，我们就不需要手动创建和配置每个Bean对象，从而简化了依赖注入的实现。</p>
<p>总之，Spring Boot的自动装配和<code>@Autowired</code>注解都是基于Spring框架的IoC容器实现的，它们通过不同的自动化方式简化了应用程序的开发和部署。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/20210629121733256.png" alt="20210629121733256"></p>
<h2 id="2-6-代码生成："><a href="#2-6-代码生成：" class="headerlink" title="2.6 代码生成："></a>2.6 代码生成：</h2><p>(探讨部分)</p>
<p>现在，我们对框架的介绍已经进行到了实际开发的地步，日常开发中我们使用的spring boot基本上就是基于以上的原理和方法在进行简化开发的，但是框架的开发是没有尽头的，这不由得再次引发我们的思考，这就是最优秀的框架了吗?</p>
<p>事实上,虽然spring什么都能做,但是它最大的用处还是用来进行后端的那种crud开发,而这种开发一般都是遵循mvc模式,在这种情况下,有没有过这种疑惑?</p>
<p>来看一个service和controller:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public Result createActivity(String year, Integer type, String name, String</span><br><span class="line">         explanation, String icon, String organization, String time, String site) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         if(activityRepository.findActivityByName(name)!=null)&#123;</span><br><span class="line">             return Result.error(400,&quot;活动名称已存在!&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         Activity activity = new Activity();</span><br><span class="line">         activity.setYear(year);</span><br><span class="line">         activity.setActivityType(type);</span><br><span class="line">         activity.setAname(name);</span><br><span class="line">         activity.setExplanation(explanation);</span><br><span class="line">         activity.setIcon(icon);</span><br><span class="line">         activity.setOrganization(organization);</span><br><span class="line">         activity.setTime(time);</span><br><span class="line">         activity.setSite(site);</span><br><span class="line">         activity.setDeleteStatus(1);</span><br><span class="line">         activity.setStatus(0);</span><br><span class="line">         SimpleDateFormat tempDate = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">         String datetime = tempDate.format(new java.util.Date());</span><br><span class="line">         activity.setCreateTime(datetime);</span><br><span class="line">         activityRepository.save(activity);</span><br><span class="line">         return Result.success(200,&quot;新建活动成功!&quot;);</span><br><span class="line">     &#125;catch (Exception e)&#123;</span><br><span class="line">         return Result.error(500,&quot;新建活动失败!&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/addactivity&quot;)</span><br><span class="line">@ApiOperation(&quot;创建活动&quot;)</span><br><span class="line">public Result createActivity(@ApiParam(&quot;活动年份形如2023春，2023秋&quot;) @RequestParam(&quot;year&quot;) String year,</span><br><span class="line">                             @ApiParam(&quot;活动加分类型,1表示加日常行为分,2表示加个性发展分,3表示加创新创业分,4表示加创新创业讲座学分,&quot;) @RequestParam(&quot;type&quot;) Integer type,</span><br><span class="line">                             @ApiParam(&quot;活动名称&quot;) @RequestParam(&quot;name&quot;) String aname,</span><br><span class="line">                             @ApiParam(&quot;活动备注&quot;) @RequestParam(&quot;explanation&quot;) String explanation,</span><br><span class="line">                             @ApiParam(&quot;活动图片的url&quot;) @RequestParam(&quot;icon&quot;) String icon,</span><br><span class="line">                             @ApiParam(&quot;活动所属社团&quot;) @RequestParam(&quot;organization&quot;) String organization,</span><br><span class="line">                             @ApiParam(&quot;活动进行时间&quot;) @RequestParam(&quot;time&quot;) String time,</span><br><span class="line">                             @ApiParam(&quot;活动进行地点&quot;) @RequestParam(&quot;site&quot;) String site)&#123;</span><br><span class="line">    return activityService.createActivity(year,type,aname,explanation,icon,organization,time,site);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中,controller其实只做了两件事,调用了service的方法,这一点是非常重复的,完全属于重复劳动.为方法所属的参数加上了注释.而这些个注释最后会生成接口文档.</p>
<p>有趣的是,在实际的项目开发中,有很多时候是先有接口文档,然后后端程序员根据接口文档去编写代码.那么在这些的基础上,有没有什么更好地编写mvc模式的crud的方式呢?没有多余的东西,只有业务逻辑</p>
<h5 id="代码生成-根据某种接口定义-自动的生成出了业务逻辑值外的其他所有代码-而一个接口的业务逻辑被抽象成一个方法-程序员只需要关注这个方法即可"><a href="#代码生成-根据某种接口定义-自动的生成出了业务逻辑值外的其他所有代码-而一个接口的业务逻辑被抽象成一个方法-程序员只需要关注这个方法即可" class="headerlink" title="代码生成:根据某种接口定义,自动的生成出了业务逻辑值外的其他所有代码,而一个接口的业务逻辑被抽象成一个方法,程序员只需要关注这个方法即可."></a>代码生成:根据某种接口定义,自动的生成出了业务逻辑值外的其他所有代码,而一个接口的业务逻辑被抽象成一个方法,程序员只需要关注这个方法即可.</h5><p>下面展示的是hertz的代码生成:</p>
<p>接口定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct RegisterRequest &#123;</span><br><span class="line">	1: string username</span><br><span class="line">	2: string password</span><br><span class="line">&#125;</span><br><span class="line">struct RegisterResponse &#123;</span><br><span class="line">	1: string code</span><br><span class="line">	2: string msg</span><br><span class="line">	3: i64 userid</span><br><span class="line">	4: string token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成代码:出了方法内部语句,其余都为框架自动生成.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (s *UserImpl) Register(ctx context.Context, req *api.RegisterRequest) (resp *api.RegisterResponse, err error) &#123;</span><br><span class="line">	//建立数据库连接，数据库名：数据库密码</span><br><span class="line">	dsn := &quot;root:123456@tcp(127.0.0.1:3306)/dbgotest&quot;</span><br><span class="line">	db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">	//处理错误</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		//控制台打印错误日志</span><br><span class="line">		panic(&quot;数据库连接失败!&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var user User</span><br><span class="line">	db.First(&amp;user, &quot;name = ?&quot;, req.Username)</span><br><span class="line">	if db.RowsAffected != 0 &#123;</span><br><span class="line">		resp = &amp;api.RegisterResponse&#123;Code: &quot;1&quot;, Msg: &quot;用户名已经存在!&quot;&#125;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//创建一条数据，传入一个对象</span><br><span class="line">	db.Create(&amp;User&#123;Username: req.Username, Password: req.Password, FollowCount: 0, FollowerCount: 0&#125;)</span><br><span class="line">	resp = &amp;api.RegisterResponse&#123;Code: &quot;0&quot;, Msg: &quot;用户注册成功!&quot;, Token: req.Username&#125;</span><br><span class="line">	return</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码结构:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230422225847.png" alt="QQ截图20230422225847"></p>
<p>这未必是最好的实践方式，只能说，框架的开发和使用是永无止境的，没有最好的框架，只有最合适的框架。</p>
<h1 id="3-参考资料："><a href="#3-参考资料：" class="headerlink" title="3.参考资料："></a>3.参考资料：</h1><p>1.《Inversion of Control Containers and the Dependency Injection pattern》</p>
<p>IOC领域的元老级文章，首次提出了DI的确切概念。</p>
<p>2.掘金：</p>
<p><a href="https://juejin.cn/post/6844904161775976456#heading-7">https://juejin.cn/post/6844904161775976456#heading-7</a></p>
<p><a href="https://juejin.cn/post/7215507413779611707">https://juejin.cn/post/7215507413779611707</a></p>
<p><a href="https://juejin.cn/post/6844903793637720071">https://juejin.cn/post/6844903793637720071</a></p>
<p><a href="https://juejin.cn/post/7162568709955911717">https://juejin.cn/post/7162568709955911717</a></p>
<p>3.CSDN:</p>
<p><a href="https://blog.csdn.net/weixin_54514751/article/details/126055383?ops_request_misc=&request_id=&biz_id=102&utm_term=springioc&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-126055383.nonecase&spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_54514751/article/details/126055383?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=springioc&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-126055383.nonecase&amp;spm=1018.2226.3001.4187</a></p>
<p><a href="https://blog.csdn.net/weixin_52731337/article/details/119170446">https://blog.csdn.net/weixin_52731337/article/details/119170446</a></p>
<p><a href="https://blog.csdn.net/weixin_43826242/article/details/106005176?spm=1001.2014.3001.5506">https://blog.csdn.net/weixin_43826242/article/details/106005176?spm=1001.2014.3001.5506</a></p>
<p><a href="https://blog.csdn.net/qq_24313635/article/details/109431324">https://blog.csdn.net/qq_24313635/article/details/109431324</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>低代码综测平台</title>
    <url>/2023/06/07/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%BB%BC%E6%B5%8B%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h1 id="低代码综测平台"><a href="#低代码综测平台" class="headerlink" title="低代码综测平台"></a>低代码综测平台</h1><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入:"></a>问题引入:</h1><p>每个大学都有综测，但是综测的组成成分各不相同，而对于很多学校来说，并没有以学校为单位的针对性的系统来管理每一个同学的综测.<br>同时，在大学生的课程领域也存在着类似的问题.一门课程的成绩往往由两个或者多个部分组成.但是基于同样的原因，同学们没有办法在漫长的课程进行过程中看到自己这门课动态的成绩变化，教师也无法方便有效的管理数据.<br>显而易见，可以使用低代码平台构建对应的解决方案，但是当前的低代码平台存在定义流程逻辑复杂，而且需要考虑部署，运维等等一系列问题，不太适合非计算机专业人士使用.本项目就是为了解决这些问题.</p>
<h1 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h1><h2 id="1-1-总体介绍："><a href="#1-1-总体介绍：" class="headerlink" title="1.1 总体介绍："></a>1.1 总体介绍：</h2><p>本项目是一个基于低代码技术的综测平台，用户可以通过简单的定制就可以生成基于自己学校综测结构的数据库表和crud代码。教师也可以通过简单的制定规则就可以为自己的课程建立成绩构成机制，并且能够简单便捷的对其进行管理。同学则可以通过微信小程序，方便及时的看到自己课程成绩与综测分数的及时变化。</p>
<h2 id="1-2-项目架构："><a href="#1-2-项目架构：" class="headerlink" title="1.2 项目架构："></a>1.2 项目架构：</h2><p>项目架构图如下：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230607151012228.png" alt="image-20230607151012228"></p>
<p>客户端包括前端和微信小程序,后端部分采用微服务架构,各个服务功能介绍如下：</p>
<h3 id="1-2-1-user-sever："><a href="#1-2-1-user-sever：" class="headerlink" title="1.2.1 user-sever："></a>1.2.1 user-sever：</h3><p>主要管理和维护用户，实现注册，登录，权限管理，网关拦截等功能。</p>
<p>用户的主要角色有：</p>
<p>内部管理员：系统的管理者，负责管理和维护整个系统。</p>
<p>高校负责人：负责创建本校的综测评分机制，以及将相关加分信息和学校课程录入系统。</p>
<p>教师：负责发布课程，管理课程相关信息，导入各行成绩。</p>
<p>学生：查看自己的各个课程的成绩和综测成绩。</p>
<h3 id="1-2-2-grade-sever："><a href="#1-2-2-grade-sever：" class="headerlink" title="1.2.2 grade-sever："></a>1.2.2 grade-sever：</h3><p>与web前端进行交互，通过接口获取定义综测成绩构成的相关信息，通过create table sever进行统一的数据库表和源代码的创建。</p>
<h3 id="1-2-3-grade-manage-sever："><a href="#1-2-3-grade-manage-sever：" class="headerlink" title="1.2.3 grade-manage-sever："></a>1.2.3 grade-manage-sever：</h3><p>与web前端进行交互，主要维护grade-sever创建的特定的数据库，主要实现面向管理员的数据导入，修改，删除和吗，面向学生的数据查询功能。</p>
<h3 id="1-2-4-class-sever"><a href="#1-2-4-class-sever" class="headerlink" title="1.2.4 class-sever:"></a>1.2.4 class-sever:</h3><p>与web前端进行交互，主要负责课程的创建，课程与学校之间的绑定，课程加分结构的确立以及对应数据库表的生成。</p>
<h3 id="1-2-5-class-manage-sever："><a href="#1-2-5-class-manage-sever：" class="headerlink" title="1.2.5 class-manage-sever："></a>1.2.5 class-manage-sever：</h3><p>处理来自teacher和students的相关信息，实现对class表的相关crud操作。</p>
<h3 id="1-2-6-teacher-sever"><a href="#1-2-6-teacher-sever" class="headerlink" title="1.2.6 teacher-sever:"></a>1.2.6 teacher-sever:</h3><p>程序的教师端微信小程序入口，主要负责教师在移动端进行成绩查询，成绩导入，修改和删除操作。</p>
<h3 id="1-2-7-student-sever："><a href="#1-2-7-student-sever：" class="headerlink" title="1.2.7 student-sever："></a>1.2.7 student-sever：</h3><p>程序的学生端微信小程序入口，主要负责学生查询自己的综测成绩，课程成绩，课程的具体得分构成等。</p>
<p>http框架采用springboot，springcloud，hertz，rpc框架采用kitex，代码生成为springboot后端代码，使用java parser库。</p>
<h2 id="1-3-功能介绍："><a href="#1-3-功能介绍：" class="headerlink" title="1.3 功能介绍："></a>1.3 功能介绍：</h2><h3 id="1-3-1-web网页："><a href="#1-3-1-web网页：" class="headerlink" title="1.3.1 web网页："></a>1.3.1 web网页：</h3><p>主要使用者为管理员和教师进行操作.</p>
<p>管理员负责指定学校的综测分数组成结构，并导入各种项目加分的文件。</p>
<p>教师则使用网页进行课程的创建和学生的导入（学生也可自行注册）</p>
<h3 id="1-3-2-微信小程序："><a href="#1-3-2-微信小程序：" class="headerlink" title="1.3.2 微信小程序："></a>1.3.2 微信小程序：</h3><p>主要使用者为教师和学生。</p>
<p>教师使用小程序添加，修改和删除课程中学生的相关列的成绩。</p>
<p>学生则使用微信小程序查看自己的成绩和综测得分。</p>
<p>Elasticsearch</p>
<p>redis </p>
<p>robbitmq</p>
<p>springsecurity oauth2</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>乱世佳人</title>
    <url>/2023/02/10/%E4%B9%B1%E4%B8%96%E4%BD%B3%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="乱世佳人：乱世中的飘渺与爱"><a href="#乱世佳人：乱世中的飘渺与爱" class="headerlink" title="乱世佳人：乱世中的飘渺与爱"></a><strong>乱世佳人：乱世中的飘渺与爱</strong></h1><h2 id="1-电影简介"><a href="#1-电影简介" class="headerlink" title="1.电影简介:"></a>1.电影简介:</h2><p>《乱世佳人》（英文名：gone with the wind）是一部由是由维克多·弗莱明执导，费雯·丽、克拉克·盖</p>
<p>博等人所主演的电影，改编自美国作家玛格丽特·米切尔所创作的长篇小说《飘》，于1939年在美国上</p>
<p>映。曾获第十二届奥斯卡金像奖最佳影片。</p>
<h2 id="2-内容介绍"><a href="#2-内容介绍" class="headerlink" title="2.内容介绍:"></a>2.内容介绍:</h2><h3 id="1-情窦初开"><a href="#1-情窦初开" class="headerlink" title="1.情窦初开:"></a>1.情窦初开:</h3><p>“这里曾经是骑士和棉花的土地，称为老南方……在这个美丽的世界里，骑士之风已成为过去。如今只是</p>
<p>梦的追忆……庄园与庄园主……一代文明，随风飘逝……“</p>
<p>伴随着苍凉悲怆的画外音，故事发生在1861年的春天，美国正值南北战争爆发前夕，南方泰拉庄园的千</p>
<p>金小姐斯卡莉美丽动人，气质出众，受全郡青年追捧献媚。但她却对十二橡树庄园的艾希利一见钟情，</p>
<p>但是在艾希莉举行的烤肉宴会上，他却拒绝了斯卡莉热情任性的告白和追问，选择了她的表妹，同样美</p>
<p>丽却善良温婉的梅兰尼共度一生。而斯卡莉与艾希利的深情对白一幕正好被因对南北战争的悲观言论而</p>
<p>躲藏起来的巴特勒船长无心之间撞见，二人因此相识，巴特勒也对斯卡莉一见钟情。意外的是，在宴会</p>
<p>进行中，南北战争突如其来的开始，在祥和宁静突然转向兵荒马乱之时，还是少女的斯卡莉却因艾希利</p>
<p>的拒绝内心慌乱而愤恨，便半无知半赌气地答应了仰慕她已久梅兰尼的弟弟查尔斯的求婚。盛大而纷乱</p>
<p>的婚礼过后，艾希利与查尔斯一同赶往前线战场。</p>
<h3 id="2-跌撞涉世"><a href="#2-跌撞涉世" class="headerlink" title="2.跌撞涉世:"></a>2.跌撞涉世:</h3><p>一纸信笺，打破了两个庄园的短暂平静。查尔斯熬过了轰隆的炮火，却被疟疾夺取了年轻鲜活的生命。</p>
<p>年仅十六岁的斯卡莉被迫披上黑纱，把自己的大好青春封存于寂寞的闺房中，但天性热烈奔放的她不甘</p>
<p>于沉寂，也没有时间与理由悲伤，因为她对查尔斯不存在所谓真诚的爱。在她母亲的提议下，她离开家</p>
<p>乡前往表妹所在的亚特兰大城，并很快又以一袭黑袍出现在了为战争而举行的义卖舞会上，而早已对她</p>
<p>动心的巴特勒不顾他人的非议，花高价请她跳舞，满足了她跳舞的愿望和虚荣心，也第一次向她表明心</p>
<p>迹。但此时的斯卡莉仍牵挂着艾希利，对巴特勒的追求不以为意。</p>
<p>战事推进，正如巴特勒所预言的那样，傲慢的南方军节节败退。而亚特兰大城也挤满了伤兵，每天广场</p>
<p>都在上演着往昔的贵族家庭主人因为自己子女的死亡而悲伤哭泣的戏码。而斯卡莉与梅兰妮一起，成为</p>
<p>了照顾伤病的护士，梅兰妮工作尽心尽力，善良体贴，并且温柔天真的希望远方的情人也能有陌生人照</p>
<p>料其生活，倾听其耳语。而从小养尊处优的生活与明媚热烈的天性使斯卡莉很快就厌倦了每日目睹脏</p>
<p>乱、伤痛、哀嚎、死亡的生活。然而就在她想要放弃和逃避的时候，前线传来消息，北军即将打到亚特</p>
<p>兰大，一时之间法律和秩序当然无存，贵族老爷们争相逃亡，陌生人暴露了暴徒的面具。斯卡莉也想迫</p>
<p>不及待地回到她的泰拉庄园，但是梅兰妮怀上的艾希利的孩子，正要生产，她被迫留在此地。兵荒马乱</p>
<p>时分，医生都在忙于救治病人，连一个可以接生的人都找不到，万般无奈之下，处于对艾希利好好照顾</p>
<p>梅兰妮的承诺，斯卡莉第一次由内心的勇敢战胜任性主动承担责任。最终孩子顺利降生，但是在北方的</p>
<p>大军压境与重重保卫面前，无助的女人和孩子又将何去何从？</p>
<h4 id="3-月夜奔赴"><a href="#3-月夜奔赴" class="headerlink" title="3.月夜奔赴:"></a>3.月夜奔赴:</h4><p>走投无路之时，先前与巴特勒的相遇，给了斯卡莉一线希望。她派侍女去寻求他的帮助，而自己照顾梅</p>
<p>兰妮和收拾行李，此时的她已经不是青葱岁月的无知少女，炮火和硝烟的洗礼迫使她快速的变得成熟而</p>
<p>现实，甚至临行之前执意带上母牛，因为不知道回到家乡后还能找到什么。而巴特勒没有让她失望，用</p>
<p>钞能力搞来了一辆马车，并以高超的驾驶技术越过了燃烧的炮火和武装的暴徒，成功的把她们带出了</p>
<p>城。可就在回去的路上，巴特勒却执意抛下她们去参军，去尽他作为南方人的责任，并与斯卡莉深情的</p>
<p>拥吻告别，斯卡莉无力改变，只好再一次挺身而出，带着她们在被火光照亮的月夜中向着故乡的方向奔赴。当她的华贵衣衫被泪水和风尘沾染，当她的无暇面容被暴雨和狂风褶皱，当她的姣好身形被饥饿和</p>
<p>忧伤消瘦，当她的海蓝色眼眸灰暗，握紧缰绳的手指苍白，身前的枯木与浮尸交叠，甚至一路陪伴的马</p>
<p>儿也不堪重负走向死亡，月夜下，却仍然有执着前行的身影，伴随着惊喜的呼号，日夜奔赴的故乡，近</p>
<p>在眼前。</p>
<h4 id="4-弘毅持家"><a href="#4-弘毅持家" class="headerlink" title="4.弘毅持家:"></a>4.弘毅持家:</h4><p>斯卡莉越过被烧毁的十二橡树庄园，推开泰拉庄园的大门，看到被北军[洗劫一空的庄园，被战争和苍老</p>
<p>折磨至疯的父亲，因求助病人而自身染病故去的母亲，再一次因美梦破碎而失声痛哭。但现在的她已经</p>
<p>不是当年那个任性热情的少女，她明白流泪之后家庭和庄园的责任必须她来承担。在父亲为庄园跃马踏</p>
<p>围栏可笑而又壮烈的死去后，耳畔再一次回荡着父亲当年的话”土地是世上唯一值得你，为它奉献，为它</p>
<p>奋斗，为它牺牲的事物，因为他是唯一永存的东西，只要是爱尔兰人就无一例外。”</p>
<p>魂牵梦萦的土地上，新的生活开始了。斯卡莉使每个人都放下了贵族身段，像以往的黑奴那样辛苦的劳</p>
<p>作以赚取生存的食物，但是对于心上人的妻子梅兰妮却依旧网开一面，不让她参与任何农事活动，甚至</p>
<p>在打死闯入家中的异乡人，急于处理尸体来瞒过众人这种十万火急的事情上也依然不让梅兰妮动手而是</p>
<p>自己解决。这是斯卡莉第一次杀人，这次杀人是她真正成熟的标志，为了自己，为了家人，为了泰拉的</p>
<p>土地，她勇敢的直面生活，承担责任，不顾个人声望与身段，甚至安危生死。“上帝为我作证，我将不再</p>
<p>饥饿。”这段泰拉艰难的时光，是斯卡莉一生中的的高光岁月，丰富而全面的展露了她作为女性独有的坚</p>
<p>强与执着，古人云“士不可以不弘毅，任重而道远”，在这被北方豪强包围的南方市镇中，斯卡莉以弘毅</p>
<p>的精神持家，维持着祖上的土地与今人的生活，试图恢复以往繁华丰富的时光，任重道远的漫漫长路，</p>
<p>她把自己热情的内心与渺远的爱情封印，艰难跋涉不再回头。</p>
<h4 id="5-重回繁华"><a href="#5-重回繁华" class="headerlink" title="5.重回繁华:"></a>5.重回繁华:</h4><p>艾希利回来了，穿着梅兰妮为它缝制的、如今已经残破不堪的衣衫，带着理想主义者失败后特有的灰暗</p>
<p>的面容，一步一步踱着进入了这个生活刚刚步入正规的泰拉庄园。艾希利的到来重新点燃了斯卡莉对爱</p>
<p>情和过往生活的喜爱和热情，也是她对现在日夜操劳的生活愈加地厌倦，终于，她再一次和艾希利拥抱</p>
<p>亲吻并表明心迹。提出要和他私奔到墨西哥，去追寻更好的生活，但艾希利在亲吻过后再一次以仅存的</p>
<p>良知和南方贵族特有的君子之风拒绝了她，她只好再一次转身直面绝望的生活。</p>
<p>北方佬严苛的征税是她不得不寻找帮助，这时她再一次想到了巴特勒船长，然而巴特勒船长参军之后却</p>
<p>被俘虏，被关在监狱不能给她金钱上的帮助，正在回家的路上，心灰意冷的她遇上了她妹妹修伦的未婚</p>
<p>夫弗兰克，原本一贫如洗的弗兰克因为经营木材生意而成了爆发户，经营着一家商店和木材厂，斯卡莉</p>
<p>在弗兰克身上看到了金钱和交税的可能，于是她欺骗弗兰克说修伦已经不再爱他，并用自己美貌的外表</p>
<p>与动人的情话成功打动了弗兰克，成为了他的妻子，也成功接管了木材厂的生意。生活日渐富裕的同</p>
<p>时，她对金钱的执念也愈加深重，儿时养成的自私性格也愈演愈烈，她开始为了赚钱而不择手段，与摧</p>
<p>毁她庄园、杀害她丈夫的北方佬大做生意，甚至非法雇佣、压榨囚犯来经营木材厂。</p>
<p>在一次前往木材厂的路上，她又一次遇上了巴特勒，他已经通过贿赂被释放，重新变成了腰缠万贯的绅</p>
<p>士。巴特勒再一次感叹于她独自以身犯险穿过贫民窟的勇气，她却因为巴特勒没有伸出援手恶语相向。</p>
<p>果不其然，在贫民窟她受到了袭击，但是有惊无险的逃过了，可是她的新丈夫弗兰克却与艾希利带着其</p>
<p>他反政府成员袭击了黑人的贫民窟，并在战斗中不幸中弹死去，艾希利也受了伤，当巴特勒冒险就会受</p>
<p>伤的艾希利时，斯卡莉却一心关注着艾希利的伤情而对自己的丈夫不闻不问，直到巴特勒说出这个噩</p>
<p>耗。</p>
<h4 id="6-终成眷属"><a href="#6-终成眷属" class="headerlink" title="6.终成眷属:"></a>6.终成眷属:</h4><p>时过境迁，巴特勒对第二次成为寡妇的斯卡莉依旧执着，而这一次几乎放弃对艾希利爱情的斯卡莉没有</p>
<p>在拒绝一直苦苦追求她的巴特勒。结婚一年以后，斯卡莉和巴特勒有了第一个孩子邦妮，而他们也利用</p>
<p>这段时间和巴特勒多年以来从事粮食和军火走私生意所得的巨额财富把泰拉庄园重新打造的金碧辉煌，</p>
<p>重现了斯卡莉儿时的梦中时光，斯卡莉再一次过上了养尊处优的上流生活，甚至比以前仍有过有之。但</p>
<p>是斯卡莉在婚姻短暂的甜蜜蜜月后，仍然对艾希利念念不忘，婚后仍一次一次的地前去艾希利所在的木</p>
<p>材厂，总是那些钱财对她已不重要。在一个下午，她又一次挑逗艾希利时，艾希利终于忍不住拥抱了她</p>
<p>并祝她快乐幸福。然而巧合且不幸的是，这一幕正好被进来的其他人看到，很快所有人包括梅兰妮也知道了这件事情，更要命的是斯卡莉不得不去参加艾希利的生日会，在她最尴尬的时候，梅兰妮却选择了</p>
<p>相信她和艾希利之间是清白的，并主动为她解围，事情才得以解决。</p>
<p>但是经过这件事情，再加上先前偶然发现发现斯卡莉偷偷翻阅艾希利的照片，巴特勒对斯卡莉彻底心灰</p>
<p>意冷，然而他却从邦妮身上看到了当年斯卡莉没有被现实和金钱玷污的模样，于是把全部心思都放在培</p>
<p>养和教育他们的女儿上，先是带她去外国旅行，后因为女儿对母亲的思念不得不回国，又教女儿骑马等</p>
<p>运动，什么事都顺着她，完全以新式教育的观点培养宝贝女儿，这点也与从小接受老式南方贵族教育的</p>
<p>斯卡莉渐行渐远。经年终成眷属的两人，逐渐渐行渐远，形同陌路。</p>
<h4 id="7-不说再见"><a href="#7-不说再见" class="headerlink" title="7.不说再见:"></a>7.不说再见:</h4><p>泰拉庄园的一个清晨，骑在小马上英姿飒爽的小邦妮伴着清晨的阳光来到争吵的父母亲面前，要给他们</p>
<p>表演跨越栅栏，斯卡莉见状不禁想起当年换上痴呆的父亲翻阅栅栏跌下马而死的惨状，慌忙让巴特勒去</p>
<p>拦下她，巴特勒大声呼喊她停下，然而为时已晚。父亲和女儿，奇异而悲惨的经历了同样的命运，令人</p>
<p>感到可笑而又不禁潸然泪下。</p>
<p>邦妮死后，巴特勒追悔莫及，万念俱灰，他不能接受宝贝女儿突然去世的结局，甚至固执地认为女儿没</p>
<p>有死而不肯为她下葬，为了葬礼的顺利举行，同样悲伤的斯卡莉只好请佣人去找梅兰妮帮忙，已有身孕</p>
<p>的梅兰妮听到之后立即赶来安慰巴特勒，在刚刚说服巴特勒同意为小邦妮下葬之时，梅兰妮却突然晕</p>
<p>倒，原本没有生育能力的她，为了这一传递生命的神圣事业，已经倾尽所有。</p>
<p>孩子安全出生，而梅兰妮却已经奄奄一息，在弥留之际，她执意要见斯卡莉，并对说出了自己最后的遗</p>
<p>言：替我照顾好艾希利，好好爱巴特勒，他真的很爱你。温柔一生的梅兰妮故去了，只留下斯卡莉独自</p>
<p>面对失去生活最后希望的艾希利和要毅然决然离开她，去他乡追求爱与美的巴特勒，短时间内连续经历</p>
<p>生离与死别打击的斯卡莉，孤身一人的斯卡莉，面对未来的生活仍旧没有失去希望，而是哭泣着，继续</p>
<p>聚集起对世界和生活的热情，再一次出发。</p>
<p>故事的最后，斯卡莉独自一人站在儿时与父亲并肩而立的苍天大树下，微风缓缓，古木的枯枝已经萌发</p>
<p>新芽，举目远眺，远处的泰拉庄园笼罩在一片朦胧的烟火中，天边火红色的云彩飘摇，夕阳正好。</p>
<h2 id="3-艺术成就"><a href="#3-艺术成就" class="headerlink" title="3.艺术成就:"></a>3.艺术成就:</h2><h3 id="1-画面"><a href="#1-画面" class="headerlink" title="1.画面:"></a>1.画面:</h3><p>影片大多数情节展现在油画般的布景当中，画面本身所带来的朦胧气氛，配合上费雯丽梦幻、沉浸、甚</p>
<p>至可以说是有些做作的表演，让人感觉仿佛置身南方庄园的美丽童话当中，美丽的画面甚至任意截取出</p>
<p>一个瞬间都可以被当作经典，而部分紧促残酷的场景则转向写实画风，如斯卡莉逃亡过程中目睹的悲惨</p>
<p>景象、她枪杀强盗瞬间鲜血四溅的场景，通过这种画风的改变较好的衬托了影片节奏和情绪的变化，也</p>
<p>表现了对战争的厌恶以及悲天悯人的人性温暖。而影片为数不多的长镜头更是聚焦拥抱、深思等场面，</p>
<p>直面人物内心，仿佛在通过镜头的退役来展现人物丰富的心理活动和说不出的万语千言，极其富有艺术</p>
<p>感染力。</p>
<h4 id="2-布局"><a href="#2-布局" class="headerlink" title="2.布局:"></a>2.布局:</h4><p>影片的布局十分巧妙，采用双线结构，主线是斯卡莉与艾希利、巴特勒与其他丈夫的感情纠葛，暗线则</p>
<p>是美国南北战争前后的社会发展与人心变化。以成长式的剧情体现了时间地点跨度下一个人的转变。叙</p>
<p>事上冷静与热情相结合，张弛有度，配合斯卡莉的主要视角与必要时推动剧情的其他视角，使观众能够</p>
<p>在全面的感受剧情的同时沉浸式的体验女主角的情感与追求变化。</p>
<p>影片在艺术上还有诸多成就与亮点，如亮丽的色彩使用，大气磅礴的气势，豪华奢靡的场景，逼真的战</p>
<p>争场面等等，此处受制于篇幅不再一一赘述。</p>
<h2 id="4-人物形象"><a href="#4-人物形象" class="headerlink" title="4.人物形象:"></a>4.人物形象:</h2><h4 id="1-斯卡莉"><a href="#1-斯卡莉" class="headerlink" title="1.斯卡莉:"></a>1.斯卡莉:</h4><p>斯卡莉是影片的主角，南方种植园主的千金，她有着美丽的身形与无暇的笑容，对生命和生活怀有着无</p>
<p>比的热情，无论经历多大的苦难都能勇敢的面对生活，同时，她又虚荣而自私，现实而贪婪，痴情而残</p>
<p>忍，形象饱满而极具多维层次感，她的笑容让人沉醉，她的热情让人动容，她的残忍让人心寒，一场似</p>
<p>乎酝酿已久的战争出现在她的生命中，这场战争使她感受到了前所未有的痛苦，爱情的消亡，亲情的逝</p>
<p>去，让她在苦难中得到成长，明白了爱的意味，从自私到无私的转变，从而唤醒了当代女性意识觉醒，</p>
<p>思想自由解放，这与18、19世纪哲学思想家如康德等人所倡导的”天赋人权”、自由平等等思想不谋而</p>
<p>合。</p>
<h4 id="2-巴特勒"><a href="#2-巴特勒" class="headerlink" title="2.巴特勒:"></a>2.巴特勒:</h4><p>巴特勒影片的男主角。他是典型的英伦绅士形象，智慧，勇敢，敏锐，正义，无论对谁都是笑容和煦、</p>
<p>彬彬有礼，举止翩翩，同时家财万贯，是万千少女的梦中情人形象，为此还产生了瑞德巴特勒情结，但</p>
<p>他同时又有属于自己的自私与骄傲，他的自私要求他做任何事都要有最终的回报，他的骄傲不允许他在</p>
<p>国家危难之时带着女人逃避，这是这种性格成就了他，却也因此让他始终得不到斯卡莉最真挚的爱。</p>
<h4 id="3-艾希利"><a href="#3-艾希利" class="headerlink" title="3.艾希利:"></a>3.艾希利:</h4><p>艾希利是典型的理想主义者形象，他也是一位绅士，南北战争前对战争充满信心，战斗时勇敢作战，战</p>
<p>后仍积极参加反政府组织，在事业上他的一生奋斗具有古希腊式的悲剧色彩，令人唏嘘感叹。而在感情</p>
<p>上他又是懦弱的、模棱两可的、没有担当的，他始终出于贵族的操守于内心的底线没有答应斯卡莉的表</p>
<p>白，但是又经常克制不住内心的冲动与斯卡莉拥吻，说着绵绵情话。在生活中他又是脆弱的，会被挫折</p>
<p>打倒，会变得一蹶不振，找不到生活的方向。与巴特勒相比，他有缺点，却更加真实，或许这也是斯卡</p>
<p>莉自始至终钟情于他的原因。</p>
<h4 id="4-梅兰妮"><a href="#4-梅兰妮" class="headerlink" title="4.梅兰妮:"></a>4.梅兰妮:</h4><p>梅兰妮是古典温柔女性的代表，巴特勒称她为”十分伟大、完美的女人“，与热烈奔放的斯卡莉相比，她</p>
<p>性格沉静温婉，待人平和宽容，永远选择相信别人，始终看到别人好的一面。纵使在所有人都质疑艾希</p>
<p>利和斯卡莉时，她仍然选择相信斯卡莉，并在故去之时把艾希利托付给斯卡莉。在温柔的同时，梅兰妮</p>
<p>又有勇敢的一面，她在明知生育会面临极大危险的情况下，依旧毅然决然选择这神圣的使命，最终坦然</p>
<p>地面对死亡。她和巴特勒一样，都用有着近乎完美的人设，是无数男人心目中的温暖情人形象。</p>
<h2 id="5-影片主题"><a href="#5-影片主题" class="headerlink" title="5.影片主题:"></a>5.影片主题:</h2><h3 id="1-乱世爱情与婚姻：坚守、背叛、遗忘"><a href="#1-乱世爱情与婚姻：坚守、背叛、遗忘" class="headerlink" title="1.乱世爱情与婚姻：坚守、背叛、遗忘"></a>1.乱世爱情与婚姻：坚守、背叛、遗忘</h3><p>爱情贯穿《乱世佳人》的始终，是重要的影片线索和主题之一。斯卡莉始终对艾希利有着热烈明媚的，</p>
<p>爱，为了这份爱情她牺牲了自己的第一任丈夫，把他当作自己感情的玩物，她的第二次婚姻是出于生存</p>
<p>所需，只是把婚姻当作生存的工具，而她对巴特勒怀有的则是一种介于信任和喜爱之间的感情，不能说</p>
<p>她完全不爱巴特勒，但未必对着堪称完美的男人有多迷恋。斯卡莉的三次婚姻都已悲剧收场，她的爱情</p>
<p>更是始终没有收到真挚的回应，斯卡莉的爱情与婚姻是失败的，这种失败有她自己的原因，有艾希利的</p>
<p>原因，也有时代的原因，但她对爱情的坚持与追求却没有失败，是感人至深并且应收到尊敬的。</p>
<p>艾希利虽然没有明确的出轨，但他确实对斯卡莉和梅兰妮都怀有十分的喜爱，从这种意义上说，他确实</p>
<p>背叛了自己的感情，背叛了自己专一忠贞的誓言，确实，很难有人能拒绝斯卡莉动人的外表与如一热烈</p>
<p>的示爱，艾希利爱情与婚姻的问题，其实是男人在选择和追求时普遍的问题，在追求爱情时希望爱的炽</p>
<p>热如骄阳，正如斯卡莉的爱，然而面对平淡生活与事业的失意时，又渴望温柔如水的安慰和陪伴，正如</p>
<p>梅兰妮的爱。有人说乱世佳人教会我们如何去爱，倒不如说教会我们如何在爱情和婚姻之间取舍，最终做到像巴特勒</p>
<p>像那样冷静的追求爱情。巴特勒对斯卡莉一见钟情，然后想尽各种办法追求她，但是后来发现自己不再</p>
<p>喜欢她的时候又把自己的爱全部给了自己的孩子小邦妮，又在小邦妮死后冷静而又不失了风度的告别斯</p>
<p>卡莉，去追求新的美好爱情。始终把爱情与婚姻紧紧握在一起，斯卡莉的爱太浓列梦幻，艾希利的爱太</p>
<p>犹豫怯懦，或许只有巴特勒的爱情和对爱情的态度才是我们所追求和推崇的。</p>
<h3 id="2-Gone-with-the-wind：西风吹彻的土地"><a href="#2-Gone-with-the-wind：西风吹彻的土地" class="headerlink" title="2. Gone with the wind：西风吹彻的土地"></a>2. Gone with the wind：西风吹彻的土地</h3><p>乱世佳人英文名是gone with the wind，随风而逝，在小说原文中作者曾经解释说意思是斯卡莉的故乡</p>
<p>泰拉庄园已经随风飘去，乱世之中，佳人摧折，命途多舛，飘零四海，乱世之中，佳人奋发，爱的炽烈</p>
<p>明媚，生活的独立自由，乱世之中始终怀有对土地与生活的坚守与热爱。”没有比你更深重的苦难，没有</p>
<p>比你更自由的意志“，观毕乱世佳人，置身盛世，或许我们应当学会如何去生存，如何去尽力生活，如何</p>
<p>去爱，爱土地与土地上的人，爱希望与未来，爱人性中每一丝丝明亮的闪光。</p>
<p>最后以影片的结尾作结:</p>
<p>Home,I want to go home,I have to think of a way to get him back,no matter what,tomorrow is a</p>
<p>new day.</p>
<p>抒情熊</p>
<p>2022.3.18</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>影评</tag>
      </tags>
  </entry>
  <entry>
    <title>北邙星梦</title>
    <url>/2023/05/29/%E5%8C%97%E9%82%99%E6%98%9F%E6%A2%A6/</url>
    <content><![CDATA[<p>若你来自北方<br>若你的肩头从未抖落风霜<br>若你的目光里从未有过烟雨江南<br>当你把目光投向熙攘 直视生活<br>当你听到不属于北方的夜夜笙歌<br>相信你眼中会残存北方的月影<br>那未曾体味过繁华的温柔的月影<br>可你的梦里是否有过对江南的憧憬<br>以春暖花开为背景 把心爱的元素用素笔勾勒<br>把画面定格 用一如永远的话语抹上底色<br>希望你能有憧憬的目光<br>无论它来自你的故乡<br>还是来自繁华却少许空洞的江南<br>希望你能找到和你一样的人<br>从北方走来却不心怀江南的人<br>用所有不平凡的品质情感让目光相会<br>哪怕不思考前提 哪怕会轻易提起<br>希望你能带着两束目光走向最后<br>放下来自漫漫黄沙里的理性<br>做出作出决定就不会改变<br>做不到眼中同时装着江南和故乡<br>就做个函数吧<br>同时握着理性和情感<br>做出决定就不改变<br>不回头不眺望也无所谓悲伤</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式原理</title>
    <url>/2023/01/17/%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="分布式理论-现代架构基石"><a href="#分布式理论-现代架构基石" class="headerlink" title="分布式理论-现代架构基石"></a>分布式理论-现代架构基石</h1><h1 id="1-目录："><a href="#1-目录：" class="headerlink" title="1.目录："></a>1.目录：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202220429.png" alt="QQ截图20230202220429"></p>
<h1 id="2-分布式概述："><a href="#2-分布式概述：" class="headerlink" title="2.分布式概述："></a>2.分布式概述：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202220755.png" alt="QQ截图20230202220755"></p>
<p>在多台服务器上运行同一个系统的的能力。</p>
<h2 id="2-1-why-how-what："><a href="#2-1-why-how-what：" class="headerlink" title="2.1 why-how-what："></a>2.1 why-how-what：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202221236.png" alt="QQ截图20230202221236"></p>
<h2 id="2-2-常见的分布式系统："><a href="#2-2-常见的分布式系统：" class="headerlink" title="2.2 常见的分布式系统："></a>2.2 常见的分布式系统：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202221435.png" alt="QQ截图20230202221435"></p>
<h1 id="3-系统概述："><a href="#3-系统概述：" class="headerlink" title="3.系统概述："></a>3.系统概述：</h1><h2 id="3-1-故障模型："><a href="#3-1-故障模型：" class="headerlink" title="3.1 故障模型："></a>3.1 故障模型：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202221554.png" alt="QQ截图20230202221554"></p>
<p>按照处理的难易程度划分，最难处理的是拜占庭故障。</p>
<p>从四个角度去衡量故障：时间，正确性，状态，原因。</p>
<p>crash 只知道状态，而不知道原因。</p>
<p>fail-stop 既知道状态，也知道原因。</p>
<p>per，omiss不知道状态。</p>
<p>拜占庭是正确性问题。大部分分布式系统一般不解决此问题，因为太难解决了。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202222218.png" alt="QQ截图20230202222218"></p>
<h2 id="3-2-拜占庭将军问题："><a href="#3-2-拜占庭将军问题：" class="headerlink" title="3.2 拜占庭将军问题："></a>3.2 拜占庭将军问题：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202222423.png" alt="QQ截图20230202222423"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202222818.png" alt="QQ截图20230202222818"></p>
<p>在这种场景下，需要进行两轮投票，第一轮由ABC 把自己的的结果发送给D，由d整合结果之后再发给ABC,然后ABC再次像没有D的时候的三将军一样进行投票。</p>
<p>第二轮投票的决策依赖于第一轮D的消息。因为d只能传输01两种消息，所以必然能保证符合大多数人的意愿（ABC之间消息传输正确）</p>
<h2 id="3-3-共识和一致性："><a href="#3-3-共识和一致性：" class="headerlink" title="3.3 共识和一致性："></a>3.3 共识和一致性：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202223930.png" alt="QQ截图20230202223930"></p>
<p>线性一致性又叫做强一致.</p>
<h2 id="3-4-时间和时间顺序："><a href="#3-4-时间和时间顺序：" class="headerlink" title="3.4 时间和时间顺序："></a>3.4 时间和时间顺序：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202224220.png" alt="QQ截图20230202224220"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202224425.png" alt="QQ截图20230202224425"></p>
<h1 id="4-理论基础："><a href="#4-理论基础：" class="headerlink" title="4.理论基础："></a>4.理论基础：</h1><h2 id="4-1-CAP理论："><a href="#4-1-CAP理论：" class="headerlink" title="4.1 CAP理论："></a>4.1 CAP理论：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202224736.png" alt="QQ截图20230202224736"></p>
<p>完全的CAP无法达到。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202224928.png" alt="QQ截图20230202224928"></p>
<h2 id="4-2-ACID理论："><a href="#4-2-ACID理论：" class="headerlink" title="4.2 ACID理论："></a>4.2 ACID理论：</h2><p><img src="C:\Users\wpy\Desktop\blog\source\images\分布式理论\QQ截图20230202225216.png" alt="QQ截图20230202225216"></p>
<p>数据库一定要保证的是A和C，I和D有些时候并不能保证。</p>
<h2 id="4-3-BASE理论："><a href="#4-3-BASE理论：" class="headerlink" title="4.3 BASE理论："></a>4.3 BASE理论：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202231153.png" alt="QQ截图20230202231153"></p>
<h1 id="5-分布式事务"><a href="#5-分布式事务" class="headerlink" title="5.分布式事务:"></a>5.分布式事务:</h1><h2 id="5-1-两阶段提交"><a href="#5-1-两阶段提交" class="headerlink" title="5.1 两阶段提交:"></a>5.1 两阶段提交:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203090403.png" alt="QQ截图20230203090403"></p>
<h3 id="5-1-1-可能的异常"><a href="#5-1-1-可能的异常" class="headerlink" title="5.1.1 可能的异常:"></a>5.1.1 可能的异常:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203090515.png" alt="QQ截图20230203090515"></p>
<p>在第二种情况中,查询状态通过participate.</p>
<h3 id="5-1-2-注意的问题"><a href="#5-1-2-注意的问题" class="headerlink" title="5.1.2 注意的问题:"></a>5.1.2 注意的问题:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203090730.png" alt="QQ截图20230203090730"></p>
<h2 id="5-2-三阶段提交"><a href="#5-2-三阶段提交" class="headerlink" title="5.2 三阶段提交:"></a>5.2 三阶段提交:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203091258.png" alt="QQ截图20230203091258"></p>
<p>解决了在commit的时候失败,导致prepare资源浪费的问题.</p>
<h2 id="5-3-悲观锁与乐观锁"><a href="#5-3-悲观锁与乐观锁" class="headerlink" title="5.3 悲观锁与乐观锁:"></a>5.3 悲观锁与乐观锁:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203091558.png" alt="QQ截图20230203091558"></p>
<h2 id="5-4-MVCC"><a href="#5-4-MVCC" class="headerlink" title="5.4 MVCC:"></a>5.4 MVCC:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203091743-1675387067867-7.png" alt="QQ截图20230203091743"></p>
<p>需要依赖硬件.</p>
<h1 id="6-共识协议"><a href="#6-共识协议" class="headerlink" title="6.共识协议:"></a>6.共识协议:</h1><h2 id="6-1-NWR模型"><a href="#6-1-NWR模型" class="headerlink" title="6.1: NWR模型:"></a>6.1: NWR模型:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203092131.png" alt="QQ截图20230203092131"></p>
<p>强一致:能够通过读数据,发现数据被改变.</p>
<h2 id="6-2-RAFT协议"><a href="#6-2-RAFT协议" class="headerlink" title="6.2 RAFT协议:"></a>6.2 RAFT协议:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203092513.png" alt="QQ截图20230203092513"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203092652.png" alt="QQ截图20230203092652"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203092935.png" alt="QQ截图20230203092935"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203093317.png" alt="QQ截图20230203093317"></p>
<h2 id="6-3-Paxos协议"><a href="#6-3-Paxos协议" class="headerlink" title="6.3 Paxos协议:"></a>6.3 Paxos协议:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203093735.png" alt="QQ截图20230203093735"></p>
<h1 id="7-分布式实践"><a href="#7-分布式实践" class="headerlink" title="7.分布式实践:"></a>7.分布式实践:</h1><h2 id="7-1-Map-Reduce"><a href="#7-1-Map-Reduce" class="headerlink" title="7.1 Map Reduce:"></a>7.1 Map Reduce:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203093903.png" alt="QQ截图20230203093903"></p>
<h2 id="7-2-分布式K-V"><a href="#7-2-分布式K-V" class="headerlink" title="7.2 分布式K-V:"></a>7.2 分布式K-V:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203094101.png" alt="QQ截图20230203094101"></p>
<p>Raft有很多的开源实现.</p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结:"></a>8.总结:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203094338.png" alt="QQ截图20230203094338"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230203094355.png" alt="QQ截图20230203094355"></p>
<p>主要是后三个.</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>天风白马</title>
    <url>/2023/05/29/%E5%A4%A9%E9%A3%8E%E7%99%BD%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="天风白马"><a href="#天风白马" class="headerlink" title="天风白马"></a>天风白马</h1><p>小镇巷陌上 人马奔忙<br>骑手无数次踱过街道 目之所至<br>窗棂与人影交叠 熙熙攘攘<br>兴之所往 忽而高扬马鞭 起势 耳畔回响<br>浩荡天风呼啸 仙乐奏鸣 </p>
<p>天风奏鸣中 看到最真实的自我<br>携着无尽的野望与卑微的愠怒 生活<br>博约观取 而放浪混浊<br>仰止高山 而畏惧退缩<br>灵犀心念 而轻言负诺<br>衷情遣词 而折心沐火<br>奏鸣中不断回望 惟有流光与千里明月<br>回响着散落的双手 与不再明亮的眼睛<br>奏鸣中漫阅前程 焚书折剑 尘土茫茫<br>飞扬的少年意气与惨淡的粲然日夜<br>奔涌 沸腾 厉啸<br>希冀着 超脱于激昂天风</p>
<p>天风奏鸣中 看到喜悦的人间<br>经行过无尽的亲吻 拥抱 爱恋 娇颜<br>却被只影拒绝<br>终以酒肉致幻 以低眉言笑 以傲慢分崩<br>彩云灯火 风光霁月<br>却只愿守着那金子般的岁月 不断蚕食<br>希冀着 沉醉于悠然天风</p>
<p>终夜开眼 以白马为瞻<br>一遍遍幻想着银鞍 星川 纵横捭阖<br>喟叹着义从 奋发于钢铁烈火<br>把盛世美颜融与寸缕肌肤 与每一寸骨血<br>灼血 挥枪 天地入怀而如归<br>梦境里反复呓语着<br>烽火入冬 三月江南 繁花如画</p>
<p>或许短暂的一生<br>就是追逐自我白马的旅程<br>歧路狭隘 但或有天风奏鸣<br>生活破碎而纷繁 游人如织而迫近青冥暮色<br>但见天色已晚 曜日将出<br>自我之相 勇当逐马</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>侠藏</title>
    <url>/2023/05/29/%E4%BE%A0%E8%97%8F/</url>
    <content><![CDATA[<p>侠藏<br>（一）<br>天启六年，辽东。<br>北风一阵阵呼啸而过，却吹不出几家灯火。<br>自从后金起兵，似乎浓墨重彩的黑夜更使人留恋起来，只因为黑夜里没有战争,没有死亡，只有好梦和安眠。但此刻，天边已有一抹纯白，未升的阳光和未落的月色一同， 映在这关外唯一的城里。<br>城外，是精锐的后金骑兵。<br>这支以努尔哈赤的仇恨为源火建立的军队，在这荒凉的大漠还未尝一败，更可怕的是，每次他们攻城成功，都会残忍的屠城，把生机和希望一同断绝。<br>而此刻的宁远城，似乎就是他们眼中的下一片废墟。<br>城中仅有一万余守军，且大多是新军和老兵。没有支援，大明的官员们都畏惧后金的凶狠残暴，畏缩在山海关后不敢发兵。而远隔千里之外的京师，甚至都不知道这场战争的发生。<br>他站在城楼上北望，寒风凛冽。<br>天光还未大亮，如今的后金在绝对的实力面前，连都偷袭都不屑起来。<br>“也许今天就要死在这里了吧？”他想，“不过也好，我就是为这一天而活着的。”<br>他不由得开始回忆起从前，无数画面和音律从眼前划过，最后拼凑、融合，凝结成两个并不十分清晰的身影。<br>“我终究要成为一名大侠的。”<br>“好啊，那我定会跟在你身后，与你一同走遍万水千山。”<br>（二）<br>总有那么一个人，你希望永远拉着他的手，走过所有人间苍茫，在年年岁岁里幕影成双，但现实总是不尽如人意，你与他渐走渐散，再无相逢。<br>从初见他的那一刻起，凌就决定守护他一生。<br>那年他十四岁，不同官场世家的顽劣性格，他只喜欢安静沉默地看书写字。凌初至他家的那一天，他正为读一本古书而发愁，凌就站在他的身后，听管家对他说，“以后这就是你的主子了。”闻言，他抬起头，正对上凌的目光。<br>凌至今记得那个眼神，纯净清冽，没有太多世俗的东西，可只是简单的相望就有令人心疼的感觉。仿佛来自异域的弃子，因无人知会而沉默不言。<br>后来的他们形影不离，渐渐超越了主仆之间的关系。<br>凌还记得第一次听他讲故事的那一天。是他的故事让凌第一次知道了世界上还有这样一方净土，那里没有暴力、流浪、战乱，故事里有的，是渺远绮丽的山川江海，是催人泪下的恩怨情仇，是以家国为重的英雄侠客，而这种侠客精神，也正是他们所最爱的。<br>古往今来，侠客们大多一袭青衫薄衣，银鞍白马，仗剑游行于天地之间，且富济贫，敢爱敢恨，放浪形骸，无所畏惧。对于从儿时起，就因贫穷而颠沛流离的凌来说，这种生活就意味着可以自己做出选择，可以自由自在，无所顾忌。但对于出身于书香门第的他，本应立志考取功名，高居庙堂之上，可他却想成为侠客。<br>直到他们分开，他也从未对凌说起过侠对于他的意义。<br>“如今的你，做到你想要的全部了么？”凌这样想着，大声喝道，“我们现在何处？”<br>“距离宁远城还有不足五里，天亮之间应该能赶到城中。”<br>“好！大家再快点！争取在后金发起进攻之前赶到城中！”<br>凌收回思绪。环视四周，浩荡千里的尽是八旗军队的旗帜，却看不到明军的身影。“我们可能是最后的支援了吧？却来自一支毫无编制的民兵，真可笑啊。”凌苦笑，抽出了长刀。他的身后，无数道身影借着微光纵马飞奔。<br>他们本是辽东人，但因为后金的攻城掠地而失去了亲人和家乡。愤怒使他们自发的聚集，但因为主力明军的懦弱，他们已经许久没有用武之地。<br>听说此次的新任宁前道不再退缩而决定一战，他们才从辽东的四面八方赶来此地，为家乡奉献最后一点力量。<br>最终，他们中的很多人最终如愿以偿，与自己的土地共存亡，但那些活下来的人也变得无比强大，因为他们无可失去。<br>谁也未曾想到他们最终变成了后金军队在最擅长的骑术上的梦魇，被冠以响亮的封号，名震四海。<br>关宁铁骑。<br>（三）<br>元宵节。<br>书中说南宋的元宵是最热闹的，平民百姓无论男女都会走上街头看花灯，熙熙攘攘的长街上，叫卖声，笙箫声，挑逗声此起彼伏，放眼望去，无论是御街还是寻常巷陌，皆是张灯结彩，宛如一片片星海。从前的花灯也好看，形态各异，五彩缤纷，令人眼花缭乱，正如那座始终埋没在江南烟雨中的城市，仿佛从始至终蒙着一层飘渺的薄暮，令人看不透。<br>可能每一座城市都有专属的颜色，只是大多都隐匿于城市的角落，隐匿于每个普通人的平凡生活，唯有在熙攘佳节时，这种颜色才会变得格外明亮，使不曾熟悉这座城市的人也能真切地感受到。<br>而天启的京师，惟有一片真切而阴郁的灰色。<br>今年的冬天格外冷。哪怕是元宵佳节，街上还是寥寥无人，赏灯人们都早早回家，享受炉火和家人的温暖。抬眼看城市的高处，唯有几盏单调的花灯，发着微弱的光，好似幕星一般。<br>“这大概就是王朝日薄西山的景象吧。”他这样想着，推开了门。<br>她依旧在弹她的琴。声音并不十分凄婉，只是很压抑，仿佛与清冷的庭院相应和，很容易让人想到那些可望而不可即的东西，比如故乡，比如理想。<br>“我要走啦，”他自顾自地说，“去关外。”<br>琴声依旧，她已经很久没有同他说过话了。<br>“我知道，你想要的不是这些，为身居高位而左右逢源，为投政敌之所好而加害同窗，可是，我别无选择啊。”<br>琴声骤停。<br>“你还记得你娶我的时候么，”她缓缓地说，“那时的你只是一名一无所有的书生，刚刚考中举人，心中只有以天下为己任，立志做一名人皆称道的好官。可现在呢，你做的那些为了升官发财而做的那些恶心的事我永远也不会忘。”<br>他闻言，沉默了很久。<br>“我有没有和你说过，我小时候想成为一名侠客？”<br>他突然用力，猛地拉过她的衣袖，强迫她直视他的眼睛。<br>“一味地正直是没有用的！我需要力量，我需要可以执掌苍生的权力！没有权力，哪怕侠客梦再美，现世里你什么都不是！”<br>他松开手，大口大口地喘息着。<br>“我说过的话我没有忘，”他说，“也永远不会忘。”<br>院门忽的被推开，身着华贵彩衣的随从和身着铁甲的武士鱼贯而入，层层环绕在他身旁。<br>“大人，时候到了，该走了。”一名随从上前，压低声音说。<br>他面色冷峻地推开他，跨上一匹马，走出了大院。<br>“晴，照顾好自己。”<br>一队人策马向京师外飞驰而去，他们的身后，似伴若有若无的琴声。<br>“那么，我相信你，希望你不会让我失望。”<br>（四）<br>城外。<br>后金的骑兵已列队完毕，沉默的武士胯下是嘶鸣的骏马，来自朔北的风呼啸而过，他们却纹丝不动。等待着的最后进攻的命令。<br>他从城头回望，同样无言的士兵站在城头，正在最后调试红衣大炮。<br>这是他们最后的仰仗。只有这些来自葡萄牙，被称为“佛郎机”的恐怖巨兽才能遏制住后金军的骏马长刀。<br> 他突然很想说些什么，却又不知道从何说起。<br>其实他从小就不善言谈，只有在面对相知的人他才会知无不言。但多年宦海沉浮，他再也没遇到凌那样知心的人。她也很久不理解他，不言说那些本可以说的万语千言。<br>“你在何方？行何事？你的身旁是否有值得守护的人？”他想。<br>“这里，是我们的土地！”他一字一顿。<br>“我不知道是什么让你们走到现在，但对于我，是我的侠客梦。从很小的时候开始，我就梦想做一名仗剑走江湖的大侠，能劫富济贫，行侠一方，但长大了才发现，侠客精神的存在本就是社会的悖论，一己之力终究改变不了太多。”他叹息了一声，“为了这一天，我已经等待了太久，走过官场的腐朽黑暗，习惯了踩着别人的尸体前行，看惯了勾心斗角，生离死别，我一直在寻找一个可以报国的机会。那个机会，就在我面前，就在我们面前！”<br>“列阵！”他大声的说。<br>（五）<br>“头儿，前面已经开打了！”<br>凌暗自叹息，他终究还是没能在开战之前赶到城下。说实话他对这座孤城的守将还是比较好奇的，本希望能见他一面，但现在怕是没有机会了。<br>“寻找破绽，直接切入战场！”<br>战事如火如荼的进行着，每一刻都有人死去。<br>后金军的骑兵虽然犀利，但却不善于攻城，而明军虽然人数劣势，但有必死的心智，加上有利的地形和怒吼的红衣大炮，竟是挡住了后金的攻势，竟隐隐有反攻地迹象。<br>中军的努尔哈赤有些着急了。对面守将是谁？无名小卒罢了。而堂堂的后金国主竟在此无名小卒面前停滞不前。这是他所不能接受的。<br>“正黄旗压上！我领军做先锋！”他怒吼一声。<br>“报告！西南方出现不明军队，直奔我们中军而来！”<br>努尔哈赤大惊，急忙望去。<br>只见一支飞驰的骑军神兵般降入战场，借着战马的冲击力，所到之处后金军皆人仰马翻。为首的一人身着黑衣，手执双刀，翻飞间手起刀落。似有睥睨八荒之威势。<br>“这才是我想要的对手啊！”努尔哈赤赞叹地说，“不过这样笔直的冲阵，怕是嫌命长了吧？”<br>他握起了他的刀。<br>……<br>他依旧站在城楼上，只不过手中多了一口宝剑。<br>“有人来了！”他看到了骑兵赴死般的冲阵，自然也认出了他心念的人。<br>凌。<br>“打开城门，召集骑兵出城迎战！”<br>“你疯了！你知道他们是什么人！”<br>“我知道，”他头也不回地说，“那是我的故人。”<br>他仰天长啸，城门洞开。<br>“此去经年，你过的好吗？”<br>（六）<br>他还记得与凌的分别。<br>那天他喝了很多酒，似乎把所有剩下的钱都拿来买酒了。<br>“那我走了，你要照顾好自己啊。”<br>“我会的，你也是，别再为了别人那么拼了。”<br>凌笑。<br>“可要好好对她啊，不然我可不放过你。”<br>“好啦好啦，我知道你也喜欢过她，是啊，她那样的人又有几个人不喜欢呢？放心，我会永远对她好的。可是现在，天色已晚啦。”<br>他不再说话，小口啜着酒。<br>凌忽然想起他曾经读到过的一句诗，“桃李春风一杯酒，江湖夜雨十年灯。”<br>可能这句话就是写离别的吧？分开时大家都强撑着把酒言欢，分开后却独行辗转，守心独语，再也不说出心中所想，在每个沉默的夜里走向远方。<br>“那，我走了，再会。”<br>再会。<br>再会吧，希望再会之时，你能实现所有愿望，负剑走在山水江湖间，清傲孤寒，无所牵挂。<br>（七）<br>凌已经无力对他行礼了。<br>硝烟散尽，敌军退去，他们打赢了这场不可能胜利的战争，但他就要死了。<br>所谓故人相逢应该是很美满的吧？毕竟天下有四海，故人却寥寥无几。所以每个相逢应举杯相迎，推杯换盏间，说尽世间沧桑。<br>可战场上的相逢总是意味着分别，而且是以天人两隔的分别，，一人归去，再无相逢执手的可能。<br>“你还是那样，为了别人总是奋不顾身啊。”他不禁回想起小时候凌为了保护他在小巷中与人斗殴至头破血流的时光，发现他从未真正理解过身边的人，只是在自我所信奉的道路上渐行渐远。<br>“没办法，本就一无所有，所以每次才能压上全部，毕竟就算失败了也失去不了什么。凌咳出一口鲜血，“不说这个了，她还好么？”<br>“嗯，不过她现在应该很讨厌我吧？为了身居高位，可以掌兵作战，我做了太多为人所不齿的事。”他苦笑。<br>“还记得我们小时候么？你说你要做一名大侠，我要吵着闹着要跟在你身后，如今的你还留着当年的梦么？只是我不能陪你走了啊。”凌神智已经有些恍惚，“没事，你还有她，她也是懂你的吧？可要好好待她啊，不然我……”<br>“你总是对我说这些。让我想起我父亲。”他打断了凌，转身，走向落日余晖照耀下的、只剩下断壁颓垣的宁远城，一场胜利改变不了什么，后金军还会再来，战火的暗影始终笼罩在辽东这片土地的上空。<br>凌望着他的背影渐行渐远，往事如漫天风雪扑面而来。<br>“你的侠客梦，要一直走下去啊。”凌轻声说着，闭上了双眼。<br>（八）<br>崇祯三年。京师。<br>他望着窗外，盛夏已过，秋的肃杀萧瑟已缓慢入侵了京城。<br>宁远大捷后，他本可以节节攀升，但他却毅然辞官归乡，去寻找他故人眼中的侠的身影。<br>谁也不知道多年以后他为何要重新出山，也没有人能想到他竟然死于最忠诚的帝国之手。<br>而她，就像是不愿看到他的结局一般，一年前已弃他而去。<br>“现在世间，却是没有令我牵挂的人和事了啊。”他暗自想着。回想自己的一生。<br>“追求侠义，心系苍生，错了吗？”<br>“沉浮官场，不择手段，错了吗？”<br>“独守孤城，力战外侮，错了吗？”<br>“我一生追求的侠义，难道是错的吗？还是说面对这个世界，侠的精神就应当被埋藏在每个心怀正义的人的内心而不展露呢？可是这样，那侠客精神存在的意义和目的又是什么呢？”<br>天将明。<br>他这样想着，面对自己和帝国的薄暮，紧紧地闭上了双眼。</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>奎桑提教学</title>
    <url>/2023/02/10/%E5%A5%8E%E6%A1%91%E6%8F%90%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>奎桑提</tag>
      </tags>
  </entry>
  <entry>
    <title>塑鸿</title>
    <url>/2023/01/17/%E5%A1%91%E9%B8%BF/</url>
    <content><![CDATA[<h5 id="塑鸿"><a href="#塑鸿" class="headerlink" title="塑鸿"></a>塑鸿</h5><p>天地间的青山在极目外<br>苍穹上的鸿雁在远眺中<br>仰慕于青山的浩渺<br>惊异于鸿雁的自信<br>于是决意塑造自我的鸿<br>翱翔于予慕的青山上</p>
<p>首先我要铸造锻打它的骨骼<br>剔除每一丝杂质里的犹豫与怯懦</p>
<p>其次我要编制描绘它的羽翼<br>从林间的微风里捕捉自由 从深海的月影中萃取温</p>
<p>我更要全心全意塑造它的灵魂<br>以我所见的每一个不羁的鸿的语言<br>以我心心念念的长久执着与陪伴<br>以我每一个漫漫长夜的静静守望</p>
<p>我之所以强调所谓塑造的意义<br>是因为它可以抛弃每一个人心中与身上所有所有的不完美<br>只把最美好最高洁的内心展现于世人面前<br>把每一个展翅翱翔的背影留在世人心中</p>
<p>我知道<br>终究我塑造的鸿会离我而去<br>飞向我永远看不到的青山上<br>而我只能慢慢消散而被时光遗弃</p>
<p>但我相信<br>终有一天<br>我的鸿会于其他的鸿比翼飞翔于这遍及青山的世<br>传递我塑造时给予的无限爱恋与期待</p>
<p>纵使那时我已长辞于此<br>纵使那时已无人知晓我的名字</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>奥恩教学</title>
    <url>/2023/02/10/%E5%A5%A5%E6%81%A9%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>教学</category>
      </categories>
      <tags>
        <tag>奥恩</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/2023/03/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="微服务架构原理与治理实践："><a href="#微服务架构原理与治理实践：" class="headerlink" title="微服务架构原理与治理实践："></a>微服务架构原理与治理实践：</h1><h1 id="1-引入："><a href="#1-引入：" class="headerlink" title="1.引入："></a>1.引入：</h1><p>微服务架构是当前大多数互联网公司的标准架构.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103120.png" alt="QQ截图20230204103120"></p>
<p>演进历史：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103154.png" alt="QQ截图20230204103154"></p>
<h2 id="2-1-单体架构："><a href="#2-1-单体架构：" class="headerlink" title="2.1 单体架构："></a>2.1 单体架构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103231.png" alt="QQ截图20230204103231"></p>
<h2 id="2-2-垂直应用架构："><a href="#2-2-垂直应用架构：" class="headerlink" title="2.2 垂直应用架构："></a>2.2 垂直应用架构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103412.png" alt="QQ截图20230204103412"></p>
<h2 id="2-3-分布式架构："><a href="#2-3-分布式架构：" class="headerlink" title="2.3 分布式架构："></a>2.3 分布式架构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103420.png" alt="QQ截图20230204103420"></p>
<h2 id="2-4-SOA架构："><a href="#2-4-SOA架构：" class="headerlink" title="2.4 SOA架构："></a>2.4 SOA架构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103513.png" alt="QQ截图20230204103513"></p>
<h2 id="2-5-微服务架构："><a href="#2-5-微服务架构：" class="headerlink" title="2.5 微服务架构："></a>2.5 微服务架构：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103557.png" alt="QQ截图20230204103557"></p>
<h1 id="2-微服务架构："><a href="#2-微服务架构：" class="headerlink" title="2.微服务架构："></a>2.微服务架构：</h1><h2 id="2-1-微服务概览："><a href="#2-1-微服务概览：" class="headerlink" title="2.1 微服务概览："></a>2.1 微服务概览：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103735.png" alt="QQ截图20230204103735"></p>
<h2 id="2-2-核心要素："><a href="#2-2-核心要素：" class="headerlink" title="2.2 核心要素："></a>2.2 核心要素：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204103807.png" alt="QQ截图20230204103807"></p>
<h2 id="2-3-基本概念："><a href="#2-3-基本概念：" class="headerlink" title="2.3 基本概念："></a>2.3 基本概念：</h2><h3 id="2-3-1-服务与实例："><a href="#2-3-1-服务与实例：" class="headerlink" title="2.3.1 服务与实例："></a>2.3.1 服务与实例：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204104000.png" alt="QQ截图20230204104000"></p>
<p>一个服务内部具有多个实例.也有可能只有一个实例。</p>
<p>一个服务的所有实例必须运行同一段代码。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204104210.png" alt="QQ截图20230204104210"></p>
<h3 id="2-3-2-服务间通信："><a href="#2-3-2-服务间通信：" class="headerlink" title="2.3.2 服务间通信："></a>2.3.2 服务间通信：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204104256.png" alt="QQ截图20230204104256"></p>
<h3 id="2-3-3-服务注册与发现："><a href="#2-3-3-服务注册与发现：" class="headerlink" title="2.3.3  服务注册与发现："></a>2.3.3  服务注册与发现：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204104624.png" alt="QQ截图20230204104624"></p>
<p>解决写死问题：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204104702.png" alt="QQ截图20230204104702"></p>
<p>无法相对平均的访问服务中的各个实例。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204104833.png" alt="QQ截图20230204104833"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204104947.png" alt="QQ截图20230204104947"></p>
<p>下线：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204105032.png" alt="QQ截图20230204105032"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204105022.png" alt="QQ截图20230204105022"></p>
<p>上线：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204105053.png" alt="QQ截图20230204105053"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204105318.png" alt="QQ截图20230204105318"></p>
<h3 id="2-3-4-流量特征："><a href="#2-3-4-流量特征：" class="headerlink" title="2.3.4 流量特征："></a>2.3.4 流量特征：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204105348.png" alt="QQ截图20230204105348"></p>
<h2 id="2-4-服务治理："><a href="#2-4-服务治理：" class="headerlink" title="2.4 服务治理："></a>2.4 服务治理：</h2><h3 id="2-4-1-服务发布："><a href="#2-4-1-服务发布：" class="headerlink" title="2.4.1 服务发布："></a>2.4.1 服务发布：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204105704.png" alt="QQ截图20230204105704"></p>
<p>存在的问题：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204105831.png" alt="QQ截图20230204105831"></p>
<h4 id="2-4-1-2-蓝绿部署："><a href="#2-4-1-2-蓝绿部署：" class="headerlink" title="2.4.1.2 蓝绿部署："></a>2.4.1.2 蓝绿部署：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204110213.png" alt="QQ截图20230204110213"></p>
<p>先部署一部分实例。</p>
<p>简单，稳定，但是需要两倍的资源。</p>
<h4 id="2-4-1-3-灰度发布（金丝雀发布）"><a href="#2-4-1-3-灰度发布（金丝雀发布）" class="headerlink" title="2.4.1.3 灰度发布（金丝雀发布）"></a>2.4.1.3 灰度发布（金丝雀发布）</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204110536.png" alt="QQ截图20230204110536"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204110624.png" alt="QQ截图20230204110624"></p>
<p>不停地增添新的实例，去掉旧的实例。</p>
<p>如果在升级过程中，尤其是在升级后期（99%），发现bug，回滚会非常的困难。而k8s这种平台可以实现。</p>
<h3 id="2-4-2-流量治理："><a href="#2-4-2-流量治理：" class="headerlink" title="2.4.2 流量治理："></a>2.4.2 流量治理：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204110930.png" alt="QQ截图20230204110930"></p>
<p>boe？可以基于用户，测试自己的需求。</p>
<h3 id="2-4-3-负载均衡："><a href="#2-4-3-负载均衡：" class="headerlink" title="2.4.3 负载均衡："></a>2.4.3 负载均衡：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204111541.png" alt="QQ截图20230204111541"></p>
<h3 id="2-4-4-稳定性治理："><a href="#2-4-4-稳定性治理：" class="headerlink" title="2.4.4 稳定性治理："></a>2.4.4 稳定性治理：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204111645.png" alt="QQ截图20230204111645"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204111804.png" alt="QQ截图20230204111804"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204111821.png" alt="QQ截图20230204111821"></p>
<p>熔断过程中，服务a不会一直访问，而是间歇性的访问尝试一下b恢复了没有。</p>
<p>降级就是有限保证重要的服务，而拒绝掉相对不太重要的服务。</p>
<h3 id="2-4-5-总结："><a href="#2-4-5-总结：" class="headerlink" title="2.4.5 总结："></a>2.4.5 总结：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204112127.png" alt="QQ截图20230204112127"></p>
<h1 id="3-服务治理实践-重试："><a href="#3-服务治理实践-重试：" class="headerlink" title="3.服务治理实践-重试："></a>3.服务治理实践-重试：</h1><h2 id="3-1-是否需要重试："><a href="#3-1-是否需要重试：" class="headerlink" title="3.1 是否需要重试："></a>3.1 是否需要重试：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204112417.png" alt="QQ截图20230204112417"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204112448.png" alt="QQ截图20230204112448"></p>
<p>本地调用如果失败，不需要重试。</p>
<p>远程调用失败，可以考虑重试。</p>
<h2 id="3-2-重试的意义"><a href="#3-2-重试的意义" class="headerlink" title="3.2 重试的意义;"></a>3.2 重试的意义;</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204112618.png" alt="QQ截图20230204112618"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204112718.png" alt="QQ截图20230204112718"></p>
<p>长尾延时，指的是有些请求的时间特别长（由于服务治理和负载均衡的部分策略原因）。</p>
<h2 id="3-3-重试的难点："><a href="#3-3-重试的难点：" class="headerlink" title="3.3 重试的难点："></a>3.3 重试的难点：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204113025.png" alt="QQ截图20230204113025"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204113008.png" alt="QQ截图20230204113008"></p>
<p>次数指数型增长。</p>
<h2 id="3-4-重试策略："><a href="#3-4-重试策略：" class="headerlink" title="3.4 重试策略："></a>3.4 重试策略：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204113233.png" alt="QQ截图20230204113233"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204113318.png" alt="QQ截图20230204113318"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204113524.png" alt="QQ截图20230204113524"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204113707.png" alt="QQ截图20230204113707"></p>
<h1 id="4-总结："><a href="#4-总结：" class="headerlink" title="4.总结："></a>4.总结：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204113845.png" alt="QQ截图20230204113845"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>巷</title>
    <url>/2023/02/10/%E5%B7%B7/</url>
    <content><![CDATA[<p>巷<br>他依稀记得昔年初遇的模样<br>在熟悉的故国故城</p>
<p>恍若千里是熙熙攘攘的古巷<br>莺飞草长映出她眼中的流光<br>时光婉转却风采飞扬</p>
<p>少年转身告别故乡<br>闯荡远方的背后留下寂寞清冷的月光她低沉的吟唱被时光渐渐淡忘<br>抑或昏黄的月影中烛火黯淡无光</p>
<p>年华辗转后少年忆起曾经豆蔻旧梦</p>
<p>开始循着旧梦走向魂牵梦萦的故乡</p>
<p>当他越过青山重 终于以游子归来<br>古巷里再也听不到 的是她的婉转歌声</p>
<p>少年念及过往后再叹世事无常<br>转身离去赴往喧嚣浮华的客方<br>又是一夜清冷月光<br>恍然间又听到她的低声浅唱<br>他仿佛褪去眉间风霜如同时光轮转梦中古巷里的故人重逢<br>再也等不到的两相执手<br>他紧握着半生的古巷月光<br>看着幻梦中的她渐行渐远<br>希冀着时光再一次流转<br>流转出彼时年少的模样</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库概述</title>
    <url>/2023/03/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="1-数据持久化"><a href="#1-数据持久化" class="headerlink" title="1.数据持久化:"></a>1.数据持久化:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309095548.png" alt="QQ截图20230309095548"></p>
<p>一些问题:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309095740.png" alt="QQ截图20230309095740"></p>
<h1 id="2-存储系统与数据库系统"><a href="#2-存储系统与数据库系统" class="headerlink" title="2.存储系统与数据库系统:"></a>2.存储系统与数据库系统:</h1><h2 id="2-1-存储系统"><a href="#2-1-存储系统" class="headerlink" title="2.1 存储系统:"></a>2.1 存储系统:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309100001.png" alt="QQ截图20230309100001"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309100035.png" alt="QQ截图20230309100035"></p>
<p>io的基本路径上要简单,处于性能考虑,但是在异常处理上要做到复杂.</p>
<h2 id="2-2-存储器的层级结构"><a href="#2-2-存储器的层级结构" class="headerlink" title="2.2 存储器的层级结构:"></a>2.2 存储器的层级结构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309100302.png" alt="QQ截图20230309100302"></p>
<p>上方存储容量小,读写快.</p>
<p>下方存储容量大,读写慢.</p>
<h2 id="2-3-应用到存储介质"><a href="#2-3-应用到存储介质" class="headerlink" title="2.3 应用到存储介质:"></a>2.3 应用到存储介质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309100513.png" alt="QQ截图20230309100513"></p>
<h2 id="2-4-RAID技术"><a href="#2-4-RAID技术" class="headerlink" title="2.4 RAID技术:"></a>2.4 RAID技术:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309100813.png" alt="QQ截图20230309100813"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309101050.png" alt="QQ截图20230309101050"></p>
<h2 id="2-5-关系"><a href="#2-5-关系" class="headerlink" title="2.5 关系:"></a>2.5 关系:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309101302.png" alt="QQ截图20230309101302"></p>
<p>关系型数据库是存储系统,但是在存储之外,有发展出其他能力.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309101357.png" alt="QQ截图20230309101357"></p>
<p>非关系型数据库也是存储系统,但是一般不要求严格的结构化.</p>
<h2 id="2-6-结构化数据管理"><a href="#2-6-结构化数据管理" class="headerlink" title="2.6 结构化数据管理:"></a>2.6 结构化数据管理:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309101603.png" alt="QQ截图20230309101603"></p>
<p>事务能力:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309101724.png" alt="QQ截图20230309101724"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309102054.png" alt="QQ截图20230309102054"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309102131.png" alt="QQ截图20230309102131"></p>
<h1 id="3-主流存储产品"><a href="#3-主流存储产品" class="headerlink" title="3.主流存储产品:"></a>3.主流存储产品:</h1><p>明确存储系统与数据库系统的区别.</p>
<h2 id="3-1-单机存储-本地文件系统"><a href="#3-1-单机存储-本地文件系统" class="headerlink" title="3.1 单机存储-本地文件系统:"></a>3.1 单机存储-本地文件系统:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309102437.png" alt="QQ截图20230309102437"></p>
<h2 id="3-2-单机存储-k-v存储系统"><a href="#3-2-单机存储-k-v存储系统" class="headerlink" title="3.2 单机存储-k-v存储系统:"></a>3.2 单机存储-k-v存储系统:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309102859.png" alt="QQ截图20230309102859"></p>
<h2 id="3-2-分布式存储系统"><a href="#3-2-分布式存储系统" class="headerlink" title="3.2 分布式存储系统:"></a>3.2 分布式存储系统:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309103346.png" alt="QQ截图20230309103346"></p>
<h3 id="3-2-1-HDFS-分布式文件系统"><a href="#3-2-1-HDFS-分布式文件系统" class="headerlink" title="3.2.1 HDFS:分布式文件系统:"></a>3.2.1 HDFS:分布式文件系统:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309103425.png" alt="QQ截图20230309103425"></p>
<h2 id="3-2-2-Ceph"><a href="#3-2-2-Ceph" class="headerlink" title="3.2.2 Ceph:"></a>3.2.2 Ceph:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309103719.png" alt="QQ截图20230309103719"></p>
<h1 id="4-主流数据库"><a href="#4-主流数据库" class="headerlink" title="4.主流数据库:"></a>4.主流数据库:</h1><h2 id="4-1-单机关系型数据库"><a href="#4-1-单机关系型数据库" class="headerlink" title="4.1 单机关系型数据库:"></a>4.1 单机关系型数据库:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309103913.png" alt="QQ截图20230309103913"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309104238.png" alt="QQ截图20230309104238"></p>
<p>page是内存真实数据,redo存储事务中的数据库操作,others存储内存不够用时候的临时文件.</p>
<h2 id="4-2-单机型非关系型数据库"><a href="#4-2-单机型非关系型数据库" class="headerlink" title="4.2 单机型非关系型数据库:"></a>4.2 单机型非关系型数据库:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309104417.png" alt="QQ截图20230309104417"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309104750.png" alt="QQ截图20230309104750"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309104908.png" alt="QQ截图20230309104908"></p>
<h2 id="4-3-从单机到分布式"><a href="#4-3-从单机到分布式" class="headerlink" title="4.3 从单机到分布式:"></a>4.3 从单机到分布式:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309105157.png" alt="QQ截图20230309105157"></p>
<p>池化:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309105331.png" alt="QQ截图20230309105331"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309105551.png" alt="QQ截图20230309105551"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309105701.png" alt="QQ截图20230309105701"></p>
<p>一些难题:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309105720.png" alt="QQ截图20230309105720"></p>
<h1 id="5-演进"><a href="#5-演进" class="headerlink" title="5.演进:"></a>5.演进:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309110106.png" alt="QQ截图20230309110106"></p>
<h2 id="5-1-SPDK"><a href="#5-1-SPDK" class="headerlink" title="5.1 SPDK:"></a>5.1 SPDK:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309110137.png" alt="QQ截图20230309110137"></p>
<h2 id="5-2-AI"><a href="#5-2-AI" class="headerlink" title="5.2 AI:"></a>5.2 AI:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309110506.png" alt="QQ截图20230309110506"></p>
<h2 id="5-3-高性能硬件"><a href="#5-3-高性能硬件" class="headerlink" title="5.3 高性能硬件:"></a>5.3 高性能硬件:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309110645.png" alt="QQ截图20230309110645"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309110803.png" alt="QQ截图20230309110803"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230309110830.png" alt="QQ截图20230309110830"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>彩云辞</title>
    <url>/2023/01/17/%E5%BD%A9%E4%BA%91%E8%BE%9E/</url>
    <content><![CDATA[<h5 id="彩云辞"><a href="#彩云辞" class="headerlink" title="彩云辞"></a>彩云辞</h5><p>夕照弥漫<br>沉醉于金色的山水风光<br>殊不知云影变幻<br>彩云悄然泊于身旁</p>
<p>灵动飞扬是彩云的身影<br>明丽温婉是彩云的光芒<br>桀骜的白云也再移不开目光<br>在秋月秋水的秉烛夜谈<br>在春日春山的缓缓吟唱</p>
<p>然世事变易 风雨飘摇<br>彩云徐徐归去<br>于梦不到的云间<br>用七彩的微光传递温暖<br>唯有天鸢可以拉住彩云的裙摆<br>在同去同归中执手相望</p>
<p>面向涌动的人海<br>彩云只在回忆里<br>升起一轮淡淡的暖阳<br>柴米油盐的生活<br>庸俗肤浅的岁月<br>不经意间短暂的回想<br>总会带来善良与希望</p>
<p>叹天地广袤 万象纷繁<br>惟有珍藏彩云往昔的言笑顾盼<br>细数彩云光影的日暮温柔<br>对彩云向远方的归去<br>许下最真挚的承诺 最美好的祝福</p>
<p>愿彩云始终保持七彩的模样<br>温柔的光洒落并不温柔的人间<br>愿彩云与你我的几多相遇相知<br>温柔的鼓励一程追寻 踏山寻海<br>不卑不亢</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>明月策</title>
    <url>/2023/05/29/%E6%98%8E%E6%9C%88%E7%AD%96/</url>
    <content><![CDATA[<p>明月策<br>灯火幽微 月色皎皎<br>过客从乡野游荡到市镇<br>孤魂般掠过银白色街道<br>掠过与他无关的</p>
<p>故乡的低语 情人的呢喃<br>他简单思量着远方递不出的喜爱<br>喟叹自己不知几日缘起而花落的一生一次次<br>千里明月</p>
<p>可否传递思绪万千？<br>于是他折断利刃 既闻铁砧铿锵 笔锋凌扬<br>以精工 细笔策问明月 折返月光</p>
<p>当过客带着丑陋 贪婪 无能和懦弱远去<br>在明月策的书简上留下刀痕与笔端<br>世人肆意横行着<br>明月策上浩荡强风吹拂过的雕刻和文字<br>千古以往白驹咆哮般游历世界的孤魂过客<br>带着被漠视意外的喜悦与喜爱徘徊<br>皓首穷经谓之策<br>白首不离谓之明月</p>
<p>借着月光告别市镇的过客<br>拥抱大地与玫瑰<br>祝福幸福的人民<br>无奈的翻动着明月策的书页<br>或许只是再找越来越远的思念<br>或许在等另外一个同样爱的明媚炽烈的孤魂<br>月光皎皎</p>
<p>希望闪亮</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统</title>
    <url>/2023/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h1><h1 id="1-概论"><a href="#1-概论" class="headerlink" title="1.概论"></a>1.概论</h1><h2 id="1-1-数据库"><a href="#1-1-数据库" class="headerlink" title="1.1 数据库:"></a>1.1 数据库:</h2><p>是长期储存在计算机内、有组织的、可共享的数据集合.</p>
<h2 id="1-2-数据库管理系统"><a href="#1-2-数据库管理系统" class="headerlink" title="1.2 数据库管理系统:"></a>1.2 数据库管理系统:</h2><p>管理数据库，支持应用的软件系统 DataBase Management System (DBMS).</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608111714224.png" alt="image-20230608111714224"></p>
<h2 id="1-3-数据库系统"><a href="#1-3-数据库系统" class="headerlink" title="1.3 数据库系统:"></a>1.3 数据库系统:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608111745493.png" alt="image-20230608111745493"></p>
<h2 id="1-4-文件系统的劣势"><a href="#1-4-文件系统的劣势" class="headerlink" title="1.4 文件系统的劣势:"></a>1.4 文件系统的劣势:</h2><p><strong>数据冗余和不一致</strong></p>
<p><strong>数据访问困难</strong></p>
<p>传统文件处理环境不支持方便而高效的方式去获取数据，不能对变化的需求做出更快的反应。</p>
<p><strong>数据孤立</strong></p>
<p>数据分散在不同文件中，这些文件又可能具有不同的格式，因此编写新的应用程序来检索适当数据是很困难的.</p>
<p><strong>完整性问题</strong></p>
<p>数据库所存储的数据值必须满足某些特定一致性约束文件系统中，新的约束加入时，很难通过修改程序来体现这些新约束,当约束涉及到不同文件中的多个数据项时，问题更为复杂.</p>
<p><strong>原子性问题</strong></p>
<p>操作是原子的：为了保证数据库的一致性，一些操作要么全部发生、要么根本不发生，例如：转账在传统文件处理系统中，很难保持上述原子性。</p>
<p><strong>并发访问异常</strong></p>
<p>了提高系统的总体性能及加快响应速度，许多系统需要允许多个用户同时更新数据,在文件系统中，数据可能被多个不同应用程序访问，这些程序相互间事先没有协调，管理就很难进行.</p>
<p><strong>安全性问题</strong></p>
<p>并非数据库系统的所有用户都可以访问所有数据,由于文件系统中应用程序总是即席地加入到文件处理系统中来，这样的安全性约束难以实现.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112155934.png" alt="image-20230608112155934"></p>
<h2 id="1-5-数据库系统结构"><a href="#1-5-数据库系统结构" class="headerlink" title="1.5 数据库系统结构:"></a>1.5 数据库系统结构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112221435.png" alt="image-20230608112221435"></p>
<h2 id="1-6-数据抽象"><a href="#1-6-数据抽象" class="headerlink" title="1.6 数据抽象:"></a>1.6 数据抽象:</h2><p>对于用户系统地隐藏关于数据存储和维护的某些细节,屏蔽复杂性，简化用户与系统的交互.</p>
<h3 id="1-6-1-视图抽象"><a href="#1-6-1-视图抽象" class="headerlink" title="1.6.1 视图抽象:"></a>1.6.1 视图抽象:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112434463.png" alt="image-20230608112434463"></p>
<h3 id="1-6-2-逻辑抽象"><a href="#1-6-2-逻辑抽象" class="headerlink" title="1.6.2 逻辑抽象:"></a>1.6.2 逻辑抽象:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112502106.png" alt="image-20230608112502106"></p>
<h3 id="1-6-3-物理抽象"><a href="#1-6-3-物理抽象" class="headerlink" title="1.6.3 物理抽象:"></a>1.6.3 物理抽象:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112527896.png" alt="image-20230608112527896"></p>
<h2 id="1-7-数据独立性"><a href="#1-7-数据独立性" class="headerlink" title="1.7 数据独立性:"></a>1.7 数据独立性:</h2><h3 id="1-7-1-物理数据独立性"><a href="#1-7-1-物理数据独立性" class="headerlink" title="1.7.1 物理数据独立性:"></a>1.7.1 物理数据独立性:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112621203.png" alt="image-20230608112621203"></p>
<h3 id="1-7-2-逻辑数据独立性"><a href="#1-7-2-逻辑数据独立性" class="headerlink" title="1.7.2 逻辑数据独立性:"></a>1.7.2 逻辑数据独立性:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112646064.png" alt="image-20230608112646064"></p>
<h2 id="1-8-数据模型"><a href="#1-8-数据模型" class="headerlink" title="1.8 数据模型:"></a>1.8 数据模型:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112714623.png" alt="image-20230608112714623"></p>
<p>常用的数据模型:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112741975.png" alt="image-20230608112741975"></p>
<h3 id="1-8-1-层次数据模型"><a href="#1-8-1-层次数据模型" class="headerlink" title="1.8.1 层次数据模型:"></a>1.8.1 层次数据模型:</h3><p>有且只有一个结点没有双亲结点，这个结点称为根结点,根以外的其它结点有且只有一个双亲结点.</p>
<p>一个例子:<br><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112857743.png" alt="image-20230608112857743"></p>
<p>优缺点:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112850291.png" alt="image-20230608112850291"></p>
<h3 id="1-8-2-网状数据模型"><a href="#1-8-2-网状数据模型" class="headerlink" title="1.8.2 网状数据模型:"></a>1.8.2 网状数据模型:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608112935942.png" alt="image-20230608112935942"></p>
<p>优缺点:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113001074.png" alt="image-20230608113001074"></p>
<h2 id="1-9-数据库语言"><a href="#1-9-数据库语言" class="headerlink" title="1.9 数据库语言:"></a>1.9 数据库语言:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113028790.png" alt="image-20230608113028790"></p>
<h1 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2.关系数据库:"></a>2.关系数据库:</h1><h2 id="2-1-关系模型"><a href="#2-1-关系模型" class="headerlink" title="2.1 关系模型:"></a>2.1 关系模型:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113142099.png" alt="image-20230608113142099"></p>
<h2 id="2-2-关系数据结构的基本概念"><a href="#2-2-关系数据结构的基本概念" class="headerlink" title="2.2 关系数据结构的基本概念:"></a>2.2 关系数据结构的基本概念:</h2><h3 id="2-2-1属性"><a href="#2-2-1属性" class="headerlink" title="2.2.1属性:"></a>2.2.1属性:</h3><p>关系表的列,顺序无关紧要</p>
<h3 id="2-2-2域"><a href="#2-2-2域" class="headerlink" title="2.2.2域:"></a>2.2.2域:</h3><p>属性的所有可能取值的集合，称为该属性的域</p>
<h3 id="2-2-3关系"><a href="#2-2-3关系" class="headerlink" title="2.2.3关系:"></a>2.2.3关系:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113500259.png" alt="image-20230608113500259"></p>
<p>笛卡尔积中的每一个元素称为一个元组.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113551262.png" alt="image-20230608113551262"></p>
<h3 id="2-2-4关系模式"><a href="#2-2-4关系模式" class="headerlink" title="2.2.4关系模式:"></a>2.2.4关系模式:</h3><p>关系的型.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113659892.png" alt="image-20230608113659892"></p>
<p>注意此处的关系是数据库字段之间的关系.</p>
<p>举个例子:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113727645.png" alt="image-20230608113727645"></p>
<h3 id="2-2-5-关系数据库"><a href="#2-2-5-关系数据库" class="headerlink" title="2.2.5 关系数据库:"></a>2.2.5 关系数据库:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608113801270.png" alt="image-20230608113801270"></p>
<h2 id="2-3-完整性约束"><a href="#2-3-完整性约束" class="headerlink" title="2.3 完整性约束:"></a>2.3 完整性约束:</h2><h3 id="2-3-1-超码"><a href="#2-3-1-超码" class="headerlink" title="2.3.1 超码:"></a>2.3.1 超码:</h3><p>唯一的标识一个元组.</p>
<h3 id="2-3-2-候选码"><a href="#2-3-2-候选码" class="headerlink" title="2.3.2 候选码:"></a>2.3.2 候选码:</h3><p>超码.且真子集不是超码.一个关系模式可以有多个候选码.</p>
<h3 id="2-3-3-主键-主码"><a href="#2-3-3-主键-主码" class="headerlink" title="2.3.3 主键(主码):"></a>2.3.3 主键(主码):</h3><p>被数据库设计者选中的，用来在同一关系中区分不同元组的候选键.</p>
<p>选择原则：值从不或很少变化的.</p>
<p>一个关系模式只能具有一个主键,主键中的属性称为关系的主属性.</p>
<h3 id="2-3-4-外键-外码"><a href="#2-3-4-外键-外码" class="headerlink" title="2.3.4 外键(外码):"></a>2.3.4 外键(外码):</h3><p>主键在其他表中.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608114144524.png" alt="image-20230608114144524"></p>
<p>外键并不一定要与相应的主键同名。</p>
<p>一般情况下，外键与相应的主键往往取相同的名字，以便于识别.</p>
<h3 id="2-3-5-实体完整性约束"><a href="#2-3-5-实体完整性约束" class="headerlink" title="2.3.5 实体完整性约束:"></a>2.3.5 实体完整性约束:</h3><p>主键不能为空.</p>
<h3 id="2-3-6-关联完整性约束"><a href="#2-3-6-关联完整性约束" class="headerlink" title="2.3.6 关联完整性约束:"></a>2.3.6 关联完整性约束:</h3><p>外键的值必须有对应的主键.</p>
<h2 id="2-4-关系运算"><a href="#2-4-关系运算" class="headerlink" title="2.4 关系运算:"></a>2.4 关系运算:</h2><h3 id="2-4-1-关系代数运算"><a href="#2-4-1-关系代数运算" class="headerlink" title="2.4.1 关系代数运算:"></a>2.4.1 关系代数运算:</h3><p>选择:选出若干行</p>
<p>投影:选出若干列</p>
<p>并:合并元组</p>
<p>差:减去元组</p>
<p>笛卡尔积:列相乘</p>
<p>关系代数的基本运算足以表达任何关系代数查询,但是，如果我们把自己局限于基本运算,某些常用的查询表达出来会显得冗长.</p>
<p>因而，我们定义了一些附加运算，它们不能增加关系代数的表达能力，却可以简化一些常用的查询.</p>
<h3 id="2-4-2-附加关系代数运算"><a href="#2-4-2-附加关系代数运算" class="headerlink" title="2.4.2 附加关系代数运算:"></a>2.4.2 附加关系代数运算:</h3><p>交:交集</p>
<p>连接:</p>
<p>选取属性间满足一定关系的元组.</p>
<h4 id="2-4-2-1-等值连接"><a href="#2-4-2-1-等值连接" class="headerlink" title="2.4.2.1 等值连接:"></a>2.4.2.1 等值连接:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608154559943.png" alt="image-20230608154559943"></p>
<h4 id="2-4-2-2-自然连接"><a href="#2-4-2-2-自然连接" class="headerlink" title="2.4.2.2 自然连接:"></a>2.4.2.2 自然连接:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608154641166.png" alt="image-20230608154641166"></p>
<h4 id="2-4-2-3-左外连接"><a href="#2-4-2-3-左外连接" class="headerlink" title="2.4.2.3 左外连接:"></a>2.4.2.3 左外连接:</h4><p>匹配不上的就不要了.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608154812044.png" alt="image-20230608154812044"></p>
<p>右边外连接也是一样的,两个连接的交集是全外连接.</p>
<h3 id="2-4-3-拓展关系代数运算"><a href="#2-4-3-拓展关系代数运算" class="headerlink" title="2.4.3 拓展关系代数运算:"></a>2.4.3 拓展关系代数运算:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608155049714.png" alt="image-20230608155049714"></p>
<h2 id="2-5-元组关系演算"><a href="#2-5-元组关系演算" class="headerlink" title="2.5 元组关系演算:"></a>2.5 元组关系演算:</h2><p><strong><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608155139015.png" alt="image-20230608155139015"></strong></p>
<p>举几个例子:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608155201419.png" alt="image-20230608155201419"></p>
<h2 id="2-6-关系运算安全性"><a href="#2-6-关系运算安全性" class="headerlink" title="2.6 关系运算安全性:"></a>2.6 关系运算安全性:</h2><p>如果一个关系运算系统不产生无限关系和无穷验证,则这个运算是安全的.</p>
<p>关系代数系统是安全的,元组关系演算不安全.这两种运算之间具有等价性.</p>
<p>关系运算是关系数据库查询语言的基础.</p>
<h2 id="2-7-SQL"><a href="#2-7-SQL" class="headerlink" title="2.7 SQL:"></a>2.7 SQL:</h2><p>结构化查询语言.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608230625061.png" alt="image-20230608230625061"></p>
<h3 id="2-7-1-DDL"><a href="#2-7-1-DDL" class="headerlink" title="2.7.1 DDL:"></a>2.7.1 DDL:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建：</span><br><span class="line">create table/view/index</span><br><span class="line">删除：</span><br><span class="line">drop</span><br><span class="line">修改：</span><br><span class="line">alter table</span><br><span class="line">视图和索引不能修改</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名（</span><br><span class="line">列名 数据类型,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">）</span><br></pre></td></tr></table></figure>

<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608230930095.png" alt="image-20230608230930095"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create unique index 索引名 on 表名（索引字段）</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-授权："><a href="#2-7-2-授权：" class="headerlink" title="2.7.2 授权："></a>2.7.2 授权：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增添</span><br><span class="line">grant 权限 on 关系 to 用户</span><br><span class="line">取消</span><br><span class="line">revoke 权限 on 关系 from 用户</span><br></pre></td></tr></table></figure>

<h3 id="2-7-3-查询："><a href="#2-7-3-查询：" class="headerlink" title="2.7.3 查询："></a>2.7.3 查询：</h3><h4 id="2-7-3-1-单表查询："><a href="#2-7-3-1-单表查询：" class="headerlink" title="2.7.3.1 单表查询："></a>2.7.3.1 单表查询：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608231306012.png" alt="image-20230608231306012"></p>
<p>1.消除重复：distinct 只用一次就行。</p>
<p>2.谓词一览：<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608231541008.png" alt="image-20230608231541008"></p>
<p>3.order by:</p>
<p>放在查询语句的最后，先写orderby +列名，再写策略：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608231744733.png" alt="image-20230608231744733"></p>
<p>4.聚集查询：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608231828078.png" alt="image-20230608231828078"></p>
<p>位置在select后面，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">统计学生总人数.</span><br><span class="line">Select count(*) From student;</span><br><span class="line"></span><br><span class="line">查询选修了课程的学生人数.</span><br><span class="line">Select count(distinct Sno) From SC;</span><br></pre></td></tr></table></figure>

<p>5.分组:</p>
<p>最后，只能出现分组属性和聚集函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select dept_name, Max(salary)</span><br><span class="line">From Employee</span><br><span class="line">Where age》25</span><br><span class="line">Group by dept_name;</span><br><span class="line">age</span><br></pre></td></tr></table></figure>

<p>having：作用于分组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select dept_name, Max(salary)</span><br><span class="line">From Employee</span><br><span class="line">Where age&gt;23</span><br><span class="line">Group by dept_name</span><br><span class="line">Having Max(salary)&gt;80000;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-3-2-连接查询："><a href="#2-7-3-2-连接查询：" class="headerlink" title="2.7.3.2 连接查询："></a>2.7.3.2 连接查询：</h4><p>出现在from后面，表后面。</p>
<p>1.等值连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">FROM Student JOIN SC ON Student.Sno = SC.Sno;</span><br></pre></td></tr></table></figure>

<p>2.自然连接：</p>
<p>在等值连接的基础上，去掉重复的列。</p>
<p>关键字natural join.</p>
<p>3.外连接与内连接：</p>
<p>left，right，inner.</p>
<h4 id="2-7-3-3-嵌套查询："><a href="#2-7-3-3-嵌套查询：" class="headerlink" title="2.7.3.3 嵌套查询："></a>2.7.3.3 嵌套查询：</h4><p>代替表存在的地方，比如where后面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Sname </span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno IN</span><br><span class="line">（SELECT Sno 内</span><br><span class="line">FROM SC</span><br><span class="line">WHERE Cno= &#x27; 2 &#x27;）；</span><br></pre></td></tr></table></figure>

<p>子查询不建议、或无法使用ORDER BY子句。</p>
<p>带有exist的子查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SnameFROM StudentWHERE NOT EXISTS(SELECT *FROM CourseWHERE NOT EXISTS(SELECT *FROM SCWHERE Sno=Student.SnoAND Cno=Course.Cno));</span><br></pre></td></tr></table></figure>

<h3 id="2-7-4-插入："><a href="#2-7-4-插入：" class="headerlink" title="2.7.4 插入："></a>2.7.4 插入：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT</span><br><span class="line">INTO Student</span><br><span class="line">VALUES (&#x27; 200215130&#x27;</span><br><span class="line">，</span><br><span class="line">&#x27;陈冬&#x27;</span><br><span class="line">，</span><br><span class="line">&#x27;男&#x27;</span><br><span class="line">，18 ，</span><br><span class="line">‘CS&#x27;)；</span><br></pre></td></tr></table></figure>

<h3 id="2-7-5-更新："><a href="#2-7-5-更新：" class="headerlink" title="2.7.5 更新："></a>2.7.5 更新：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Student</span><br><span class="line">SET Sage=22</span><br><span class="line">WHERE Sno=‘200215122</span><br></pre></td></tr></table></figure>

<h3 id="2-7-6-删除："><a href="#2-7-6-删除：" class="headerlink" title="2.7.6 删除："></a>2.7.6 删除：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE</span><br><span class="line">FROM Student</span><br><span class="line">WHERE Sno=‘200215121’；</span><br></pre></td></tr></table></figure>



<h1 id="3-数据库完全性与完整性"><a href="#3-数据库完全性与完整性" class="headerlink" title="3.数据库完全性与完整性:"></a>3.数据库完全性与完整性:</h1><h2 id="3-1-安全性"><a href="#3-1-安全性" class="headerlink" title="3.1 安全性:"></a>3.1 安全性:</h2><h3 id="3-1-1-用户标识与鉴别"><a href="#3-1-1-用户标识与鉴别" class="headerlink" title="3.1.1 用户标识与鉴别:"></a>3.1.1 用户标识与鉴别:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608155849143.png" alt="image-20230608155849143"></p>
<h3 id="3-1-2-存取控制机制"><a href="#3-1-2-存取控制机制" class="headerlink" title="3.1.2 存取控制机制:"></a>3.1.2 存取控制机制:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608155945282.png" alt="image-20230608155945282"></p>
<h3 id="3-1-3-授权与权限收回"><a href="#3-1-3-授权与权限收回" class="headerlink" title="3.1.3 授权与权限收回:"></a>3.1.3 授权与权限收回:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160033484.png" alt="image-20230608160033484"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把查询Course表的权限授给用户Bob</span><br><span class="line">GRANT SELECT ON TABLE Course TO Bob;</span><br></pre></td></tr></table></figure>

<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160128269.png" alt="image-20230608160128269"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">收回用户Bob修改Course表中课程号的权限</span><br><span class="line">REVOKE UPDATE(Cno) ON TABLE Course FROM Bob;</span><br></pre></td></tr></table></figure>

<p>数据库角色:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160248592.png" alt="image-20230608160248592"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160254637.png" alt="image-20230608160254637"></p>
<h3 id="3-1-4-审计"><a href="#3-1-4-审计" class="headerlink" title="3.1.4 审计:"></a>3.1.4 审计:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160331131.png" alt="image-20230608160331131"></p>
<h3 id="3-1-5-数据加密"><a href="#3-1-5-数据加密" class="headerlink" title="3.1.5 数据加密:"></a>3.1.5 数据加密:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160353506.png" alt="image-20230608160353506"></p>
<h2 id="3-2-数据完整性"><a href="#3-2-数据完整性" class="headerlink" title="3.2 数据完整性:"></a>3.2 数据完整性:</h2><h3 id="3-2-1-域完整性"><a href="#3-2-1-域完整性" class="headerlink" title="3.2.1 域完整性:"></a>3.2.1 域完整性:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160459884.png" alt="image-20230608160459884"></p>
<p>在create table时候定义.</p>
<h3 id="3-2-2-实体完整性"><a href="#3-2-2-实体完整性" class="headerlink" title="3.2.2 实体完整性:"></a>3.2.2 实体完整性:</h3><p>指关系的主码不能重复也不能取空值.</p>
<h3 id="3-2-3-关系完整性"><a href="#3-2-3-关系完整性" class="headerlink" title="3.2.3 关系完整性:"></a>3.2.3 关系完整性:</h3><p>主外键之间互相参照完整.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160637100.png" alt="image-20230608160637100"></p>
<h3 id="3-2-4-断言"><a href="#3-2-4-断言" class="headerlink" title="3.2.4 断言:"></a>3.2.4 断言:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160728558.png" alt="image-20230608160728558"></p>
<h3 id="3-2-5-触发器"><a href="#3-2-5-触发器" class="headerlink" title="3.2.5 触发器:"></a>3.2.5 触发器:</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程</p>
<p>定义之后的触发器存储在数据库服务器中.</p>
<p>任何用户对表的增、删、改操作均由服务器自动激活相应的触发器.</p>
<p>不同RDBMS实现的触发器语法各不行同，互不兼容.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608160814723.png" alt="image-20230608160814723"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create trigger check2 after delete on Course</span><br><span class="line"></span><br><span class="line">referencing old row as orow</span><br><span class="line"></span><br><span class="line">for each row</span><br><span class="line"></span><br><span class="line">when (orow.cno not in (select cno from Course)</span><br><span class="line"></span><br><span class="line">and orow.cno in (select cno from SC))</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">rollback</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h1 id="4-数据库设计："><a href="#4-数据库设计：" class="headerlink" title="4.数据库设计："></a>4.数据库设计：</h1><h2 id="4-1-数据库设计步骤："><a href="#4-1-数据库设计步骤：" class="headerlink" title="4.1 数据库设计步骤："></a>4.1 数据库设计步骤：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608161258687.png" alt="image-20230608161258687"></p>
<h2 id="4-2-概念数据库设计："><a href="#4-2-概念数据库设计：" class="headerlink" title="4.2 概念数据库设计："></a>4.2 概念数据库设计：</h2><p>主要包括模式设计和事务设计。</p>
<p>模式设计以实体为主,产出ER图。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608161741986.png" alt="image-20230608161741986"></p>
<h2 id="4-3-逻辑数据库设计："><a href="#4-3-逻辑数据库设计：" class="headerlink" title="4.3 逻辑数据库设计："></a>4.3 逻辑数据库设计：</h2><p>把概念数据库设计阶段产生的概念数据库模式,变换为逻辑数据库模式.</p>
<p>动态关系至少具有第三规范形式，静态关系至少具有第一规范形式；</p>
<h3 id="4-3-1-关系的转化："><a href="#4-3-1-关系的转化：" class="headerlink" title="4.3.1 关系的转化："></a>4.3.1 关系的转化：</h3><p>一对一：</p>
<p>1.在一中增加另一个一的对应字段。</p>
<p>2.建立一个单独的关系表示（不推荐）</p>
<p>一对多：</p>
<p>1.在多中建立字段表征一.</p>
<p>2.单独建立表.</p>
<p>多对多：</p>
<p>建立中间表。</p>
<h3 id="4-3-2-函数依赖："><a href="#4-3-2-函数依赖：" class="headerlink" title="4.3.2 函数依赖："></a>4.3.2 函数依赖：</h3><p>可以通过属性x确定属性y，则称y依赖于x。</p>
<p>若y不是x的子集，则称为非平凡函数依赖。一般依赖均指非平凡函数依赖。</p>
<h4 id="4-3-2-1-各种其他依赖："><a href="#4-3-2-1-各种其他依赖：" class="headerlink" title="4.3.2.1 各种其他依赖："></a>4.3.2.1 各种其他依赖：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608162748238.png" alt="image-20230608162748238"></p>
<h3 id="4-3-3-范式："><a href="#4-3-3-范式：" class="headerlink" title="4.3.3 范式："></a>4.3.3 范式：</h3><h4 id="4-3-3-1-第一范式（1NF）"><a href="#4-3-3-1-第一范式（1NF）" class="headerlink" title="4.3.3.1 第一范式（1NF）:"></a>4.3.3.1 第一范式（1NF）:</h4><p>设R是一个关系模式。如果R的每个属性的值域都是不可分的简单数据项的集合，则称这个关系模式为第一范式关系模式，记作1NF。</p>
<h4 id="4-3-3-2-第二范式（2NF）"><a href="#4-3-3-2-第二范式（2NF）" class="headerlink" title="4.3.3.2 第二范式（2NF）:"></a>4.3.3.2 第二范式（2NF）:</h4><p>若关系模式R是1NF，而且每一个非键属性都完全函数依赖于R的候选键(码)，则R称为第二范式关系模式，记作2NF。</p>
<p>在满足1NF的前提下，表中不存在部分依赖，非主键列要完全依赖于主键。(主要是说在联合主键的情况下，非主键列不能只依赖于主键的一部分)。</p>
<p>举个例子：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608163330446.png" alt="image-20230608163330446"></p>
<p><strong>缺点</strong>：<br>1·对于查询需要对多个表进行关联，导致性能降低<br>2·更难进行索引优化</p>
<h4 id="4-3-3-3-第三范式（3NF）"><a href="#4-3-3-3-第三范式（3NF）" class="headerlink" title="4.3.3.3 第三范式（3NF）:"></a>4.3.3.3 第三范式（3NF）:</h4><p>不存在传递依赖。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608163435860.png" alt="image-20230608163435860"></p>
<p><img src="C:\Users\wpy\AppData\Roaming\Typora\typora-user-images\image-20230608163900922.png" alt="image-20230608163900922"></p>
<p>设计范式的要求：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608163932353.png" alt="image-20230608163932353"></p>
<h2 id="4-4-物理数据库设计："><a href="#4-4-物理数据库设计：" class="headerlink" title="4.4 物理数据库设计："></a>4.4 物理数据库设计：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608164012741.png" alt="image-20230608164012741"></p>
<h1 id="5-物理存储结构："><a href="#5-物理存储结构：" class="headerlink" title="5. 物理存储结构："></a>5. 物理存储结构：</h1><h2 id="5-1-物理存储设备："><a href="#5-1-物理存储设备：" class="headerlink" title="5.1 物理存储设备："></a>5.1 物理存储设备：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204100360.png" alt="image-20230608204100360"></p>
<h2 id="5-2-磁盘："><a href="#5-2-磁盘：" class="headerlink" title="5.2 磁盘："></a>5.2 磁盘：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204139802.png" alt="image-20230608204139802"></p>
<p>随机存取。</p>
<p>以扇区为单位。</p>
<p>磁盘读写是数据库应用的瓶颈，数据库的物理存储结构、数据库操作算法和查询优化的研究都把最小化磁盘读写次数作为重要目标之一。</p>
<h3 id="5-2-1-缓冲处理："><a href="#5-2-1-缓冲处理：" class="headerlink" title="5.2.1 缓冲处理："></a>5.2.1 缓冲处理：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204309882.png" alt="image-20230608204309882"></p>
<h2 id="5-3-磁盘文件："><a href="#5-3-磁盘文件：" class="headerlink" title="5.3 磁盘文件："></a>5.3 磁盘文件：</h2><h3 id="5-3-1-文件和关系："><a href="#5-3-1-文件和关系：" class="headerlink" title="5.3.1 文件和关系："></a>5.3.1 文件和关系：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204427759.png" alt="image-20230608204427759"></p>
<h3 id="5-3-2-文件记录："><a href="#5-3-2-文件记录：" class="headerlink" title="5.3.2 文件记录："></a>5.3.2 文件记录：</h3><p>主要分为定长记录和边长记录：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204528790.png" alt="image-20230608204528790"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204538995.png" alt="image-20230608204538995"></p>
<h3 id="5-3-3-无序与有序文件："><a href="#5-3-3-无序与有序文件：" class="headerlink" title="5.3.3 无序与有序文件："></a>5.3.3 无序与有序文件：</h3><p>无序文件：查找效率低，增删效率高。</p>
<p>有序文件：查找效率高，插入效率低。</p>
<h2 id="5-4-HASH文件："><a href="#5-4-HASH文件：" class="headerlink" title="5.4 HASH文件："></a>5.4 HASH文件：</h2><p>用Hash函数来存储和存取关系记录。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204843781.png" alt="image-20230608204843781"></p>
<p>简单hash不再赘述。</p>
<p>动态hash：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204916399.png" alt="image-20230608204916399"></p>
<p>可拓展hash：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608204937612.png" alt="image-20230608204937612"></p>
<p>线性hash:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205002640.png" alt="image-20230608205002640"></p>
<h2 id="5-5-索引文件："><a href="#5-5-索引文件：" class="headerlink" title="5.5 索引文件："></a>5.5 索引文件：</h2><p>索引是一种数据结构，通常是有序文件。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205049857.png" alt="image-20230608205049857"></p>
<p>索引文件分类：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205120548.png" alt="image-20230608205120548"></p>
<h3 id="5-5-1主索引："><a href="#5-5-1主索引：" class="headerlink" title="5.5.1主索引："></a>5.5.1主索引：</h3><p>索引域是主键。</p>
<h3 id="5-5-2-聚集索引："><a href="#5-5-2-聚集索引：" class="headerlink" title="5.5.2 聚集索引："></a>5.5.2 聚集索引：</h3><p>排序，一一对应。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205330501.png" alt="image-20230608205330501"></p>
<h3 id="5-5-3-辅助索引："><a href="#5-5-3-辅助索引：" class="headerlink" title="5.5.3 辅助索引："></a>5.5.3 辅助索引：</h3><p>建立在键值之上：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205419798.png" alt="image-20230608205419798"></p>
<h3 id="5-5-4-b＋树索引："><a href="#5-5-4-b＋树索引：" class="headerlink" title="5.5.4 b＋树索引："></a>5.5.4 b＋树索引：</h3><p>定义：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205541287.png" alt="image-20230608205541287"></p>
<p>举例：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205527630.png"></p>
<p>特征：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205627655.png" alt="image-20230608205627655"></p>
<h3 id="5-5-5-多维索引："><a href="#5-5-5-多维索引：" class="headerlink" title="5.5.5 多维索引："></a>5.5.5 多维索引：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205705602.png" alt="image-20230608205705602"></p>
<h1 id="6-查询处理与优化："><a href="#6-查询处理与优化：" class="headerlink" title="6. 查询处理与优化："></a>6. 查询处理与优化：</h1><h2 id="6-1-关系代数操作算法："><a href="#6-1-关系代数操作算法：" class="headerlink" title="6.1 关系代数操作算法："></a>6.1 关系代数操作算法：</h2><p>算法运行环境：</p>
<p>M+1个缓冲区(输入和输出)+外存中存放的数据。</p>
<p>算法运行代价：</p>
<p>磁盘块存取数。</p>
<h3 id="6-1-1-选择操作："><a href="#6-1-1-选择操作：" class="headerlink" title="6.1.1 选择操作："></a>6.1.1 选择操作：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205928006.png" alt="image-20230608205928006"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205935151.png" alt="image-20230608205935151"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608205948344.png" alt="image-20230608205948344"></p>
<h3 id="6-1-2-投影操作："><a href="#6-1-2-投影操作：" class="headerlink" title="6.1.2 投影操作："></a>6.1.2 投影操作：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608210120472.png" alt="image-20230608210120472"></p>
<h3 id="6-1-3-连接操作："><a href="#6-1-3-连接操作：" class="headerlink" title="6.1.3 连接操作："></a>6.1.3 连接操作：</h3><p>三种连接算法：</p>
<h4 id="6-1-3-1-nest-loop-join"><a href="#6-1-3-1-nest-loop-join" class="headerlink" title="6.1.3.1.nest-loop-join:"></a>6.1.3.1.nest-loop-join:</h4><p>循环暴力.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608210512866.png" alt="image-20230608210512866"></p>
<h4 id="6-1-3-2-sort-merge-join"><a href="#6-1-3-2-sort-merge-join" class="headerlink" title="6.1.3.2.sort-merge join:"></a>6.1.3.2.sort-merge join:</h4><p>排序之后匹配。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608210333645.png" alt="image-20230608210333645"></p>
<h4 id="6-1-3-3-hash-join："><a href="#6-1-3-3-hash-join：" class="headerlink" title="6.1.3.3:hash-join："></a>6.1.3.3:hash-join：</h4><p>分别哈希，对比哈希值。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608210408546.png" alt="image-20230608210408546"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608210706403.png" alt="image-20230608210706403"></p>
<h3 id="6-1-4-集合操作："><a href="#6-1-4-集合操作：" class="headerlink" title="6.1.4 集合操作："></a>6.1.4 集合操作：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608210801197.png" alt="image-20230608210801197"></p>
<h2 id="6-2-查询优化："><a href="#6-2-查询优化：" class="headerlink" title="6.2 查询优化："></a>6.2 查询优化：</h2><h3 id="6-2-1-下推选择："><a href="#6-2-1-下推选择：" class="headerlink" title="6.2.1 下推选择："></a>6.2.1 下推选择：</h3><p>当查询中涉及视图时，某些情况下：</p>
<p>首先将选择操作尽可能往树的上部移动是很重要的。然后再把选择下推到所有可能的分枝。</p>
<h3 id="6-2-2-启发式优化："><a href="#6-2-2-启发式优化：" class="headerlink" title="6.2.2 启发式优化："></a>6.2.2 启发式优化：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608211140851.png" alt="image-20230608211140851"></p>
<h3 id="6-2-3-操作代价的估计："><a href="#6-2-3-操作代价的估计：" class="headerlink" title="6.2.3 操作代价的估计："></a>6.2.3 操作代价的估计：</h3><p>由逻辑计划可派生出多个不同物理计划。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608211222742.png" alt="image-20230608211222742"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608211323662.png" alt="image-20230608211323662"></p>
<p>连接条件的结果估计：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608211609026.png" alt="image-20230608211609026"></p>
<h3 id="6-2-4-选择连接顺序："><a href="#6-2-4-选择连接顺序：" class="headerlink" title="6.2.4 选择连接顺序："></a>6.2.4 选择连接顺序：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608211720410.png" alt="image-20230608211720410"></p>
<h3 id="6-2-5-物化与流水化："><a href="#6-2-5-物化与流水化：" class="headerlink" title="6.2.5 物化与流水化："></a>6.2.5 物化与流水化：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608211814583.png" alt="image-20230608211814583"></p>
<h3 id="6-2-6-其他策略："><a href="#6-2-6-其他策略：" class="headerlink" title="6.2.6 其他策略："></a>6.2.6 其他策略：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608212107861.png" alt="image-20230608212107861"></p>
<p>小结：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608212151194.png" alt="image-20230608212151194"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608212159546.png" alt="image-20230608212159546"></p>
<h1 id="7-事务处理与恢复："><a href="#7-事务处理与恢复：" class="headerlink" title="7.事务处理与恢复："></a>7.事务处理与恢复：</h1><h2 id="7-1-事务："><a href="#7-1-事务：" class="headerlink" title="7.1 事务："></a>7.1 事务：</h2><p>是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p>
<p>一个事务由一条或者多条SQL语句组成，一个程序中有一个或者多个事务。</p>
<p>事务是并发控制和恢复的基本单位。</p>
<h2 id="7-2-定义："><a href="#7-2-定义：" class="headerlink" title="7.2 定义："></a>7.2 定义：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608222227468.png" alt="image-20230608222227468"></p>
<h2 id="7-3-特性"><a href="#7-3-特性" class="headerlink" title="7.3 特性:"></a>7.3 特性:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608222324166.png" alt="image-20230608222324166"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608222339616.png" alt="image-20230608222339616"></p>
<h2 id="7-4-并发控制保证"><a href="#7-4-并发控制保证" class="headerlink" title="7.4 并发控制保证:"></a>7.4 并发控制保证:</h2><p>多个事务同时运行时,保证i.</p>
<p>事务在运行过程中被强行停止时,保证ad.</p>
<h2 id="7-5-原理"><a href="#7-5-原理" class="headerlink" title="7.5 原理:"></a>7.5 原理:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608222534196.png" alt="image-20230608222534196"></p>
<h2 id="7-6-事务执行方式"><a href="#7-6-事务执行方式" class="headerlink" title="7.6 事务执行方式:"></a>7.6 事务执行方式:</h2><p>在同一时刻并发运行大量事务时,有多种实现方式.</p>
<h3 id="7-6-1-串行执行"><a href="#7-6-1-串行执行" class="headerlink" title="7.6.1 串行执行:"></a>7.6.1 串行执行:</h3><p>同一时刻只有一个事务在运行.</p>
<p>比较简单,但是不能充分的利用系统资源.</p>
<h3 id="7-6-2-交叉并发"><a href="#7-6-2-交叉并发" class="headerlink" title="7.6.2 交叉并发:"></a>7.6.2 交叉并发:</h3><p>交替执行事务.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608222801329.png" alt="image-20230608222801329"></p>
<h3 id="7-6-3-同时并发"><a href="#7-6-3-同时并发" class="headerlink" title="7.6.3 同时并发:"></a>7.6.3 同时并发:</h3><p>多个处理机同时运行多个事务.</p>
<p>是最理想的并发事务处理方式.</p>
<h2 id="7-7-并发问题以及解决"><a href="#7-7-并发问题以及解决" class="headerlink" title="7.7 并发问题以及解决:"></a>7.7 并发问题以及解决:</h2><h3 id="7-7-1-并发问题"><a href="#7-7-1-并发问题" class="headerlink" title="7.7.1 并发问题:"></a>7.7.1 并发问题:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608222941882.png" alt="image-20230608222941882"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608223016624.png" alt="image-20230608223016624"></p>
<h3 id="7-7-2-事务调度"><a href="#7-7-2-事务调度" class="headerlink" title="7.7.2 事务调度:"></a>7.7.2 事务调度:</h3><h4 id="7-7-2-1-串行调度"><a href="#7-7-2-1-串行调度" class="headerlink" title="7.7.2.1 串行调度."></a>7.7.2.1 串行调度.</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608223057400.png" alt="image-20230608223057400"></p>
<p>是正确的,但是用串行执行一样,存在系统资源利用率不高的问题.</p>
<h4 id="7-7-2-2-可串行化调度"><a href="#7-7-2-2-可串行化调度" class="headerlink" title="7.7.2.2 可串行化调度:"></a>7.7.2.2 可串行化调度:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608223308532.png" alt="image-20230608223308532"></p>
<h4 id="7-7-2-3事务调度的表示方式"><a href="#7-7-2-3事务调度的表示方式" class="headerlink" title="7.7.2.3事务调度的表示方式:"></a>7.7.2.3事务调度的表示方式:</h4><p>r是读,w是写.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608223352663.png" alt="image-20230608223352663"></p>
<h4 id="7-7-2-4-冲突"><a href="#7-7-2-4-冲突" class="headerlink" title="7.7.2.4 冲突:"></a>7.7.2.4 冲突:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608223458648.png" alt="image-20230608223458648"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608223515784.png" alt="image-20230608223515784"></p>
<h4 id="7-7-2-5-冲突可串行化"><a href="#7-7-2-5-冲突可串行化" class="headerlink" title="7.7.2.5 冲突可串行化:"></a>7.7.2.5 冲突可串行化:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608223557281.png" alt="image-20230608223557281"></p>
<p>通过相邻动作的交换,将可串行化调度转换为串行调度.</p>
<h4 id="7-7-2-6-优先图"><a href="#7-7-2-6-优先图" class="headerlink" title="7.7.2.6 优先图:"></a>7.7.2.6 优先图:</h4><p>简单的判断一个调度是否是冲突可串行化的.</p>
<p>节点是事务.</p>
<p>如果调度中存在ti小于tj(按照先后顺序判断),则存在一条由i到j的弧.</p>
<p>简单的判断方法:</p>
<p>1.根据事务的a,b(操作的对象)进行分组</p>
<p>2.按照分组后的顺序,寻找r-w,w-r,w-w,如果找到后所对应的数字不同,则存在一条弧.</p>
<p>如果画完了有环，则是非冲突可串行化，就是有冲突，但是不能串行化的。</p>
<h2 id="7-8-并发控制协议"><a href="#7-8-并发控制协议" class="headerlink" title="7.8 并发控制协议:"></a>7.8 并发控制协议:</h2><h3 id="7-8-1-锁"><a href="#7-8-1-锁" class="headerlink" title="7.8.1 锁:"></a>7.8.1 锁:</h3><p>锁是数据库元素上的并发控制标志.</p>
<p>每个事务在存取一个数据库元素之前必须获得这个数据库元素上的锁.</p>
<p>一个事务需要获得的锁的类型依赖于它将在数据库元素上执行什么样的操作.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225106550.png" alt="image-20230608225106550"></p>
<h3 id="7-8-2-两阶段锁协议"><a href="#7-8-2-两阶段锁协议" class="headerlink" title="7.8.2 两阶段锁协议:"></a>7.8.2 两阶段锁协议:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225149660.png" alt="image-20230608225149660"></p>
<h3 id="7-8-3-时间戳协议"><a href="#7-8-3-时间戳协议" class="headerlink" title="7.8.3 时间戳协议:"></a>7.8.3 时间戳协议:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225232710.png" alt="image-20230608225232710"></p>
<h1 id="8-故障恢复"><a href="#8-故障恢复" class="headerlink" title="8. 故障恢复:"></a>8. 故障恢复:</h1><h2 id="8-1-数据库恢复"><a href="#8-1-数据库恢复" class="headerlink" title="8.1 数据库恢复:"></a>8.1 数据库恢复:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225328329.png" alt="image-20230608225328329"></p>
<h2 id="8-2-故障种类以及恢复"><a href="#8-2-故障种类以及恢复" class="headerlink" title="8.2 故障种类以及恢复:"></a>8.2 故障种类以及恢复:</h2><h3 id="8-2-1-介质故障"><a href="#8-2-1-介质故障" class="headerlink" title="8.2.1 介质故障:"></a>8.2.1 介质故障:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225436023.png" alt="image-20230608225436023"></p>
<h3 id="8-2-2-系统故障"><a href="#8-2-2-系统故障" class="headerlink" title="8.2.2 系统故障:"></a>8.2.2 系统故障:</h3><p>撤销或者重做.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225515445.png" alt="image-20230608225515445"></p>
<h3 id="8-2-3-事务故障"><a href="#8-2-3-事务故障" class="headerlink" title="8.2.3 事务故障:"></a>8.2.3 事务故障:</h3><p>撤销事务,强行回滚.</p>
<h2 id="8-3-数据库恢复"><a href="#8-3-数据库恢复" class="headerlink" title="8.3 数据库恢复:"></a>8.3 数据库恢复:</h2><p>恢复整个数据库文件.</p>
<h3 id="8-3-1-基于日志的恢复"><a href="#8-3-1-基于日志的恢复" class="headerlink" title="8.3.1 基于日志的恢复:"></a>8.3.1 基于日志的恢复:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225712126.png" alt="image-20230608225712126"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225725435.png" alt="image-20230608225725435"></p>
<h4 id="8-3-1-1-日志缓冲技术"><a href="#8-3-1-1-日志缓冲技术" class="headerlink" title="8.3.1.1 日志缓冲技术:"></a>8.3.1.1 日志缓冲技术:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225810128.png" alt="image-20230608225810128"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608225820534.png" alt="image-20230608225820534"></p>
<h4 id="8-3-1-2-更新技术"><a href="#8-3-1-2-更新技术" class="headerlink" title="8.3.1.2 更新技术:"></a>8.3.1.2 更新技术:</h4><p>推迟更新:</p>
<p>在一个事务所有更新操作对应的日志记录写入</p>
<p>永久存储器之前，该事务不能提交.</p>
<p>事务在不能提交之前,不能提交数据库.</p>
<p>恢复时;</p>
<p>从后往前开始扫描日志，建立两个事务表</p>
<p>提交事务表：已经提交的，且磁盘上有日志记录&lt;COMMIT *T*&gt;的所有事务</p>
<p>未提交事务表：那些具有&lt; START *T*&gt;日志记录，但无对应 &lt; COMMIT *T*&gt;的所有事务</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608230133195.png" alt="image-20230608230133195"></p>
<p>及时更新：</p>
<p>事务直接提交数据库。</p>
<h4 id="8-3-1-3-检查点恢复："><a href="#8-3-1-3-检查点恢复：" class="headerlink" title="8.3.1.3 检查点恢复："></a>8.3.1.3 检查点恢复：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608230326792.png" alt="image-20230608230326792"></p>
<h3 id="8-3-2-基于冗余存储的恢复："><a href="#8-3-2-基于冗余存储的恢复：" class="headerlink" title="8.3.2 基于冗余存储的恢复："></a>8.3.2 基于冗余存储的恢复：</h3><p>主从复制.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230608230415065.png" alt="image-20230608230415065"></p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论:"></a>1.绪论:</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1. 1 定义:"></a>1. 1 定义:</h2><p><strong>数据</strong>是对信息的一种符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称。</p>
<p>数据结构十数据对象在计算机中的组织方式.<strong>数据结构</strong>是一个二元组 Data_Structure ＝（D，R），其中，D 是数据元素的有限集，R 是 D 上关系的有限集。</p>
<h2 id="1-2-逻辑结构与存储结构"><a href="#1-2-逻辑结构与存储结构" class="headerlink" title="1.2 逻辑结构与存储结构:"></a>1.2 逻辑结构与存储结构:</h2><p>逻辑结构是指数据间的相互关系.通常分为四类结构:线性结构,集合,树,图或网.(还有什么有序表之类的)</p>
<p><strong>存储结构</strong>是指数据结构在计算机中的表示，又称为数据的物理结构。通常由四种基本的存储方法实现：</p>
<p>（1）顺序存储方式</p>
<p>（2）链式存储方式</p>
<p>（3）索引存储方式</p>
<p>（4）散列存储方式</p>
<h2 id="1-3-算法复杂度"><a href="#1-3-算法复杂度" class="headerlink" title="1.3 算法复杂度:"></a>1.3 算法复杂度:</h2><p>主要分为时间复杂度和空间复杂度.</p>
<h3 id="1-3-1-空间复杂度"><a href="#1-3-1-空间复杂度" class="headerlink" title="1.3.1 空间复杂度:"></a>1.3.1 空间复杂度:</h3><p>空间复杂度是指执行程序时,额外占用的存储空间的大小.</p>
<h3 id="1-3-2-时间复杂度"><a href="#1-3-2-时间复杂度" class="headerlink" title="1.3.2 时间复杂度:"></a>1.3.2 时间复杂度:</h3><p>时间复杂度是指执行程序时,占用时间的大小.</p>
<p>时间复杂度只与待解决问题的规模(n)有关,与一步基本操作的工作量无关.</p>
<p>时间复杂度只考虑问题的宏观渐进性,意识是求解的难度随着问题规模的增大逐渐增大的趋势.如线性增长(o(n)).</p>
<h3 id="1-3-3-算法特性"><a href="#1-3-3-算法特性" class="headerlink" title="1.3.3 算法特性:"></a>1.3.3 算法特性:</h3><p>输入.输出.有穷性.确定性.可行性.</p>
<h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表:"></a>2.线性表:</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义:"></a>2.1 定义:</h2><p>线性表是n个相同类型的数据元素组成的有限序列.是最简单的.最基础的数据结构(逻辑结构).线性表包括顺序表(数组)和链表.</p>
<h2 id="2-2-特征"><a href="#2-2-特征" class="headerlink" title="2.2 特征:"></a>2.2 特征:</h2><p>线性表的第一个元素叫第一元素,最后一个元素是最后元素,中间元素的上一个元素叫前驱,后一个元素叫后继.</p>
<h2 id="2-3-顺序表基本运算的复杂度"><a href="#2-3-顺序表基本运算的复杂度" class="headerlink" title="2.3 顺序表基本运算的复杂度:"></a>2.3 顺序表基本运算的复杂度:</h2><p>插入,删除都是o(n).</p>
<h2 id="2-4-顺序表优缺点"><a href="#2-4-顺序表优缺点" class="headerlink" title="2.4 顺序表优缺点:"></a>2.4 顺序表优缺点:</h2><p>优点: 节省空间,查找元素第i个元素比较简单(头+元素大小✖i)</p>
<p>缺点:插入.删除都需要移动数据.比较不容易确定存储空间.</p>
<h2 id="2-5-链表"><a href="#2-5-链表" class="headerlink" title="2.5 链表:"></a>2.5 链表:</h2><h3 id="2-5-1-头结点"><a href="#2-5-1-头结点" class="headerlink" title="2.5.1: 头结点:"></a>2.5.1: 头结点:</h3><p>头结点不存储数据.指针指向第一个节点.</p>
<p>头插法:读入的数据元素的顺序与生成的链表中元素的顺序是相反的。</p>
<p>尾插法读入的数据元素的顺序与生成的链表中元素的顺序是一致的。</p>
<h1 id="3-栈和队列"><a href="#3-栈和队列" class="headerlink" title="3.栈和队列:"></a>3.栈和队列:</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义:"></a>3.1 定义:</h2><p>栈和队列是一种特殊的线性表.先进后出为栈,先进先出为队列.</p>
<h2 id="3-2-栈"><a href="#3-2-栈" class="headerlink" title="3.2 栈:"></a>3.2 栈:</h2><p>插入和删除均在特定的一端进行.</p>
<p>最先进入的一端叫栈底,进行操作的一端叫栈顶.入栈成为Push,出栈称为Pop.</p>
<p>栈的一种定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define STACK_INIT_SIZE 100</span><br><span class="line"></span><br><span class="line">#define STACKINCREMENT 10</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> SElemType *base;</span><br><span class="line"></span><br><span class="line">SElemType *top;</span><br><span class="line"></span><br><span class="line">int stacksize;</span><br><span class="line"></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p>top指针表示栈顶，入栈时，top指针存入数据后移动，成为新的栈顶。出栈时，top指针回退。</p>
<h2 id="3-3-队列："><a href="#3-3-队列：" class="headerlink" title="3.3 队列："></a>3.3 队列：</h2><p>一种先进先出的线性表。</p>
<p>入队的地方称为队尾，出队的地方称为队头，队尾指针rear,队头指针front。</p>
<h1 id="4-串"><a href="#4-串" class="headerlink" title="4.串:"></a>4.串:</h1><h1 id="5-数组和广义表："><a href="#5-数组和广义表：" class="headerlink" title="5.数组和广义表："></a>5.数组和广义表：</h1><h1 id="6-树："><a href="#6-树：" class="headerlink" title="6.树："></a>6.树：</h1><h1 id="7-图："><a href="#7-图：" class="headerlink" title="7.图："></a>7.图：</h1><h2 id="7-1-定义："><a href="#7-1-定义：" class="headerlink" title="7.1 定义："></a>7.1 定义：</h2><p>由点的集合和边的集合构成的集合，任意两个结点之间都可能相关，即结点之间的邻接关系可以是任意的。</p>
<h2 id="7-2-图的相关术语："><a href="#7-2-图的相关术语：" class="headerlink" title="7.2 图的相关术语："></a>7.2 图的相关术语：</h2><p>度：节点的边数。入读是指向该节点的边数，出度是从该节点出发的边数。</p>
<p>强连通图：任意两点之间都联通的图</p>
<p>路径、路径长度：顶点 vp到顶点 vq之间的路径是指顶点序列 vp,vi1,vi2, …, vim,vq.。路径上边的数目称为路径长度。</p>
<h2 id="7-3-图的存储："><a href="#7-3-图的存储：" class="headerlink" title="7.3 图的存储："></a>7.3 图的存储：</h2><h3 id="7-3-1-邻接矩阵："><a href="#7-3-1-邻接矩阵：" class="headerlink" title="7.3.1 邻接矩阵："></a>7.3.1 邻接矩阵：</h3><h3 id="7-3-2-邻接表："><a href="#7-3-2-邻接表：" class="headerlink" title="7.3.2 邻接表："></a>7.3.2 邻接表：</h3><p>是图的一种顺序存储与链式存储结合的存储方法，类似于树的孩子链表表示法。就是对于图 G 中的每个顶点 vi，将所有邻接于 vi的顶点 vj链成一个单链表，这个单链表就称为顶点 vi的邻接表，再将所有点的邻接表表头放到数组中，就构成了图的邻接表。</p>
<p>在邻接表中，每条边都会出现两次，如果是n个顶点，e条边的邻接表，总共需要n个头节点和2e个表节点，比较适合存储比较稀疏的图。</p>
<h2 id="7-4：图的遍历："><a href="#7-4：图的遍历：" class="headerlink" title="7.4：图的遍历："></a>7.4：图的遍历：</h2><p>从图的某一个顶点出发，访问所有的顶点。</p>
<h3 id="7-4-1-深度优先搜索："><a href="#7-4-1-深度优先搜索：" class="headerlink" title="7.4.1 深度优先搜索："></a>7.4.1 深度优先搜索：</h3><p>从某一个顶点开始，访问一个顶点后，接着访问与这个顶点相邻的，未被访问过的顶点，直到所有的顶点都被访问过为止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void DFS(Graph G,int v ) /*从第 v 个顶点出发递归地深度优先遍历图 G*/</span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">visited[v]=TRUE;Visit(v); /*访问第 v 个顶点*/</span><br><span class="line"></span><br><span class="line">for(w=FisrtAdjVex(G,v);w&gt;=0; w=NextAdjVex(G,v,w))</span><br><span class="line"></span><br><span class="line">if (!visited[w]) DFS(G,w); /*对 v 的尚未访问的邻接顶点 w 递归调用 DFS*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间则取决于所采用的存储结构。当以邻接矩阵为图的存储结构时，查找每个顶点的邻接点所需时间为O(n2 ) ，其中 n 为图中顶点数。而当以邻接表作图的存储结构时，找邻接点所需时间为 O(e)，其中e 为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为 O(n+e) 。</p>
<h3 id="7-4-2-广度优先搜索："><a href="#7-4-2-广度优先搜索：" class="headerlink" title="7.4.2: 广度优先搜索："></a>7.4.2: 广度优先搜索：</h3><p>从某一个顶点开始，先访问该顶点，再访问与该顶点相邻的所有未访问过的顶点，然后在对这些邻接顶点的邻接顶点做相同的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void BFS (Graph G,int v)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">InitQueue(Q); /*置空的辅助队列 Q*/</span><br><span class="line"></span><br><span class="line">visited[v]=TRUE; Visit(v); /*访问 v*/</span><br><span class="line"></span><br><span class="line">EnQueue(Q,v); /*v 入队列*/</span><br><span class="line"></span><br><span class="line">while (!QueueEmpty(Q)) </span><br><span class="line"></span><br><span class="line">&#123;DeQueue(Q,u); /*队头元素出队并置为 u*/</span><br><span class="line"></span><br><span class="line">for(w=FistAdjVex(G,u); w&gt;=0; w=NextAdjVex(G,u,w))</span><br><span class="line"></span><br><span class="line">if(!visited[w])</span><br><span class="line"></span><br><span class="line">&#123;visited[w]=TRUE; Visit(w);</span><br><span class="line"></span><br><span class="line"> EnQueue(Q,w); /*u 尚未访问的邻接顶点 w 入队列 Q*/</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">注意入队列的顺序，先入队列的点先出队列进行的下一步的bfs，可能会影响遍历顺序。</span><br></pre></td></tr></table></figure>

<p>广度优先搜索遍历图的过程实质是通过边或弧找邻接点的过程，其时间复杂度和深度优先搜索遍历相同，两者不同之处仅仅在于对顶点访问的顺序不同。</p>
<h2 id="7-5-最小生成树："><a href="#7-5-最小生成树：" class="headerlink" title="7.5 最小生成树："></a>7.5 最小生成树：</h2><p><strong>生成树：</strong>所谓连通图 G 的生成树，是 G 的包含其全部 n 个顶点的一个极小连通子图。它必定包含且仅包含 G 的 n-1 条边。</p>
<p>最小生成树是指在图的所有生成树中，边权和最小的树。</p>
<p>下面给出两种求最小生成数的算法。</p>
<h3 id="7-5-1：Prim算法："><a href="#7-5-1：Prim算法：" class="headerlink" title="7.5.1：Prim算法："></a>7.5.1：Prim算法：</h3><p>建立u，v(所有顶点集合)，t三个集合。任选一个顶点开始。把该顶点加入u，寻找一条边，这条边的两个顶点一个在u中，一个在v-u中，而且这条边的权值在符合所有的边中最小，把v-u中的那个点加入u，把这条边加入t，反复进行操作，知道u中包括了所有的顶点为止。</p>
<p>时间复杂度o（n2）(邻接矩阵)o(n+e)(邻接表)，比较适合于边稠密的网。</p>
<h3 id="7-5-2-Kruskal-算法"><a href="#7-5-2-Kruskal-算法" class="headerlink" title="7.5.2:  Kruskal 算法:"></a>7.5.2:  Kruskal 算法:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Kruskal (G,T)&#123;</span><br><span class="line">T=V;</span><br><span class="line">ncomp=N;</span><br><span class="line">while（ncomp&gt;1）</span><br><span class="line">&#123;</span><br><span class="line">	从G中找到取出并删除权值最小的边，记为x.</span><br><span class="line">	if(x的两个顶点在T中并没有相连相连)</span><br><span class="line">	&#123;</span><br><span class="line">		把这条边加入t；</span><br><span class="line">		ncomp--；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度o（enlog2e）比较适合边稀疏的网。</p>
<h2 id="7-6：最短路径："><a href="#7-6：最短路径：" class="headerlink" title="7.6：最短路径："></a>7.6：最短路径：</h2><h3 id="7-6-1-单源最短路："><a href="#7-6-1-单源最短路：" class="headerlink" title="7.6.1:单源最短路："></a>7.6.1:单源最短路：</h3><p>给定有向图g和源点v，求该点到所有顶点的最短距离。</p>
<p>Dijkstra 算法:</p>
<p>s是已经求出最短路的集合,v-s是未求出最短路的集合.</p>
<p>首先把顶点加入s,把与v最近的v1也加入s.</p>
<p>然后在v-s中寻找vx到vo与vx到v1,遍历找最短的加入s.</p>
<p>依次进行操作.</p>
<p>时间复杂度是 O(n 2 ).</p>
<h3 id="7-6-2-多源最短路"><a href="#7-6-2-多源最短路" class="headerlink" title="7.6.2: 多源最短路:"></a>7.6.2: 多源最短路:</h3><p>从 Vi到 Vj的所有可能存在的路径中，选出一条长度最短的路径。时间复杂度是 O(n 3 ).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(int k = 0 ; k &lt; size ; k ++)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i = 0 ; i &lt; size ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 0 ; j &lt; size ; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(zu[i][j] &gt; zu[i][k] + zu[k][j])&#123;</span><br><span class="line">            	zu[i][j] = zu[i][k] + zu[k][j];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	 </span><br></pre></td></tr></table></figure>

<h2 id="7-7-拓扑排序"><a href="#7-7-拓扑排序" class="headerlink" title="7.7: 拓扑排序:"></a>7.7: 拓扑排序:</h2><h3 id="7-7-1-AOE网"><a href="#7-7-1-AOE网" class="headerlink" title="7.7.1: AOE网:"></a>7.7.1: AOE网:</h3><p>是一张有向无环图.</p>
<p>顶点表示事件,边表示事件.</p>
<p>拓扑序列:如果存在vi到vj的路径,则在这个序列中i位于j之前.有向图的序列不唯一,无环图一定有拓扑序列,有环图一定没有拓扑序列.</p>
<p>算法:</p>
<p>(1)选图中入度为0的顶点输出.</p>
<p>(2)删除该顶点以及预期相连的所有边.</p>
<p>(3)重复进行 直到所以的顶点都被输出.</p>
<p>整个算法的时间复杂度 为 O（e+n）。<strong>拓扑排序的序列可能不唯一。</strong> </p>
<h3 id="7-7-2-关键路径"><a href="#7-7-2-关键路径" class="headerlink" title="7.7.2: 关键路径:"></a>7.7.2: 关键路径:</h3><p>首先要搞清楚几个概念:</p>
<h4 id="7-7-2-1-事件的最早发生时间"><a href="#7-7-2-1-事件的最早发生时间" class="headerlink" title="7.7.2.1:事件的最早发生时间:"></a>7.7.2.1:事件的最早发生时间:</h4><p>记为ve[k]</p>
<p>是从原点到发生事件的点的最长的路径长度.(含义是这个事件要在前面所有的事件都结束了之后这个事件才能就开始,所以所需要时间最长的活动为制约条件)</p>
<h4 id="7-7-2-2-事件的最晚发生时间"><a href="#7-7-2-2-事件的最晚发生时间" class="headerlink" title="7.7.2.2:事件的最晚发生时间:"></a>7.7.2.2:事件的最晚发生时间:</h4><p>记为vl[k]</p>
<p>开始节点为0,汇点为其最早开始时间.对于其他节点,从汇点开始减去其到上一个顶点的路径长度.</p>
<h4 id="7-7-2-3-活动的最晚发生时间"><a href="#7-7-2-3-活动的最晚发生时间" class="headerlink" title="7.7.2.3:活动的最晚发生时间:"></a>7.7.2.3:活动的最晚发生时间:</h4><p>事件最晚时间减去活动边.</p>
<h4 id="7-7-2-2-活动的最早发生时间"><a href="#7-7-2-2-活动的最早发生时间" class="headerlink" title="7.7.2.2:活动的最早发生时间:"></a>7.7.2.2:活动的最早发生时间:</h4><p>就是活动源头一侧的时间的最早发生时间.</p>
<p>活动的最早和最晚开始时间相同的活动就是关键活动.由关键活动组成的路径被称为关键路径.</p>
<p>整个工程完成的时间为：从有向图的<strong>源点</strong>到<strong>汇点</strong>的最长路径。</p>
<h1 id="8-查找"><a href="#8-查找" class="headerlink" title="8.查找:"></a>8.查找:</h1><h2 id="8-1-顺序查找"><a href="#8-1-顺序查找" class="headerlink" title="8.1: 顺序查找:"></a>8.1: 顺序查找:</h2><p>第一个元素向后,依次顺序查找.</p>
<h2 id="8-2-折半查找"><a href="#8-2-折半查找" class="headerlink" title="8.2: 折半查找:"></a>8.2: 折半查找:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Search_Bin (SSTable ST, KeyType key ) </span><br><span class="line"></span><br><span class="line">&#123;low = 1; high = ST.length; /*置区间初值*/</span><br><span class="line"></span><br><span class="line">while(low &lt;= high)</span><br><span class="line"></span><br><span class="line"> &#123;mid=(low + high)/2;</span><br><span class="line"></span><br><span class="line"> if（</span><br><span class="line"></span><br><span class="line">key == ST.elem[mid].key )</span><br><span class="line"></span><br><span class="line"> return mid; /*找到待查元素*/</span><br><span class="line"></span><br><span class="line"> else if(key&lt;ST.elem[mid].key) )</span><br><span class="line"></span><br><span class="line"> high = mid - 1; /*继续在前半区间进行查找*/</span><br><span class="line"></span><br><span class="line"> else low = mid + 1;/*继续在后半区间进行查找*/</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0; /*顺序表中不存在待查元素*/</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求数据顺序存储 且有序。</p>
<p>o（logn）</p>
<h2 id="8-3：索引查找："><a href="#8-3：索引查找：" class="headerlink" title="8.3：索引查找："></a>8.3：索引查找：</h2><p>①查找表要求顺序存储；②查找表分成 n 块，当 i&gt;j 时，第 i 块中的最小元素大于第 j 块中的最大元素。</p>
<p>过程：①首先确定所要查找关键字在哪一块中。②在所确定的块中用顺序查找查找关键字。</p>
<p>平均查找长度n+l+2➗2 其中l是每块长度 n是总长度  若要使平均次数最小 每块的长度是根号n</p>
<h2 id="8-4：-监视哨："><a href="#8-4：-监视哨：" class="headerlink" title="8.4： 监视哨："></a>8.4： 监视哨：</h2><p>不是带查找元素，是人为构造的一个数据，放在特定的位置，用来处理数组越界等情况。所以有监视哨的表，查询的元素要比待查元素多一个（失败时）成功就不需要了。</p>
<h2 id="8-4：二叉排序树："><a href="#8-4：二叉排序树：" class="headerlink" title="8.4：二叉排序树："></a>8.4：二叉排序树：</h2><h3 id="8-4-1：-静态查找表与动态查找表："><a href="#8-4-1：-静态查找表与动态查找表：" class="headerlink" title="8.4.1： 静态查找表与动态查找表："></a>8.4.1： 静态查找表与动态查找表：</h3><p>动态查找表：有时在查询之后，还需要将“查询”结果为“不在查找表中”的数据元素插入到查找表中；或者，从查找表中删除其“查询”结果为“在查找表中”的数据元素。</p>
<h3 id="8-4-2：-定义："><a href="#8-4-2：-定义：" class="headerlink" title="8.4.2： 定义："></a>8.4.2： 定义：</h3><p>空树或者对于所有的子树都有：左子树＜根节点＜右子树</p>
<p>查找时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BSTree SearchBST(BiTree bt, KeyType key)/*在根指针 bt 所指二叉排序树中，递归查</span><br><span class="line">找某关键字等于 key 的元素，若查找成功，则返回指向该元素结点指针，否则返回空指针 */</span><br><span class="line">&#123;if(!bt) return NULL; </span><br><span class="line"></span><br><span class="line">else if(bt-&gt;key==key) return bt; /*查找成功*/ </span><br><span class="line"></span><br><span class="line">else if(key＜bt-&gt;key)</span><br><span class="line"></span><br><span class="line">return SearchBST(bt-&gt;lchild,key); /*在左子树中继续查找*/</span><br><span class="line"></span><br><span class="line"> else return SearchBST(bt-&gt;rchild, key); /*在右子树中继续查找*/</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="8-5：平衡二叉树："><a href="#8-5：平衡二叉树：" class="headerlink" title="8.5：平衡二叉树："></a>8.5：平衡二叉树：</h2><p>或者是一棵空树，或者是具有下列性质的二叉排序树：它的左子树和右子树都是平衡二叉树，且左子树和右子树高度之差的绝对值不超过 1。</p>
<p>在插入过程中，采用平衡旋转技术：左单旋转；右单旋转；先左后右双向旋转；先右后左双向旋转。</p>
<p>在平衡树上进行查找的过程和二叉排序树相同，因此，查找过程中和给定值进行比较的关键字的个数不超过平衡 树的深度，和 log2n 相当。</p>
<h2 id="8-6：哈希表："><a href="#8-6：哈希表：" class="headerlink" title="8.6：哈希表："></a>8.6：哈希表：</h2><p>基本思想是首先在元素的关键字 key 和元素的存储位置 p 之间建立一个对应关系 H，使得 p&#x3D;H(key)，H 称为散列函数。创建散列表时，把关键字为 key 的元素直接存入地址为 H(key)的单元；以后当查找关键字为 key 的元素时，再利用散列函数计算出该元素的存储位置 p&#x3D;H(key)，从而达到按关键字直接存取元素的目的。</p>
<p>装填因子：</p>
<p>a&#x3D;填入结点数&#x2F;空间大小</p>
<p>①直接定址法：H(key) &#x3D; a  key + b</p>
<p>适合于：地址集合的大小 &#x3D; &#x3D; 关键字集合的大小</p>
<p>⑤除留余数法：H(key) &#x3D; key MOD p ，其中 p≤m (表长)并且 p 应为不大于 m 的素数</p>
<h3 id="8-6-2：-解决冲突方法："><a href="#8-6-2：-解决冲突方法：" class="headerlink" title="8.6.2： 解决冲突方法："></a>8.6.2： 解决冲突方法：</h3><p>①开放定址法：当关键字 key 的散列地址 p&#x3D; H（key）出现冲突时，以 p 为基础，产生另一</p>
<p>个散列地址 p1，如果 p1仍然冲突，再以 p 为基础，产生另一个散列地址 p2，……，直到找</p>
<p>出一个不冲突的散列地址 pi，将相应元素存入其中。</p>
<p>主要有以下三种：</p>
<p>●线性探测再散列 </p>
<p>di&#x3D;1，2，3，…:， m-1</p>
<p>特点：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<p>●二次探测再散列 </p>
<p>di&#x3D;±1 2，±2 2，…，±k 2 (k≤m&#x2F;2)</p>
<p>特点：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<p>●伪随机探测再散列 </p>
<p>di&#x3D;伪随机数序列。</p>
<p>②链地址法：将所有散列地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的</p>
<p>头指针存在散列表的第 i 个单元中，因而查找、插入和删除主要在同义词链中进行。 链地</p>
<p>址法适用于经常进行插入和删除的情况。</p>
<p>平均查找长度与a（装填因子）和处理冲突的方法有关，与问题的规模无关。</p>
<h1 id="9-排序："><a href="#9-排序：" class="headerlink" title="9.排序："></a>9.排序：</h1><p>排序的基本操作使比较数据和移动数据。</p>
<h2 id="9-1：-内部排序与外部排序："><a href="#9-1：-内部排序与外部排序：" class="headerlink" title="9.1： 内部排序与外部排序："></a>9.1： 内部排序与外部排序：</h2><p>只使用内存的排序称之为内部排序，需要借助计算机外存的排序称为外部排序，外部排序的主要影响因素是内外存之间的交换次数。</p>
<h2 id="9-2：插入排序："><a href="#9-2：插入排序：" class="headerlink" title="9.2：插入排序："></a>9.2：插入排序：</h2><p>将第一个元素看作是有序。第一趟使前两个元素有序，第二趟使前三个元素有序．．．．直到第n-１趟，使整体有序。</p>
<p>是稳定排序。（排序中存在相同关键字时，其相对位置保持不变）ｏ（ｎ２）.</p>
<h2 id="9-３：折半插入排序："><a href="#9-３：折半插入排序：" class="headerlink" title="9.３：折半插入排序："></a>9.３：折半插入排序：</h2><p>在插入排序的基础上，使用折半搜索的思想进行插入。</p>
<h2 id="9-４：希尔排序："><a href="#9-４：希尔排序：" class="headerlink" title="9.４：希尔排序："></a>9.４：希尔排序：</h2><p>先将序列分为子序列，然后将子序列分别进行插入排序。</p>
<h2 id="9-５：冒泡排序："><a href="#9-５：冒泡排序：" class="headerlink" title="9.５：冒泡排序："></a>9.５：冒泡排序：</h2><p>在有序时比较过一次之后直接结束，比较快。</p>
<h2 id="9-６：快速排序："><a href="#9-６：快速排序：" class="headerlink" title="9.６：快速排序："></a>9.６：快速排序：</h2><p>找一个记录作为轴，小于的放在轴前，大于的放在轴后，然后对形成的子序列分别递归使用快速排序。</p>
<p>左右指针移动。</p>
<p>数据有序时会发生退化o(n2),平均分成两部分时效率最高。</p>
<h2 id="9-７：选择排序："><a href="#9-７：选择排序：" class="headerlink" title="9.７：选择排序："></a>9.７：选择排序：</h2><h2 id="9-８：堆排序："><a href="#9-８：堆排序：" class="headerlink" title="9.８：堆排序："></a>9.８：堆排序：</h2><p>建立堆，取走堆顶元素，重新建立堆，不断循环。</p>
<p>找出10000个元素中最大的十个元素最快的方法就是使用堆排序。</p>
<h2 id="9-9-归并排序："><a href="#9-9-归并排序：" class="headerlink" title="9.9: 归并排序："></a>9.9: 归并排序：</h2><p>消耗辅助空间最多的排序。稳定。</p>
<p>将两个以上的有序序列合并成一个有序序列。</p>
<p>o（nlogn）</p>
<p>合并时最多需要移动m+n-1（两个序列的个数）次</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>有匪</title>
    <url>/2023/06/04/%E6%9C%89%E5%8C%AA/</url>
    <content><![CDATA[<p>title出自《诗经·国风·淇奥》：</p>
<p>“有匪君子，如切如磋，如琢如磨” </p>
<p>“有匪君子，终不可谖兮” （欺骗）</p>
<p>匪通斐.一语双关，用典的同时暗示小说主人公的身份。</p>
<h5 id="有斐君子"><a href="#有斐君子" class="headerlink" title="有斐君子"></a>有斐君子</h5><p>周易·革卦：</p>
<p>大人之变，其文炳也，君子豹变，其文蔚也。</p>
<p>君子像豹子和老虎一样，出生非常的丑陋，但是经过自己的努力修养，最终矫健而美丽，就像成年的虎豹一样。</p>
<p>歌词来自王子健《山间有歌》：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“致我心上的谁 谁渡百转千回”</span><br><span class="line">“致我心疼的谁 谁还在被风吹”</span><br><span class="line">“致我心碎的谁 谁又闯进我心扉”</span><br></pre></td></tr></table></figure>



<p>表征人物性格</p>
<p>主角</p>
<h2 id="1-望春"><a href="#1-望春" class="headerlink" title="1.望春"></a>1.望春</h2><p>《离恨楼》</p>
<p>洗墨江初遇</p>
<p>启程 </p>
<p>石洞 白骨 梁先生 折返而归</p>
<h2 id="2-碎遮"><a href="#2-碎遮" class="headerlink" title="2.碎遮"></a>2.碎遮</h2><p>华容城中</p>
<p>客栈惊变 分别</p>
<p>出逃 城门汇合</p>
<p>客栈 青龙 殷沛第一次出现</p>
<h2 id="3-熹微"><a href="#3-熹微" class="headerlink" title="3.熹微"></a>3.熹微</h2><p>《寒鸦声》</p>
<h2 id="4-幽篁"><a href="#4-幽篁" class="headerlink" title="4.幽篁"></a>4.幽篁</h2><p>《白骨传》</p>
<p>次选：</p>
<p>1.故事大纲设计：</p>
<p>矛盾引入，海天一色，任务驱动型</p>
<p>2.配角设计：</p>
<p>殷沛</p>
<p>李晟，李妍</p>
<p>3.语言表达设计:</p>
<p>含蓄的倒装语法.</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>评论</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器部署</title>
    <url>/2023/02/10/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="服务器部署教程"><a href="#服务器部署教程" class="headerlink" title="服务器部署教程"></a>服务器部署教程</h1><p>均需要连接校园网</p>
<p>服务器连接信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址: 10.245.150.220</span><br><span class="line"></span><br><span class="line">端口: 22</span><br><span class="line"></span><br><span class="line">账户: root</span><br><span class="line"></span><br><span class="line">密码: werun_4321</span><br></pre></td></tr></table></figure>



<p>数据库连接信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址: 10.245.150.219</span><br><span class="line"></span><br><span class="line">端口: 3306</span><br><span class="line"></span><br><span class="line">账户: root</span><br><span class="line"></span><br><span class="line">密码: TJ4u5&amp;CT8czz$2B%</span><br></pre></td></tr></table></figure>

<p>1.修改自己的数据库配置。</p>
<p>我们需要把自己的项目部署到服务器上，数据库也不能用我们本地的数据库，所以首先我们要修改数据库配置。</p>
<p>以jpa为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">  username: root</span><br><span class="line">  password: TJ4u5&amp;CT8czz$2B%</span><br><span class="line">  url: jdbc:mysql://10.245.150.219:3306/你的小组名（小组1就写group1，以此类推）?useUnicode=true&amp;characterEncoding=UTF8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址: 10.245.150.219</span><br><span class="line"></span><br><span class="line">端口: 3306</span><br><span class="line"></span><br><span class="line">账户: root</span><br><span class="line"></span><br><span class="line">密码: TJ4u5&amp;CT8czz$2B%</span><br></pre></td></tr></table></figure>

<p>如果使用mybatis也需要上面的配置连接上数据库并建表.</p>
<p>2.把自己的项目打包成jar包</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230423140224.png" alt="QQ截图20230423140224"></p>
<p>右侧的maven 先clean再package.</p>
<p>然后在target目录下找到项目名.jar这个文件。</p>
<p>找到就算是打包成功了。</p>
<p>2.把自己的jar包上传到服务器上。</p>
<p>服务器的文件结构如图：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230423223238.png" alt="QQ截图20230423223238"></p>
<p>按照小组名把对应的jar包上传到对应的文件夹下。</p>
<p>完成这一步建议使用xftp.大家可以去搜一下这东西的使用方法。</p>
<p>3.用xshell连接服务器，进入自己的小组下面，启动项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar jar包名.jar</span><br></pre></td></tr></table></figure>

<p>看到控制台出现跟平常项目一样的堆栈信息就是启动成功了。</p>
<p>注意，还要在配置里修改端口号，第一组就用8081，第二组8082，第三组8083，遇上其他的问题可以在csdn上搜索。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计</title>
    <url>/2023/01/17/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构:"></a>架构:</h1><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201100838.png" alt="QQ截图20230201100838"></h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201101208.png" alt="QQ截图20230201101208"></p>
<h1 id="2-架构分类以及演进"><a href="#2-架构分类以及演进" class="headerlink" title="2.架构分类以及演进:"></a>2.架构分类以及演进:</h1><h2 id="2-1-单机架构"><a href="#2-1-单机架构" class="headerlink" title="2.1 单机架构:"></a>2.1 单机架构:</h2><p>核心是部署在一台机器上,稳定性较差.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201101528.png" alt="QQ截图20230201101528"></p>
<h2 id="2-2-单体架构"><a href="#2-2-单体架构" class="headerlink" title="2.2 单体架构:"></a>2.2 单体架构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201102143.png" alt="QQ截图20230201102143"></p>
<h2 id="2-3-垂直应用架构"><a href="#2-3-垂直应用架构" class="headerlink" title="2.3 垂直应用架构:"></a>2.3 垂直应用架构:</h2><p>按照职责对单体架构进行划分.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201101934.png" alt="QQ截图20230201101934"></p>
<h2 id="2-4-SOA架构"><a href="#2-4-SOA架构" class="headerlink" title="2.4 SOA架构:"></a>2.4 SOA架构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201102211.png" alt="QQ截图20230201102211"></p>
<p>类似于专家模式.</p>
<p>架构以服务为中心,服务之间按照特定的通信标准进行交互.</p>
<p>对程序进行了一层水平切分.</p>
<h2 id="2-5-微服务架构"><a href="#2-5-微服务架构" class="headerlink" title="2.5 微服务架构:"></a>2.5 微服务架构:</h2><p>在SOA架构中,明显的可以看到,兰师傅的沟通技巧是这个系统的核心,几乎所有的部门都需要通过这个进行交互,这样就会带来一系列的问题.比如每个服务都需要有复杂的设计.</p>
<p>而在微服务架构中,职责和服务拆分的会更加的细致,服务之间可以自由的建立连接方式,使程序的运行更加的高效.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201103119.png" alt="QQ截图20230201103119"></p>
<h2 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结:"></a>2.6 总结:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201103942.png" alt="QQ截图20230201103942"></p>
<h1 id="3-企业级后端架构分析"><a href="#3-企业级后端架构分析" class="headerlink" title="3.企业级后端架构分析:"></a>3.企业级后端架构分析:</h1><h2 id="3-1-引入"><a href="#3-1-引入" class="headerlink" title="3.1 引入:"></a>3.1 引入:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201104251.png" alt="QQ截图20230201104251"></p>
<h2 id="3-2-云计算"><a href="#3-2-云计算" class="headerlink" title="3.2 云计算:"></a>3.2 云计算:</h2><p><img src="C:\Users\wpy\Desktop\blog\source\images\架构设计\QQ截图20230201104538.png" alt="QQ截图20230201104538"></p>
<p>在图中,如果使用云计算能力的话,只需要关注云计算服务的上层服务,而无需关心下层服务.</p>
<p>可以把精力更加专注的放在业务能力上面,而无需分心.</p>
<h3 id="3-2-1-IaaS"><a href="#3-2-1-IaaS" class="headerlink" title="3.2.1 IaaS:"></a>3.2.1 IaaS:</h3><p>一个跨区域的组织,好比蛋糕店买房子,使用云计算的IaaS服务就好比找了一家房屋中介,屏蔽了物力资源的概念,用户不需要知道机房(服务器)在什么地方,所使用的电脑是什么型号等信息.</p>
<h3 id="3-2-2-PaaS"><a href="#3-2-2-PaaS" class="headerlink" title="3.2.2 PaaS:"></a>3.2.2 PaaS:</h3><p>好比蛋糕店房子的装修,使用云计算的PaaS服务,就好比找了一家装修公司.对服务器进行维护和处理问题.</p>
<h3 id="3-2-3-SaaS"><a href="#3-2-3-SaaS" class="headerlink" title="3.2.3 SaaS:"></a>3.2.3 SaaS:</h3><p>好比蛋糕师傅的培训机构,使用云计算的SaaS服务,类似于从蛋糕师傅培训机构寻找蛋糕师傅,他们专业技能强,上手快有保障,可以很快的进入店铺进行工作,类似于服务里面的成熟的组件.</p>
<h3 id="3-2-4-FaaS"><a href="#3-2-4-FaaS" class="headerlink" title="3.2.4 FaaS:"></a>3.2.4 FaaS:</h3><p>好比使用蛋糕机,使用云计算的FaaS服务,就好比省略掉其他的所有部分,直接得到结果,类比使用成熟的服务(组件更大规模的集成).</p>
<h2 id="3-3-云原生"><a href="#3-3-云原生" class="headerlink" title="3.3 云原生:"></a>3.3 云原生:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201110046.png" alt="QQ截图20230201110046"></p>
<h3 id="3-3-1-弹性资源"><a href="#3-3-1-弹性资源" class="headerlink" title="3.3.1:弹性资源:"></a>3.3.1:弹性资源:</h3><p>不使用物理机而是使用虚拟机,扩展非常的容易,使用户不需要考虑底层.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201110806.png" alt="QQ截图20230201110806"></p>
<p>资源存储类型:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201111420.png" alt="QQ截图20230201111420"></p>
<h3 id="3-3-2-微服务架构"><a href="#3-3-2-微服务架构" class="headerlink" title="3.3.2:微服务架构:"></a>3.3.2:微服务架构:</h3><p>微服务架构:软件的组织方式.易于扩展.服务部署之间是松耦合的,但是可以有非常复杂的调用逻辑.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201111905.png" alt="QQ截图20230201111905"></p>
<p>负载均衡层类似于大堂经理,对服务做一个分发.</p>
<p>不同的服务类型对应的不同的程序.</p>
<p>rpc服务存在着通信的压缩,在性能上要对http高一些,而且自带服务治理的能力.</p>
<p>而http服务大多使用json,内容上不存在压缩,可解释性相对较高.</p>
<p>RPC（Remote Procedure Call）叫作远程过程调用，它是利用网络从远程计算机上请求服务，可以理解为把程序的一部分放在其他远程计算机上执行。通过网络通信将调用请求发送至远程计算机后，利用远程计算机的系统资源执行这部分程序，最终返回远程计算机上的执行结果。</p>
<h3 id="3-3-3-敏捷开发"><a href="#3-3-3-敏捷开发" class="headerlink" title="3.3.3:敏捷开发:"></a>3.3.3:敏捷开发:</h3><p>敏捷开发:在服务上线之后如何进行修改和运行维护.</p>
<p>本质上是一种适配于软件开发的工作流.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230201111605.png" alt="QQ截图20230201111605"></p>
<h3 id="3-3-4-服务网格"><a href="#3-3-4-服务网格" class="headerlink" title="3.3.4:服务网格:"></a>3.3.4:服务网格:</h3><p>服务网格:服务与网络通信做一个解耦,对不同的语言所编写的代码做统一的治理.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202101912.png" alt="QQ截图20230202101912"></p>
<p>如果不使用通信网格,则由不同容器之间的rpc&#x2F;http框架之间进行通信.</p>
<p>而使用通信网格之后,则统一使用容器中的数据面进行通信,相当于多加了一层统一的代理.</p>
<h3 id="3-3-5-蛋糕店"><a href="#3-3-5-蛋糕店" class="headerlink" title="3.3.5:蛋糕店:"></a>3.3.5:蛋糕店:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202102429.png" alt="QQ截图20230202102429"></p>
<h1 id="4-企业级后端架构的挑战"><a href="#4-企业级后端架构的挑战" class="headerlink" title="4.企业级后端架构的挑战:"></a>4.企业级后端架构的挑战:</h1><h2 id="4-1-引入"><a href="#4-1-引入" class="headerlink" title="4.1 引入:"></a>4.1 引入:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202103020.png" alt="QQ截图20230202103020"></p>
<p>pod可以理解为是虚拟机.</p>
<h2 id="4-2-离在线资源并池"><a href="#4-2-离在线资源并池" class="headerlink" title="4.2 离在线资源并池:"></a>4.2 离在线资源并池:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202103453.png" alt="QQ截图20230202103453"></p>
<p>把整体的资源都分配给同一个进程,分为离线资源与在线资源,按照时间等因素进行调配.</p>
<p>随着在线资源进一步压缩,离线资源会逐步减少.</p>
<p>同一个机器怎么进行在线隔离?</p>
<h2 id="4-3-自动扩缩容"><a href="#4-3-自动扩缩容" class="headerlink" title="4.3 自动扩缩容:"></a>4.3 自动扩缩容:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202104114.png" alt="QQ截图20230202104114"></p>
<p>扩缩容指标:因为一般的微服务主要对cpu压力比较大,故一般以cpu的使用情况来判断.而对于某些特定的内存密集型,则使用内存.</p>
<p>而对io,kps的判断在业界有一定难度.</p>
<h2 id="4-4-微服务亲合性部署"><a href="#4-4-微服务亲合性部署" class="headerlink" title="4.4 微服务亲合性部署:"></a>4.4 微服务亲合性部署:</h2><p>不同的服务之间,耦合性非常的大,但确实是不同的人所维护的服务,通过某种方式降低成本.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202104611.png" alt="QQ截图20230202104611"></p>
<p>就是把服务之间的网络通信,转换为物理机内部(共享内存等方式)的信息传输.</p>
<p>IPC是Inter-Process Communication的缩写，意为进程间通信或者跨进程通信，是指两个进程进行数据交换的过程。</p>
<h2 id="4-5-流量治理"><a href="#4-5-流量治理" class="headerlink" title="4.5 流量治理:"></a>4.5 流量治理:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202105111.png" alt="QQ截图20230202105111"></p>
<h2 id="4-6-CPU水位负载均衡"><a href="#4-6-CPU水位负载均衡" class="headerlink" title="4.6 CPU水位负载均衡:"></a>4.6 CPU水位负载均衡:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202105255.png" alt="QQ截图20230202105255"></p>
<p>一开始,a容器中的服务,均衡的调动两个b容器中的服务,在接收反馈的时候,发现第一个b容器所在的物理机由于cpu型号老旧等问题,导致占用内存较高,处理时间较长,通过负载均衡,那么就可以在调用这两个负载时,有选择性的调用高的负载,从而实现水位负载均衡.</p>
<h1 id="5-架构实战"><a href="#5-架构实战" class="headerlink" title="5.架构实战:"></a>5.架构实战:</h1><h2 id="5-1-引入"><a href="#5-1-引入" class="headerlink" title="5.1 引入:"></a>5.1 引入:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202110344.png" alt="QQ截图20230202110344"></p>
<p>提炼问题：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202110409.png" alt="QQ截图20230202110409"></p>
<p>权重越高，意味着这个容器性能更好，可以分配更多的访问和任务。</p>
<h2 id="5-2-静态自适应权重："><a href="#5-2-静态自适应权重：" class="headerlink" title="5.2 静态自适应权重："></a>5.2 静态自适应权重：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202110744.png" alt="QQ截图20230202110744"></p>
<p>加一层代理。</p>
<p>对业务进程无感知。</p>
<h3 id="5-3-1-Alpha版本："><a href="#5-3-1-Alpha版本：" class="headerlink" title="5.3.1 Alpha版本："></a>5.3.1 Alpha版本：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202110920.png" alt="QQ截图20230202110920"></p>
<p>通过回归存储的静态权重，解决紧急回滚问题。</p>
<h3 id="5-3-2-Beta版本："><a href="#5-3-2-Beta版本：" class="headerlink" title="5.3.2 Beta版本："></a>5.3.2 Beta版本：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202111237.png" alt="QQ截图20230202111237"></p>
<p>在这种情况下，动态权重决策中心似乎变成了一个单体架构，那么职责太多时候怎么办呢？</p>
<p>就像架构一样，再做一层微服务的拆分。</p>
<h3 id="5-3-3-Release版本："><a href="#5-3-3-Release版本：" class="headerlink" title="5.3.3 Release版本："></a>5.3.3 Release版本：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202111741.png" alt="QQ截图20230202111741"></p>
<p>对动态权重决策中心做微服务拆分.</p>
<h1 id="6-总结："><a href="#6-总结：" class="headerlink" title="6.总结："></a>6.总结：</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202111908.png" alt="QQ截图20230202111908"></p>
<p>架构只是解决问题的一种方法.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230202112134.png" alt="QQ截图20230202112134"></p>
<p>代码重复撰写.</p>
<p>用户画像？</p>
<p>可拓展性.</p>
<h1 id="7-秒杀系统"><a href="#7-秒杀系统" class="headerlink" title="7.秒杀系统:"></a>7.秒杀系统:</h1><h2 id="7-1-系统设计方法论"><a href="#7-1-系统设计方法论" class="headerlink" title="7.1 系统设计方法论:"></a>7.1 系统设计方法论:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206100022.png" alt="QQ截图20230206100022"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206100047.png" alt="QQ截图20230206100047"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206100348.png" alt="QQ截图20230206100348"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206100717.png" alt="QQ截图20230206100717"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206100907.png" alt="QQ截图20230206100907"></p>
<h2 id="7-2-电商介绍"><a href="#7-2-电商介绍" class="headerlink" title="7.2 电商介绍:"></a>7.2 电商介绍:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206101152.png" alt="QQ截图20230206101152"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206101230.png" alt="QQ截图20230206101230"></p>
<p>社交电商:加强人与货的联系.</p>
<h2 id="7-3-秒杀业务"><a href="#7-3-秒杀业务" class="headerlink" title="7.3 秒杀业务:"></a>7.3 秒杀业务:</h2><h3 id="7-3-1-特点"><a href="#7-3-1-特点" class="headerlink" title="7.3.1 特点:"></a>7.3.1 特点:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206101356.png" alt="QQ截图20230206101356"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206101501.png" alt="QQ截图20230206101501"></p>
<h3 id="7-3-2-场景"><a href="#7-3-2-场景" class="headerlink" title="7.3.2 场景:"></a>7.3.2 场景:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206101637.png" alt="QQ截图20230206101637"></p>
<h3 id="7-3-3-存储"><a href="#7-3-3-存储" class="headerlink" title="7.3.3 存储:"></a>7.3.3 存储:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206101949.png" alt="QQ截图20230206101949"></p>
<p>电商数据库表:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206102008.png" alt="QQ截图20230206102008"></p>
<h3 id="7-3-4-服务"><a href="#7-3-4-服务" class="headerlink" title="7.3.4 服务:"></a>7.3.4 服务:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206102236.png" alt="QQ截图20230206102236"></p>
<h3 id="7-3-5-扩展"><a href="#7-3-5-扩展" class="headerlink" title="7.3.5 扩展:"></a>7.3.5 扩展:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206102321.png" alt="QQ截图20230206102321"></p>
<p>CDN 提高静态资源访问请求的工具.</p>
<h3 id="7-3-6-系统架构"><a href="#7-3-6-系统架构" class="headerlink" title="7.3.6 系统架构:"></a>7.3.6 系统架构:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206102514.png" alt="QQ截图20230206102514"></p>
<h3 id="7-3-7-流程图"><a href="#7-3-7-流程图" class="headerlink" title="7.3.7 流程图:"></a>7.3.7 流程图:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206102553.png" alt="QQ截图20230206102553"></p>
<h3 id="7-3-8-函数式编程"><a href="#7-3-8-函数式编程" class="headerlink" title="7.3.8: 函数式编程:"></a>7.3.8: 函数式编程:</h3><p>把request变成model?</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206103346.png" alt="QQ截图20230206103346"></p>
<h3 id="7-3-9-总结"><a href="#7-3-9-总结" class="headerlink" title="7.3.9 总结:"></a>7.3.9 总结:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206104218.png" alt="QQ截图20230206104218"></p>
<p>无状态:服务不存储状态(数据).</p>
<p>批量写入:降低压力.</p>
<p>最终一致性:过程中短暂不一致,最终一致.</p>
<h1 id="8-黑灰产监控与防御"><a href="#8-黑灰产监控与防御" class="headerlink" title="8.黑灰产监控与防御:"></a>8.黑灰产监控与防御:</h1><h2 id="8-1-常见的黑灰产"><a href="#8-1-常见的黑灰产" class="headerlink" title="8.1 常见的黑灰产:"></a>8.1 常见的黑灰产:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206110239.png" alt="QQ截图20230206110239"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206110331.png" alt="QQ截图20230206110331"></p>
<h2 id="8-2-常见的黑灰产业技术"><a href="#8-2-常见的黑灰产业技术" class="headerlink" title="8.2 常见的黑灰产业技术:"></a>8.2 常见的黑灰产业技术:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206111554.png" alt="QQ截图20230206111554"></p>
<h2 id="8-3-安全防护体系建设"><a href="#8-3-安全防护体系建设" class="headerlink" title="8.3 安全防护体系建设:"></a>8.3 安全防护体系建设:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206113720.png" alt="QQ截图20230206113720"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>桌搭教程</title>
    <url>/2023/03/18/%E6%A1%8C%E6%90%AD%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h1><p>一个依托于宿舍桌子，以显示器为核心的桌搭教程。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/1685326693089.jpg" alt="1685326693089"></p>
<h1 id="2-初创设计-v1-0-0："><a href="#2-初创设计-v1-0-0：" class="headerlink" title="2.初创设计: v1.0.0："></a>2.初创设计: v1.0.0：</h1><p>和大多数人一样 首先我们遇上的只是一个普普通通的学校的桌子.</p>
<p>要做的第一件事肯定是把自己现有的物品全部摆放到桌子上，并且进行略微的，不改动桌子的设计。</p>
<p>具体思路是：</p>
<p>1.桌面主体构造显示屏和电脑屏幕.平板屏幕的三屏幕.</p>
<p>2.最上方两个柜子放书，下方放各种摆件与物品.</p>
<p>3.书包挂载在左侧，右侧墙面上用挂钩和置物盒放置物品.</p>
<p>4.各种小摆件散乱的摆放在各个角落.</p>
<p>效果图如下：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/mmexport1685326491424.jpg" alt="mmexport1685326491424"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/4265112.jpg" alt="4265112"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/4262824.jpg" alt="4262824"></p>
<p>还有一些细节需要说明：</p>
<p>1.整体颜色思路选择:以绿白色为主，因为显示屏和电脑本事没有强烈观感色，于是桌面颜色搭配的核心就变成了键盘和鼠标。</p>
<p>由于键盘绿白色，鼠标黑白色，鼠标垫是绿色和黑色，故整体选择了绿白色作为主色调，主要使用了浅绿色的墙纸和绿白色调的明信片贴在墙的各个角落作为点缀，各种摆件（如香薰等）也尽量选择这两种颜色。</p>
<p>2.理线:主打一个把线挡起来，只要看不见就是好的理线，像手机充电头等不得不暴露的，使用磁吸工具固定在桌子的一侧。</p>
<h1 id="3-v2-0-0"><a href="#3-v2-0-0" class="headerlink" title="3.v2.0.0:"></a>3.v2.0.0:</h1><p>上一个版本的桌搭虽然比较美观，但是仍然有诸多问题，其中最主要的一个问题是：由于柜子的限制，导致人距离显示屏太近了，长时间看着电脑屏幕会感到不舒服。</p>
<p>要想解决这个问题，有以下几种解决方案：</p>
<p>1.显示器支架（需要在桌子上打孔，对学校桌子有损害，pass）</p>
<p>2.延长桌板（延长的面积不够大而且不稳定，pass）</p>
<p>3.拆掉柜子（可行）</p>
<p>于是拆掉柜子，抬高显示器，进行重新设计,本次设计以极简和收纳的思路重新进行设计，力求使桌面变得更加简洁。</p>
<p>效果如下：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/mmexport1685326495910.jpg" alt="mmexport1685326495910"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/qq_pic_merged_1685327368044.jpg" alt="qq_pic_merged_1685327368044"></p>
<h1 id="4-v3-0-0："><a href="#4-v3-0-0：" class="headerlink" title="4.v3.0.0："></a>4.v3.0.0：</h1><p>装备升级带来的更新，主要以显示器支架和显示器挂灯为主。</p>
<p>显示器支架不仅可以太高显示器，还可以分两层收纳物品，使拆掉柜子的桌子可以重新变得丰富。</p>
<p>显示器挂灯则可以营造氛围，配合原有的台灯进行光幕的延展。</p>
<p>另外还新增了很多摆件，和墙面后的挂画。</p>
<p>效果图如下：</p>
<p>白天:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/1685326603181.jpg" alt="1685326603181"></p>
<p>夜晚:(营造光效)</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/mmexport1685326498646.jpg" alt="mmexport1685326498646"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/mmexport1685329124724.jpg" alt="mmexport1685329124724"></p>
<p>全景:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/mmexport1685326505228.jpg" alt="mmexport1685326505228"></p>
<h1 id="5-v3-1-0"><a href="#5-v3-1-0" class="headerlink" title="5.v3.1.0:"></a>5.v3.1.0:</h1><p>主要原因是终于拼搭成功了一个巨型的反浩克机甲模型,并且把它放置在桌面上,于是所有的布局都进行了大改和重组.</p>
<p>效果如下:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/mmexport1685327230455.jpg" alt="mmexport1685327230455"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/1685333571570.jpg" alt="1685333571570"></p>
<p>书柜:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/1685333571278.jpg" alt="1685333571278"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>桌搭</tag>
      </tags>
  </entry>
  <entry>
    <title>江城一梦</title>
    <url>/2023/01/17/%E6%B1%9F%E5%9F%8E%E4%B8%80%E6%A2%A6/</url>
    <content><![CDATA[<h5 id="江城一梦"><a href="#江城一梦" class="headerlink" title="江城一梦"></a>江城一梦</h5><p>雪落在冰封的江<br>冻伤窗棂后童真的凝望<br>寻江溯洄而上<br>寂静的江城<br>城上钟鼓不闻<br>岸边长幺不响<br>难以面对寒冷太匆匆<br>于凌寒时节的梦</p>
<p>一梦烟景繁华<br>每一个平凡名姓<br>每一个闪烁的点点星光<br>安稳的生活<br>安稳的喜爱<br>穿梭自我的城中<br>启航生命的江上</p>
<p>一梦万物生灵<br>百鸟高唱 游鱼竞逐<br>苍鹰折翼翻飞<br>雄鹿高昂 眼神明亮<br>七岔的鹿角撞开死神的垂镰<br>灵长也不再自诩至尊<br>往日施舍的双手<br>化作热烈的拥抱</p>
<p>一梦天道昭彰<br>四方星月的兼城灯火<br>步步流动的白衣长廊<br>精确沉重的高屋瓦瓴<br>血脉传承中交融心跳<br>万里河山<br>眸中挚爱<br>放不下每一个生命<br>留不下每一个身影</p>
<p>你相信经迭的时光<br>江流会重新开始奔腾<br>江城一梦</p>
<p>梦在曲折的一生<br>梦在江帆的渔火<br>江城逐梦<br>关于未来<br>关于你</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>泠音泛海</title>
    <url>/2023/01/17/%E6%B3%A0%E9%9F%B3%E6%B3%9B%E6%B5%B7/</url>
    <content><![CDATA[<h5 id="泠音泛海"><a href="#泠音泛海" class="headerlink" title="泠音泛海"></a>泠音泛海</h5><p>灼灼烈阳<br>炙烤天海悠悠<br>航船静谧游弋<br>无风 无浪 无波涛<br>航向不喻 江海遥遥</p>
<p>船上 深海的冷清<br>水手疲惫的眼神<br>散漫寥落人影如酒杯<br>尽力摇晃 目光清清<br>混沌 执迷 凭栏<br>眺望波光天海</p>
<p>回首故国<br>长雁入秋心海如梦<br>牵挂故人又游弋何方<br>何时骄傲踏上这航船<br>何时举目遥望 缓缓起航<br>海峰 斜阳 沉落<br>漫漫长夜可否许我<br>渡过煎熬似晚风温婉</p>
<p>雾霭飘渺<br>静海夜涛<br>忽闻弦声轻扬<br>泠音轻响<br>十里音韵长谣<br>遇不到的人可知遇的每一个词句<br>春山烛火希望<br>抬眼星河 水中明月<br>放声高咏<br>唱尽不知意的千千悲欢<br>时幻时真<br>浮云摇摆起伏变换<br>孤舟航 云梦闹</p>
<p>曲终 落笔<br>泠音遥遥<br>执惘不闻 彷徨难再<br>目光再望向远方</p>
<p>万千巨轮驶过的航道<br>万千天风吹彻的航道<br>万千高闲倾慕的彼岸<br>重新怀希望泛海</p>
<p>渐散风闻 幕影成双<br>秉烛安光 封寒落涧<br>静月出山 泠音泛海<br>我自辗转 悲喜不言</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>系统分析与设计</title>
    <url>/2023/03/18/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="系统分析与设计"><a href="#系统分析与设计" class="headerlink" title="系统分析与设计"></a>系统分析与设计</h1><h1 id="1-系统"><a href="#1-系统" class="headerlink" title="1.系统:"></a>1.系统:</h1><h2 id="1-1-系统与信息系统"><a href="#1-1-系统与信息系统" class="headerlink" title="1.1 系统与信息系统:"></a>1.1 系统与信息系统:</h2><p>系统:一个能够产生特定结果的相关构件的集合.</p>
<p>信息系统：以信息作为输入&#x2F;输出对象，以计算机软、硬件为核心的系统.</p>
<h2 id="1-2系统开发角色"><a href="#1-2系统开发角色" class="headerlink" title="1.2系统开发角色:"></a>1.2系统开发角色:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329151714.png" alt="QQ截图20230329151714"></p>
<h2 id="1-3系统开发方法"><a href="#1-3系统开发方法" class="headerlink" title="1.3系统开发方法:"></a>1.3系统开发方法:</h2><p>结构化开发:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329151751.png" alt="QQ截图20230329151751"></p>
<p>面向对象开发:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329151838.png" alt="QQ截图20230329151838"></p>
<p>UML面向对象开发:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329151910.png" alt="QQ截图20230329151910"></p>
<h1 id="2-UML"><a href="#2-UML" class="headerlink" title="2.UML:"></a>2.UML:</h1><h2 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义:"></a>2.1 定义:</h2><p>UML — Unified Modeling Language.</p>
<p>UML 是一种对软件系统的制作过程&#x2F;产出物进行下述工作的描述语言： 可视化（visualizing）、详述 （specifying）、构造 （constructing）、 文档化（documentin).</p>
<h2 id="2-2构成"><a href="#2-2构成" class="headerlink" title="2.2构成:"></a>2.2构成:</h2><p>主要有四部分构成:视图(views).图(Diagrams).模型元素.通用机制.</p>
<h3 id="2-2-1-视图"><a href="#2-2-1-视图" class="headerlink" title="2.2.1 视图:"></a>2.2.1 视图:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329152406.png" alt="QQ截图20230329152406"></p>
<h3 id="2-2-2-图"><a href="#2-2-2-图" class="headerlink" title="2.2.2 图:"></a>2.2.2 图:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329152536.png" alt="QQ截图20230329152536"></p>
<h3 id="2-2-3-关系"><a href="#2-2-3-关系" class="headerlink" title="2.2.3 关系:"></a>2.2.3 关系:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329152559.png" alt="QQ截图20230329152559"></p>
<h1 id="3-需求"><a href="#3-需求" class="headerlink" title="3.需求:"></a>3.需求:</h1><h2 id="3-1需求的必要性"><a href="#3-1需求的必要性" class="headerlink" title="3.1需求的必要性:"></a>3.1需求的必要性:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329152740.png" alt="QQ截图20230329152740"></p>
<h2 id="3-2-需求的获取步骤"><a href="#3-2-需求的获取步骤" class="headerlink" title="3.2 需求的获取步骤:"></a>3.2 需求的获取步骤:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329152929.png" alt="QQ截图20230329152929"></p>
<h2 id="3-3-需求分类"><a href="#3-3-需求分类" class="headerlink" title="3.3 需求分类:"></a>3.3 需求分类:</h2><h3 id="3-3-1-业务需求"><a href="#3-3-1-业务需求" class="headerlink" title="3.3.1 业务需求:"></a>3.3.1 业务需求:</h3><p>描述项目的总体目标.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329153135.png" alt="QQ截图20230329153135"></p>
<h3 id="3-3-2-用户需求"><a href="#3-3-2-用户需求" class="headerlink" title="3.3.2 用户需求:"></a>3.3.2 用户需求:</h3><p>重点描述项目需求中涉及到用户操作的部分,一般分为功能需求与非功能需求.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329153329.png" alt="QQ截图20230329153329"></p>
<h4 id="3-3-2-1-功能需求"><a href="#3-3-2-1-功能需求" class="headerlink" title="3.3.2.1 功能需求:"></a>3.3.2.1 功能需求:</h4><p>功能需求是指系统需要提供的功能以及服务.</p>
<h4 id="3-3-2-2-非功能需求"><a href="#3-3-2-2-非功能需求" class="headerlink" title="3.3.2.2 非功能需求:"></a>3.3.2.2 非功能需求:</h4><p>非功能需求(Non-Functional Requirements, NFR)：从各个角度对系统的约束和限制，反映了客户对软件系统质量和性能(quality and  performance)的额外要求，包括安全性、可靠性、互操作性、健壮性、易使用性、可维护性、可移植性、可重用性、可扩充性等.</p>
<p><strong>注意：非功能需求隐含了对可选设计方案的一些关键影响</strong></p>
<h3 id="3-3-3-业务规则"><a href="#3-3-3-业务规则" class="headerlink" title="3.3.3 业务规则:"></a>3.3.3 业务规则:</h3><p>业务的具体实现细节.可执行性或内部执行逻辑的一些限定条件.</p>
<h3 id="3-3-4-数据定义"><a href="#3-3-4-数据定义" class="headerlink" title="3.3.4 数据定义:"></a>3.3.4 数据定义:</h3><p>较为复杂的数据格式的定义.</p>
<h3 id="3-3-5-约束条件"><a href="#3-3-5-约束条件" class="headerlink" title="3.3.5 约束条件:"></a>3.3.5 约束条件:</h3><p>范围比较广泛,主要描述系统开发在过程中的限制条件.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329153941.png" alt="QQ截图20230329153941"></p>
<h3 id="3-3-6-外部接口需求"><a href="#3-3-6-外部接口需求" class="headerlink" title="3.3.6 外部接口需求:"></a>3.3.6 外部接口需求:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329154022.png" alt="QQ截图20230329154022"></p>
<h2 id="3-4-好的需求"><a href="#3-4-好的需求" class="headerlink" title="3.4 好的需求:"></a>3.4 好的需求:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329154105.png" alt="QQ截图20230329154105"></p>
<h1 id="4-需求建模"><a href="#4-需求建模" class="headerlink" title="4.需求建模:"></a>4.需求建模:</h1><p>获取需求之后,建立模型,对需求进行描述.</p>
<h2 id="4-1-事件"><a href="#4-1-事件" class="headerlink" title="4.1 事件:"></a>4.1 事件:</h2><p>事件：发生在某一特定的时间和地点、可描述并且系统应该记录下来的事情.</p>
<p>信息系统的所有处理过程都是由事件驱动&#x2F;触发的.事件发生时需要系统做出响应，能列出所有这样的事件就可以搞清楚用户对系统的需求.</p>
<h3 id="4-1-1-事件类型"><a href="#4-1-1-事件类型" class="headerlink" title="4.1.1 事件类型:"></a>4.1.1 事件类型:</h3><p>外部事件: 系统外的事件.一般的行为都可以被认为是外部事件.</p>
<p>临时事件:某一时刻发生的事件.比如定时任务等.</p>
<p>状态事件:系统发生状态是所引发的事件.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329155153.png" alt="QQ截图20230329155153"></p>
<h3 id="4-1-2-事件定义"><a href="#4-1-2-事件定义" class="headerlink" title="4.1.2 事件定义:"></a>4.1.2 事件定义:</h3><p>1.与系统无关的不算做事件.</p>
<p>2.特别细节的事件在系统分析阶段不予考虑.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230329155451.png" alt="QQ截图20230329155451"></p>
<p>多个不同的事件组成了事件列表.</p>
<h2 id="4-2-事物"><a href="#4-2-事物" class="headerlink" title="4.2 事物:"></a>4.2 事物:</h2><p>在传统的开发方法中，事物就是构成系统存储 信息的相关数据 在面向对象的开发方法中，事物就是在系统中相互交互的对象.</p>
<h3 id="4-2-1-关系"><a href="#4-2-1-关系" class="headerlink" title="4.2.1 关系:"></a>4.2.1 关系:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330154018.png" alt="QQ截图20230330154018"></p>
<h3 id="4-2-2-属性"><a href="#4-2-2-属性" class="headerlink" title="4.2.2 属性:"></a>4.2.2 属性:</h3><p>属性：有关事物的一条特定信息.</p>
<h3 id="4-2-3-ERD"><a href="#4-2-3-ERD" class="headerlink" title="4.2.3 ERD:"></a>4.2.3 ERD:</h3><p>实体关系图.</p>
<p>示例:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330154536.png" alt="QQ截图20230330154536"></p>
<p>关系说明:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330154436.png" alt="QQ截图20230330154436"></p>
<p>简单记为:双方都有一条竖线,有圈是可选,斜线数量代表各种关系.</p>
<h3 id="4-2-4-类图"><a href="#4-2-4-类图" class="headerlink" title="4.2.4 类图:"></a>4.2.4 类图:</h3><p>面向对象设计所构建出来出的模型,用类图表示.</p>
<p>一个类由三部分组成:名字,属性,方法.</p>
<p>不同类之间的关系如下:</p>
<p>泛化:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330154838.png" alt="QQ截图20230330154838"></p>
<p>组合:物理上一体的组成部分:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330154853.png" alt="QQ截图20230330154853"></p>
<p>聚合:物理上本没有关系,人为的联系在一起.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330154846.png" alt="QQ截图20230330154846"></p>
<h2 id="4-3-敏捷开发"><a href="#4-3-敏捷开发" class="headerlink" title="4.3.敏捷开发:"></a>4.3.敏捷开发:</h2><h3 id="4-3-1-用户故事"><a href="#4-3-1-用户故事" class="headerlink" title="4.3.1 用户故事:"></a>4.3.1 用户故事:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330155247.png" alt="QQ截图20230330155247"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330155324.png" alt="QQ截图20230330155324"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330155430.png" alt="QQ截图20230330155430"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330155445.png" alt="QQ截图20230330155445"></p>
<h1 id="5-用例分析"><a href="#5-用例分析" class="headerlink" title="5.用例分析:"></a>5.用例分析:</h1><p>1.用例模型图.</p>
<p>2.每个用例的详细描述.  </p>
<p>3.术语表：所用到的术语说明. </p>
<p>4.补充规约：非功能性需求的说明.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330161302.png" alt="QQ截图20230330161302"></p>
<h2 id="5-1-用例"><a href="#5-1-用例" class="headerlink" title="5.1 用例:"></a>5.1 用例:</h2><p>用例(Use Case)：表示系统所提供的服务或可执行的某种行为.</p>
<p>– 定义了系统是如何被参与者所使用的，描述了参与者为了使用系统所提供的某一完整功能而与系统之间发生的一段“对话”.</p>
<p>– 用例的概念在1986年由Ivar Jacobson正式提出之后被广泛接受，迅速发展，已成为OO、UML、RUP的标准规范和方法.</p>
<h2 id="5-2-特征："><a href="#5-2-特征：" class="headerlink" title="5.2 特征："></a>5.2 特征：</h2><p>1.不可分解</p>
<p>2.系统参与</p>
<p>3.可观测</p>
<p>4.有价值</p>
<p>5.特定角色触发</p>
<h2 id="5-3-用例图："><a href="#5-3-用例图：" class="headerlink" title="5.3 用例图："></a>5.3 用例图：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330160049.png" alt="QQ截图20230330160049"></p>
<h2 id="5-4-用例建模的基本流程："><a href="#5-4-用例建模的基本流程：" class="headerlink" title="5.4 用例建模的基本流程："></a>5.4 用例建模的基本流程：</h2><p>1.识别并描述参与者(actor)； </p>
<p>2.识别用例(use case)，并给出简要描述； </p>
<p>3.识别参与者与用例之间的通讯关联(Association)；</p>
<p>4.给出每一个用例的详细描述.</p>
<p>5.细化用例模型.</p>
<h3 id="5-4-1-特殊参与者："><a href="#5-4-1-特殊参与者：" class="headerlink" title="5.4.1 特殊参与者："></a>5.4.1 特殊参与者：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330160340.png" alt="QQ截图20230330160340"></p>
<h3 id="5-4-2-详细描述："><a href="#5-4-2-详细描述：" class="headerlink" title="5.4.2 详细描述："></a>5.4.2 详细描述：</h3><p>包括事件流（常规与备选），前置，后置条件，目标等。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330160656.png" alt="QQ截图20230330160656"></p>
<h3 id="5-4-3-细化用例模型："><a href="#5-4-3-细化用例模型：" class="headerlink" title="5.4.3 细化用例模型："></a>5.4.3 细化用例模型：</h3><p>包含：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330160802.png" alt="QQ截图20230330160802"></p>
<p>拓展：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330160811.png" alt="QQ截图20230330160811"></p>
<p>注意箭头指向的方向是拓展的主体方向。</p>
<p>泛化：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330160753.png" alt="QQ截图20230330160753"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330160849.png" alt="QQ截图20230330160849"></p>
<h2 id="5-5-活动图与泳道图："><a href="#5-5-活动图与泳道图：" class="headerlink" title="5.5 活动图与泳道图："></a>5.5 活动图与泳道图：</h2><p>作为补充.</p>
<p>活动图：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330161349.png" alt="QQ截图20230330161349"></p>
<p>泳道图：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230330161357.png" alt="QQ截图20230330161357"></p>
<h1 id="6-结构化系统分析："><a href="#6-结构化系统分析：" class="headerlink" title="6.结构化系统分析："></a>6.结构化系统分析：</h1>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析</title>
    <url>/2023/03/18/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h1><h1 id="1-绪论："><a href="#1-绪论：" class="headerlink" title="1.绪论："></a>1.绪论：</h1><h2 id="1-1-算法特性："><a href="#1-1-算法特性：" class="headerlink" title="1.1 算法特性："></a>1.1 算法特性：</h2><p>1.输入</p>
<p>2.输出</p>
<p>3.可行性</p>
<p>4.有穷性（终止性）</p>
<p>5.确定性</p>
<h2 id="1-2-问题与问题实例："><a href="#1-2-问题与问题实例：" class="headerlink" title="1.2 问题与问题实例："></a>1.2 问题与问题实例：</h2><p>问题是由输入和输出组成的二元组集合，问题实例是其中的一个二元组。</p>
<p>一个算法求解一个问题，而不是问题实例。</p>
<h2 id="1-3-算法正确性："><a href="#1-3-算法正确性：" class="headerlink" title="1.3 算法正确性："></a>1.3 算法正确性：</h2><p>一个算法是正确的，如果它对于每一个输入都最终停止,而且产生正确的输出.</p>
<p>调试程序不能证明算法正确，只能证明算法有错。</p>
<h3 id="1-3-1-正确性分析："><a href="#1-3-1-正确性分析：" class="headerlink" title="1.3.1 正确性分析："></a>1.3.1 正确性分析：</h3><p>循环不变量方法：主要结构为循环的算法的正确性证明。</p>
<p>(有点类似数学归纳法)</p>
<p>1.循环初始：即循环开始前，P成立</p>
<p>2.循环步骤：循环体每执行一次之后P仍然成立</p>
<p>3.循环终止：循环结束后，P成立，保证算法正确</p>
<h2 id="1-4-算法复杂性："><a href="#1-4-算法复杂性：" class="headerlink" title="1.4 算法复杂性："></a>1.4 算法复杂性：</h2><p> 分析算法对不同输入所需资源量</p>
<h2 id="1-5-输入的大小："><a href="#1-5-输入的大小：" class="headerlink" title="1.5 输入的大小："></a>1.5 输入的大小：</h2><p>设<em>Input</em>是问题<em>P</em>的输入集合，<em>P</em>的输入大小是一个函数</p>
<p><em>F</em>：<em>Input</em>—<em>N</em>，<em>N</em>是正整数集合.通常用size（a）表示。</p>
<h2 id="1-6-时间复杂度："><a href="#1-6-时间复杂度：" class="headerlink" title="1.6 时间复杂度："></a>1.6 时间复杂度：</h2><p>算法的时间复杂度是对该输入产生结果所需要的原子操作数。</p>
<p>是输入大小的函数t（n）</p>
<h2 id="1-7-空间复杂度："><a href="#1-7-空间复杂度：" class="headerlink" title="1.7 空间复杂度："></a>1.7 空间复杂度：</h2><p>空间复杂性是对该输入所需要的存储空间的大小。</p>
<h3 id="1-7-1-时间复杂度分析："><a href="#1-7-1-时间复杂度分析：" class="headerlink" title="1.7.1 时间复杂度分析："></a>1.7.1 时间复杂度分析：</h3><p>把每个原子操作所需要的时间假定为常数。</p>
<p>把程序所有原子操作执行时间的和加起来，作为时间复杂度。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529211342766.png" alt="image-20230529211342766"></p>
<h3 id="1-7-2-对时间复杂度的理解："><a href="#1-7-2-对时间复杂度的理解：" class="headerlink" title="1.7.2 对时间复杂度的理解："></a>1.7.2 对时间复杂度的理解：</h3><p>时间复杂性分析并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。</p>
<p>也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也慢了数百倍，或者变慢了数万倍。</p>
<p>如果不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度。</p>
<h2 id="1-8-其他定义："><a href="#1-8-其他定义：" class="headerlink" title="1.8 其他定义："></a>1.8 其他定义：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529211038879.png" alt="image-20230529211038879"></p>
<h1 id="2-算法分析的数学基础："><a href="#2-算法分析的数学基础：" class="headerlink" title="2.算法分析的数学基础："></a>2.算法分析的数学基础：</h1><h2 id="2-1-复杂函数的阶："><a href="#2-1-复杂函数的阶：" class="headerlink" title="2.1 复杂函数的阶："></a>2.1 复杂函数的阶：</h2><p>影响函数运行时间的主导项。</p>
<h3 id="2-1-1-同阶："><a href="#2-1-1-同阶：" class="headerlink" title="2.1.1 同阶："></a>2.1.1 同阶：</h3><p>用θ表示。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529212227153.png" alt="image-20230529212227153"></p>
<h3 id="2-1-2-低阶函数集合："><a href="#2-1-2-低阶函数集合：" class="headerlink" title="2.1.2 低阶函数集合："></a>2.1.2 低阶函数集合：</h3><p>用O表示。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529212401125.png" alt="image-20230529212401125"></p>
<h3 id="2-1-3-高阶函数集合："><a href="#2-1-3-高阶函数集合：" class="headerlink" title="2.1.3 高阶函数集合："></a>2.1.3 高阶函数集合：</h3><p>用Ω表示。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529212454661.png" alt="image-20230529212454661"></p>
<p>前面的作为高、低阶函数，后面带系数的是用希腊字母表示的函数。</p>
<h3 id="2-1-4-三者的关系："><a href="#2-1-4-三者的关系：" class="headerlink" title="2.1.4 三者的关系："></a>2.1.4 三者的关系：</h3><p>θ表示渐进紧界</p>
<p>O表示渐进上界</p>
<p>Ω表示渐进下界</p>
<p>显然，o是最坏情况，Ω是最好情况，一般来说，很少用Ω描述算法的时间复杂度，一般使用O。</p>
<h3 id="2-1-5-严格低阶函数："><a href="#2-1-5-严格低阶函数：" class="headerlink" title="2.1.5 严格低阶函数："></a>2.1.5 严格低阶函数：</h3><p>与低阶差不多，但是少了等号。</p>
<h3 id="2-1-6-数学公式中函数阶的定义："><a href="#2-1-6-数学公式中函数阶的定义：" class="headerlink" title="2.1.6 数学公式中函数阶的定义："></a>2.1.6 数学公式中函数阶的定义：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529213142061.png" alt="image-20230529213142061"></p>
<h2 id="2-2和式的计算和估计："><a href="#2-2和式的计算和估计：" class="headerlink" title="2.2和式的计算和估计："></a>2.2和式的计算和估计：</h2><h2 id="2-3递归方程："><a href="#2-3递归方程：" class="headerlink" title="2.3递归方程："></a>2.3递归方程：</h2><p>递归方程是使用具有较小输入值的相同方程来描述一个方程。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601161711292.png" alt="image-20230601161711292"></p>
<p>有多种解法.</p>
<h3 id="2-3-1-替换方法："><a href="#2-3-1-替换方法：" class="headerlink" title="2.3.1 替换方法："></a>2.3.1 替换方法：</h3><p>先猜测解，然后用数学归纳法证明。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529213630519.png" alt="image-20230529213630519"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230529213636789.png" alt="image-20230529213636789"></p>
<h3 id="2-3-2-迭代计算"><a href="#2-3-2-迭代计算" class="headerlink" title="2.3.2 迭代计算:"></a>2.3.2 迭代计算:</h3><p>通过和式子估计的方式求出结果.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601161816030.png" alt="image-20230601161816030"></p>
<h3 id="2-3-3-master定理"><a href="#2-3-3-master定理" class="headerlink" title="2.3.3 master定理:"></a>2.3.3 master定理:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601162156649.png" alt="image-20230601162156649"></p>
<p><img src="C:\Users\wpy\AppData\Roaming\Typora\typora-user-images\image-20230601162223715.png" alt="image-20230601162223715"></p>
<h1 id="3-排序与分治："><a href="#3-排序与分治：" class="headerlink" title="3.排序与分治："></a>3.排序与分治：</h1><h2 id="3-1-算法设计"><a href="#3-1-算法设计" class="headerlink" title="3.1 算法设计:"></a>3.1 算法设计:</h2><p>1.边界条件:递归的底层调用的条件.</p>
<p>2.divide:分成多个子问题</p>
<p>是一个划分,根据某种划分条件,把集合划分成几个部分</p>
<p>2.conquer:递归调用正在设计的算法</p>
<p>直接调用当前正在进行的函数即可,返回值肯定是和当前函数的返回值相同.                                                                                                                         </p>
<p>3.merge:合并子问题的解</p>
<p>划分成几个部分就对几个部分进行合并,要注意,合并的结果就是当前函数的返回值,也就是conquer的返回值,根据不同的问题,合并的具体逻辑也不相同.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230530094638937.png" alt="image-20230530094638937"></p>
<h2 id="3-2-例1-求max-min"><a href="#3-2-例1-求max-min" class="headerlink" title="3.2 例1:求max,min"></a>3.2 例1:求max,min</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230530094930240.png" alt="image-20230530094930240"></p>
<p>简单来说就是通过递归,把运算划归到两个两个数进行运算.</p>
<p>终止条件:</p>
<p>只剩两个数的时候比较,后返回</p>
<p>divide:</p>
<p>根据数组中点分成两个部分</p>
<p>conquer:</p>
<p>对两个部分分别求max,min</p>
<p>merge:</p>
<p>分别从两个max,min中找到max,min.</p>
<h2 id="3-3-例2-快速排序"><a href="#3-3-例2-快速排序" class="headerlink" title="3.3 例2:快速排序"></a>3.3 例2:快速排序</h2><p>划分成两个部分,分别排序,然后在合并起来.</p>
<p>快速排序:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230530100407809.png" alt="image-20230530100407809"></p>
<p>终止条件:</p>
<p>只剩两个数,直接返回</p>
<p>divide:</p>
<p>选定一个数,把一个数组分成三部分:p左边的都比p小,p右边的都比p大.</p>
<p>couquer:</p>
<p>对这两个数组分别使用快速排序.</p>
<p>merge:</p>
<p>不需要merge,递归的运算完成之后就已经是排序完成了.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601163113788.png" alt="image-20230601163113788"></p>
<p>时间复杂度:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601163620365.png" alt="image-20230601163620365"></p>
<p>注意:此处的时间复杂度是用θ表示的,也就是说,这是一个稳定的算法,不会因为数据排列方式的不同而不同.</p>
<p>而那些用o来表示的,可以说是不稳定算法,代表了最差的复杂度.</p>
<h2 id="3-4-排序问题的下界"><a href="#3-4-排序问题的下界" class="headerlink" title="3.4 排序问题的下界:"></a>3.4 排序问题的下界:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230530100802353.png" alt="image-20230530100802353"></p>
<p> 意义:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601163920296.png" alt="image-20230601163920296"></p>
<h2 id="3-5-例子3-一维空间"><a href="#3-5-例子3-一维空间" class="headerlink" title="3.5 例子3:一维空间:"></a>3.5 例子3:一维空间:</h2><p>divide:</p>
<p>折半把点分成两部分.</p>
<p>conquer:</p>
<p>对两部分别求最近的两个点</p>
<p>merge:</p>
<p>在两个集合合并的时候,通过边界条件求出最近的两个点.</p>
<h2 id="3-6-循环不变量方法"><a href="#3-6-循环不变量方法" class="headerlink" title="3.6 循环不变量方法:"></a>3.6 循环不变量方法:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601165247849.png" alt="image-20230601165247849"></p>
<h1 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4.动态规划:"></a>4.动态规划:</h1><h2 id="4-1-分治算法的问题"><a href="#4-1-分治算法的问题" class="headerlink" title="4.1 分治算法的问题:"></a>4.1 分治算法的问题:</h2><p>分治算法是把原始问题分解成多个子问题,然后再合并起来.</p>
<p>在分治算法中,子问题之间是相互独立的,也就是说,执行这些子问题的方式不同,得到的结果都是相同的.(比如在数组里面插入)<br>但是对于有些问题,求解子问题的顺序不同会导致结果不同,这样就不能使用分治算法了.</p>
<h2 id="4-2-优化问题"><a href="#4-2-优化问题" class="headerlink" title="4.2 优化问题:"></a>4.2 优化问题:</h2><p>问题可能有很多解，每个可能的解都对应有一个值，这个值通常称为代价.</p>
<p>优化问题是要在该问题所有可能的解中找到具有最优值(最大&#x2F;最小)的解，即问题的一个最优解.</p>
<p> 一个问题的最优解不一定是唯一的.举例：最短路径，旅行商、任务调度等问题.</p>
<p>因此我们也可以说：优化问题就是给定一个代价函数，在问题的解空间中搜索具有最小或最大代价的优化解.</p>
<p>动态规划是解决优化问题的一种常见方法.</p>
<p>简单来说,优化问题要经过很多个决策,从而得到最终的结果,最优化问题一般是让我们求解这些”决策”,即求解决策变量,而动态规划的算法题则主要让我们根据这些决策求解出最终的结果.</p>
<h2 id="4-3-动态规划简介"><a href="#4-3-动态规划简介" class="headerlink" title="4.3 动态规划简介:"></a>4.3 动态规划简介:</h2><p>Dynamic Programming ,称为DP.</p>
<p>把原始问题划分成一系列子问题.</p>
<p>不同子问题的数目常常只有多项式量级.</p>
<p>求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间.</p>
<p>自底向上地求解子问题.</p>
<p>一类优化问题：可分为多个相关子问题，子问题的解被重复使用.</p>
<h3 id="4-3-1-优化子结构"><a href="#4-3-1-优化子结构" class="headerlink" title="4.3.1 优化子结构:"></a>4.3.1 优化子结构:</h3><p>当一个问题的优化解包含了子问题的优化解时，我们说这</p>
<p>个问题具有优化子结构。</p>
<p>子问题是指数据量比较小的原始问题.这句话的意思是,原始问题的解中,属于子问题这一小部分的值放到子问题里面,依旧是最优解.</p>
<p>举个例子,比如最短路径问题,求a到b的最短路径,他的一个子问题是求a到c的最短路径,设x为最优解,那么x中从a到c的解也一定是这段路径上的最优解.否则x不可能成为最优解.</p>
<p>(其实就是反证法)</p>
<h3 id="4-3-2-重叠子问题"><a href="#4-3-2-重叠子问题" class="headerlink" title="4.3.2 重叠子问题:"></a>4.3.2 重叠子问题:</h3><p>在问题的求解过程中，很多子问题的解将被多次使用.</p>
<p>也就是说可以通过之前的状态得出之后的状态.即可以使用递推方程求解.</p>
<h2 id="4-4-过程"><a href="#4-4-过程" class="headerlink" title="4.4 过程:"></a>4.4 过程:</h2><p>1.分析最优解的结构</p>
<p>2.递归的定义最优解的代价</p>
<p>3.递归地划分子问题 </p>
<p>4.自底向上计算优化解的代价，记录优化解的构造信息</p>
<p>5.构造优化解</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230530154906083.png" alt="image-20230530154906083"></p>
<p>这个过程实在是过于抽象了,下面试图给出一种自己的过程:</p>
<h3 id="4-4-1-证明动态规划"><a href="#4-4-1-证明动态规划" class="headerlink" title="4.4.1 证明动态规划:"></a>4.4.1 证明动态规划:</h3><p>即验证这个问题具有优化子结构和重叠子问题的特征.</p>
<h3 id="4-4-2-数学的定义原问题和子问题"><a href="#4-4-2-数学的定义原问题和子问题" class="headerlink" title="4.4.2 数学的定义原问题和子问题:"></a>4.4.2 数学的定义原问题和子问题:</h3><p>子问题是数量更小的原始问题.</p>
<p>切记,在子问题定义时,涉及到当前决策一定要进行说明,否则会导致递推方程出现错误.</p>
<p>比如在”打家劫舍”问题中,定义dp数组时一定要加上限定条件:是否已经盗窃了当前房屋.即对当前问题作出决策.</p>
<h3 id="4-4-3-写出递归方程"><a href="#4-4-3-写出递归方程" class="headerlink" title="4.4.3 写出递归方程:"></a>4.4.3 写出递归方程:</h3><h3 id="4-4-4-求解"><a href="#4-4-4-求解" class="headerlink" title="4.4.4 求解:"></a>4.4.4 求解:</h3><h2 id="4-5-例子1-最长公共子序列"><a href="#4-5-例子1-最长公共子序列" class="headerlink" title="4.5 例子1:最长公共子序列:"></a>4.5 例子1:最长公共子序列:</h2><p>是在做一种选择,对每一个元素,选择要不要这个元素.</p>
<p>核心递归方程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def longestCommonSubsequence(str1, str2) -&gt; int:</span><br><span class="line">    def dp(i, j):</span><br><span class="line">        # 空串的 base case</span><br><span class="line">        if i == -1 or j == -1:</span><br><span class="line">            return 0</span><br><span class="line">        if str1[i] == str2[j]:</span><br><span class="line">            # 这边找到一个 lcs 的元素，继续往前找</span><br><span class="line">            return dp(i - 1, j - 1) + 1</span><br><span class="line">        else:</span><br><span class="line">            # 谁能让 lcs 最长，就听谁的</span><br><span class="line">            return max(dp(i-1, j), dp(i, j-1))</span><br><span class="line">        </span><br><span class="line">    # i 和 j 初始化为最后一个索引</span><br><span class="line">    return dp(len(str1)-1, len(str2)-1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>O(ij).</p>
<h2 id="4-6-例子2-背包问题"><a href="#4-6-例子2-背包问题" class="headerlink" title="4.6 例子2:背包问题:"></a>4.6 例子2:背包问题:</h2><h2 id="4-7-例子3-三角形路径问题"><a href="#4-7-例子3-三角形路径问题" class="headerlink" title="4.7 例子3: 三角形路径问题:"></a>4.7 例子3: 三角形路径问题:</h2><h1 id="5-贪心算法："><a href="#5-贪心算法：" class="headerlink" title="5.贪心算法："></a>5.贪心算法：</h1><h2 id="5-1-简介："><a href="#5-1-简介：" class="headerlink" title="5.1 简介："></a>5.1 简介：</h2><p>贪心算法总是做出在当前来看最好的选择。</p>
<p>并不从整体最优考虑，做出的只是在某种意义上的局部最优解。</p>
<p>希望通过作出局部优化选择达到全局优化选择。</p>
<p>贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解，如：单源最短路经问题、最小生成树问题等</p>
<p>在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。</p>
<p>是在最优化问题的决策的过程中,针对如何决策所进行的算法.</p>
<h2 id="5-2-产生优化解的条件："><a href="#5-2-产生优化解的条件：" class="headerlink" title="5.2 产生优化解的条件："></a>5.2 产生优化解的条件：</h2><h3 id="5-2-1-优化子结构："><a href="#5-2-1-优化子结构：" class="headerlink" title="5.2.1.优化子结构："></a>5.2.1.优化子结构：</h3><p>若一个优化问题的优化解包含它的(剩余)子问题的优化解，则称其具有优化子结构。</p>
<p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面状态推导出来。</p>
<h3 id="5-2-2-Greedy选择性-Greedy-choice-property-："><a href="#5-2-2-Greedy选择性-Greedy-choice-property-：" class="headerlink" title="5.2.2 Greedy选择性(Greedy-choice property)："></a>5.2.2 Greedy选择性(Greedy-choice property)：</h3><p>一个优化问题的全局优化解可以通过局部优化选择</p>
<p>得到。</p>
<p>greedy选择性证明：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531212252722.png" alt="image-20230531212252722"></p>
<p>简单来说,是针对一个全局最优解进行分析,最好对这个全局最优解进行排序.</p>
<p>然后取出其中一个,与贪心算法所取出的那一个进行比较.</p>
<p>有两种情况:</p>
<p>1.是同一个:符合贪心算法要求</p>
<p>2.不是同一个:则使用剪枝粘贴技术,即把当前这个去掉,然后加上贪心的这一个,然后证明新的这个解是比原来的最优解更优秀的一个解.</p>
<p>用这两点证明贪心算法可以得到最优秀的解.</p>
<h2 id="5-3-与动态规划的比较："><a href="#5-3-与动态规划的比较：" class="headerlink" title="5.3 与动态规划的比较："></a>5.3 与动态规划的比较：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531212318252.png" alt="image-20230531212318252"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531212337774.png"></p>
<p> 最优解问题大部分都可以拆分成一个个的子问题，把解空间的遍历视作对子问题树的遍历，则以某种形式对树整个的遍历一遍就可以求出最优解，大部分情况下这是不可行的。</p>
<p>贪心算法和动态规划本质上是对子问题树的一种修剪，两种算法要求问题都具有的一个性质就是子问题最优性(组成最优解的每一个子问题的解，对于这个子问题本身肯定也是最优的)。</p>
<p>动态规划方法代表了这一类问题的一般解法，我们自底向上构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，并且以其中的最优值作为自身的值，其它的值舍弃。</p>
<p>而贪心算法是动态规划方法的一个特例，可以证明每一个子树的根的值不取决于下面叶子的值，而只取决于当前问题的状况。换句话说，不需要知道一个节点所有子树的情况，就可以求出这个节点的值。由于贪心算法的这个特性，它对解空间树的遍历不需要自底向上，而只需要自根开始，选择最优的路，一直走到底就可以了。</p>
<h2 id="5-4-设计贪心算法的步骤："><a href="#5-4-设计贪心算法的步骤：" class="headerlink" title="5.4 设计贪心算法的步骤："></a>5.4 设计贪心算法的步骤：</h2><p>1.设计贪心选择方法：</p>
<p>2.证明方法的优化子结构和选择性</p>
<p>3.设计算法</p>
<h2 id="5-5-最小生成树："><a href="#5-5-最小生成树：" class="headerlink" title="5.5 最小生成树："></a>5.5 最小生成树：</h2><h3 id="5-5-1-kruskal算法："><a href="#5-5-1-kruskal算法：" class="headerlink" title="5.5.1 kruskal算法："></a>5.5.1 kruskal算法：</h3><p>每次找一条权值最小的边加入集合。</p>
<h3 id="5-5-2-prim算法："><a href="#5-5-2-prim算法：" class="headerlink" title="5.5.2 prim算法："></a>5.5.2 prim算法：</h3><p>每次找两个点集合之间连接的边里面，权值最小的加入边集合，同时把点加入点集合.</p>
<h1 id="6-平摊分析："><a href="#6-平摊分析：" class="headerlink" title="6.平摊分析："></a>6.平摊分析：</h1><h2 id="6-1-简介："><a href="#6-1-简介：" class="headerlink" title="6.1 简介："></a>6.1 简介：</h2><p>目的是分析给定数据结构上的n个操作的上界.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531214059911.png" alt="image-20230531214059911"></p>
<h2 id="6-2-聚集方法："><a href="#6-2-聚集方法：" class="headerlink" title="6.2 聚集方法："></a>6.2 聚集方法：</h2><p>目的是分析n个操作系列中每个操作的复杂性上界。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531214216132.png" alt="image-20230531214216132"></p>
<h2 id="6-3-栈操作："><a href="#6-3-栈操作：" class="headerlink" title="6.3 栈操作："></a>6.3 栈操作：</h2><h3 id="6-3-1-基本操作："><a href="#6-3-1-基本操作：" class="headerlink" title="6.3.1 基本操作："></a>6.3.1 基本操作：</h3><ol>
<li></li>
</ol>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531214413815.png" alt="image-20230531214413815"></p>
<ol start="2">
<li></li>
</ol>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531214359122.png" alt="image-20230531214359122"></p>
<h3 id="6-3-2-操作分析："><a href="#6-3-2-操作分析：" class="headerlink" title="6.3.2 操作分析："></a>6.3.2 操作分析：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230531214502312.png" alt="image-20230531214502312"></p>
<h1 id="7-树搜索："><a href="#7-树搜索：" class="headerlink" title="7.树搜索："></a>7.树搜索：</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述:"></a>7.1 概述:</h2><p>简单来说,就是把问题的数据集合放在树中,运用树搜索的相关知识和方法解决问题.</p>
<h2 id="7-2-相关搜索方法"><a href="#7-2-相关搜索方法" class="headerlink" title="7.2 相关搜索方法:"></a>7.2 相关搜索方法:</h2><h3 id="7-2-1-DFS"><a href="#7-2-1-DFS" class="headerlink" title="7.2.1 DFS:"></a>7.2.1 DFS:</h3><p>深度优先搜索.</p>
<h3 id="7-2-2-BFS"><a href="#7-2-2-BFS" class="headerlink" title="7.2.2 BFS:"></a>7.2.2 BFS:</h3><p>广度优先搜索.</p>
<h3 id="7-2-3-爬山算法"><a href="#7-2-3-爬山算法" class="headerlink" title="7.2.3 爬山算法:"></a>7.2.3 爬山算法:</h3><p>贪心算法加深度优先搜索.</p>
<p>在选择哪个节点开始深度优先搜索时,使用评估函数,不同的问题评估函数不一样.根据不同节点的评估函数的值确定搜索的先后顺序.</p>
<p>具有局部优化的特征.</p>
<h3 id="7-2-4-Best-First算法"><a href="#7-2-4-Best-First算法" class="headerlink" title="7.2.4 Best-First算法:"></a>7.2.4 Best-First算法:</h3><p>贪心算法加广度优先搜索.</p>
<p>在针对哪些节点开始广度优先搜索时,同样是使用函数进行评估,对函数小(大)的节点进行广度优先搜索.函数值相同的节点都要进行搜索.</p>
<p>具有全局优化的特征.(其实广度优先搜索本事具有这种特征).</p>
<h3 id="7-2-5-分支限界算法"><a href="#7-2-5-分支限界算法" class="headerlink" title="7.2.5 分支限界算法:"></a>7.2.5 分支限界算法:</h3><p>同样是对广度优先搜索的一种优化.</p>
<p>分支限界法的步骤如下：</p>
<p>1)按宽度优先策略遍历解空间树</p>
<p>2)在遍历过程中，对处理的每个结点i，根据界限函数，估计沿该结点向下搜索所可能达到的完全解的目标函数的可能取值范围—界限bound(i)&#x3D;[dow(i), up(i)]</p>
<ol start="3">
<li>从中选择使目标函数取的极小值的结点优先进行宽度优先搜索，从而不断调整搜索方向，尽快找到问题解。</li>
</ol>
<p>在每次分支后，对凡是界限超出已知可行解值那些子集不再做进一步分支。这样，解的许多子集（即搜索树上的许多结点）就可以不予考虑了，从而缩小了搜索范围。</p>
<h1 id="8-图算法"><a href="#8-图算法" class="headerlink" title="8.图算法:"></a>8.图算法:</h1><h2 id="8-1-最大流"><a href="#8-1-最大流" class="headerlink" title="8.1 最大流:"></a>8.1 最大流:</h2><h3 id="8-1-1-问题概述"><a href="#8-1-1-问题概述" class="headerlink" title="8.1.1 问题概述:"></a>8.1.1 问题概述:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601225556248.png" alt="image-20230601225556248"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601225634141.png" alt="image-20230601225634141"></p>
<h3 id="8-1-2-解题思路"><a href="#8-1-2-解题思路" class="headerlink" title="8.1.2 解题思路:"></a>8.1.2 解题思路:</h3><h4 id="8-1-2-1-最大流等于最小割"><a href="#8-1-2-1-最大流等于最小割" class="headerlink" title="8.1.2.1 最大流等于最小割:"></a>8.1.2.1 最大流等于最小割:</h4><p>过桥可以很简单的理解.</p>
<h4 id="8-1-2-2-ford-fulkerson算法"><a href="#8-1-2-2-ford-fulkerson算法" class="headerlink" title="8.1.2.2 ford-fulkerson算法:"></a>8.1.2.2 ford-fulkerson算法:</h4><p>1.选定一个流(注意流和流网络的不同之处,流网络只有最大容量,流除了容量还有余量)</p>
<p>2.根据这个流找到残留网络</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601231214792.png" alt="image-20230601231214792"></p>
<p>3.根据残留网络找到增广路径</p>
<p>若一条路径上的残余容量大于0,那么这就是一条增广路径.</p>
<p>4.在增广路径上压入新的流量,形成新的流,然后重复2.</p>
<p>5.结束:直到找不到增广路径为止.得到的流就是最大流.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230601231506335.png" alt="image-20230601231506335"></p>
<h2 id="8-2-单源最短路"><a href="#8-2-单源最短路" class="headerlink" title="8.2 单源最短路:"></a>8.2 单源最短路:</h2><p>\Dijkstra(迪杰斯特拉)算法是计算单源最短路径算法，用于计算一个结点到其他所有结点的最短路径。</p>
<p>该算法以源点为起始点，不断更新其他点到已经确定距离结点的距离，选取距离最小的结点加入S集合，直到S集合存放有所有的结点.</p>
<p>步骤:</p>
<p>现在一张图中有n个结点，有两个集合，S集合和V集合。S集合表示已经选取的结点，V集合表示还没有选取的结点</p>
<p>1.计算原点到各点的距离.不能直接到达的空着.</p>
<p>2.选取1中距离最小的点加入s集合</p>
<p>3.计算经过新加入的点,到其他各个点的距离</p>
<p>4.取距离里面最小的,把那个点加入s集合.</p>
<p>……</p>
<p>不断重复,直到s中包含所有点为止.</p>
<p>算法复杂度o(n2).</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>白马遥</title>
    <url>/2023/01/17/%E7%99%BD%E9%A9%AC%E9%81%A5/</url>
    <content><![CDATA[<h5 id="白马遥"><a href="#白马遥" class="headerlink" title="白马遥"></a>白马遥</h5><p>三关千里 念念不忘<br>是你红豆初抛的桃天</p>
<p>西凉皎月 纸醉金迷<br>是她音容真切的拥抱</p>
<p>银河望穿 山高海遥<br>是我千乘白马的寻找</p>
<p>熙攘千面 一见倾心<br>是你轻纱蓝巾的风貌</p>
<p>东风凛冬 徘徊跌撞<br>是她众叛亲离的潦倒</p>
<p>更漏凄清 长夜难涯<br>是我昔年字句闪耀</p>
<p>闽音声声 心心所向<br>是你波澜一生的传扬</p>
<p>都市华灯 浮光笼罩<br>是她静夜提笔的歌谣</p>
<p>时空相隔 梦呓相交<br>是我敬仰渴望的寻找</p>
<p>或许生命里经略过无数的白马</p>
<p>才能放下心上的西凉只身回乡</p>
<p>或许距离与时间从来阻隔不了爱</p>
<p>或许你有远方的喜爱<br>或许眼前美好无比漫长<br>或许你牵不牵手都有勇气</p>
<p>在短暂的余生上<br>再一次身骑白马</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>规则引擎</title>
    <url>/2023/02/10/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h1 id="规则引擎-设计与实现"><a href="#规则引擎-设计与实现" class="headerlink" title="规则引擎:设计与实现"></a>规则引擎:设计与实现</h1><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍:"></a>1.介绍:</h1><p>规则引擎是一种嵌入在应用服务中的组件，可以将灵活多变的业务决策从服务代码中分离出来。通过使用预定义的语义模块来编写业务逻辑规则。在执行时接受数据输入、解释业务规则，并做出决策。规则引擎能大大提高系统的灵活性和扩展性。<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E5%9B%BE%E7%89%8720230131170454.jpg" alt="QQ图片20230131170454"></p>
<p>在字节跳动，规则引擎已经在风控识别、活动运营、配置下发等场景得到了广泛的应用。开发人员可以将业务逻辑与服务代码解耦，实现灵活、高效的业务策略发布。目前公司内部基于规则引擎的动态决策系统已经承接了千万级别QPS的决策请求。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131162850.png" alt="QQ截图20230131162850"></p>
<p>规则引擎的实现需要在满足大容量、高请求、低延迟的基础上尽可能做到简单易上手。本次课程将会带领大家实现一个简单版的规则引擎。</p>
<p>规则引擎的本质呢就是我们自己定义一套语法，然后去解析用这套语法写的表达式，然后根据解析的内容执行表达式。这个过程其实就是编译和执行的过程。<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131162144.png" alt="QQ截图20230131162144"></p>
<h2 id="1-1-组成部分"><a href="#1-1-组成部分" class="headerlink" title="1.1 组成部分:"></a>1.1 组成部分:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131162831.png" alt="QQ截图20230131162831"></p>
<h1 id="2-编译原理基本概念"><a href="#2-编译原理基本概念" class="headerlink" title="2.编译原理基本概念:"></a>2.编译原理基本概念:</h1><h2 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2.1 编译:"></a>2.1 编译:</h2><p>编译的过程就是把某种语言的源程序，<strong>在不改变语义的条件下</strong>，转换成另一种语言程序(目标语言程序)</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131163222.png" alt="QQ截图20230131163222"></p>
<ul>
<li>如果源代码编译后要在操作系统上运行，那目标代码就是汇编&#x2F;机器代码。</li>
<li>如果编译后是在虚拟机里执行，那目标代码就可以不是汇编代码，而是一种解释器可以理解的中间形式的代码即可。</li>
</ul>
<h3 id="2-1-1-解释型语言和编译型语言"><a href="#2-1-1-解释型语言和编译型语言" class="headerlink" title="2.1.1 解释型语言和编译型语言:"></a><strong>2.1.1 解释型语言和编译型语言:</strong></h3><ul>
<li>有的语言提前把代码一次性转换完毕，这种就是编译型语言，用的转换工具就叫编译器，比如C、C++、Go。一次编译可重复执行<ul>
<li>编译后产物不能跨平台，不同系统对可执行文件的要求不同。.exe</li>
<li>特殊的，c、c++、汇编、源代码也不能跨平台</li>
</ul>
</li>
<li>有的语言则可以一边执行一边转化，用到哪里了就转哪里，这种就是解释性语言，用的转化工具叫虚拟机或者解释器，比如java python、javascript</li>
</ul>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131163240.png" alt="QQ截图20230131163240"></p>
<p><strong>关于</strong> <strong>Java</strong> <strong>和</strong> <strong>Python</strong> <strong>.</strong></p>
<ul>
<li>Java既有编译又有解释。但是编译并没有直接编译成机器码，而是编译成字节码，然后再放到虚拟机中执行。</li>
<li>Python执行过程也是经过两个阶段，先编译成字节码 .pyc 再放到虚拟机中去执行</li>
</ul>
<p><a href="https://link.juejin.cn/?target=https://stackoverflow.com/questions/441824/java-virtual-machine-vs-python-interpreter-parlance/441973%23441973">JVM 和 Python解释器</a> | 为什么一个叫虚拟机一个叫解释器</p>
<ol>
<li>“虚拟机”对二进制字节码进行解释，而“解释器”是对程序文本进行解释。</li>
<li>从历史上看，Java 是为解释二进制字节码而设计和实现的，而 Python 最初是为解释程序文本而设计和实现的。因此，“Java 虚拟机”这个术语在 Java 社区中具有历史意义并且非常成熟，“Python 解释器”这个术语在 Python 社区中具有历史意义并且非常成熟。人们倾向于延长传统并使用很久以前使用的相同术语。</li>
<li>对于 Java，二进制字节码解释是程序执行的主要方式，而 JIT 编译只是一种可选的和透明的优化。而对于 Python，目前，程序文本解释是 Python 程序执行的主要方式，而编译成 Python VM 字节码只是一种可选的透明优化。</li>
</ol>
<h2 id="2-2-过程"><a href="#2-2-过程" class="headerlink" title="2.2: 过程:"></a>2.2: 过程:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131163934.png" alt="QQ截图20230131163934"></p>
<h3 id="2-2-1-词法分析："><a href="#2-2-1-词法分析：" class="headerlink" title="2.2.1: 词法分析："></a>2.2.1: 词法分析：</h3><p>词法分析是规则引擎的第一步，通过逐行解析源代码，把源代码当成字符串解析，转换为词法单元(Token)的过程。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131164026.png" alt="QQ截图20230131164026"></p>
<p>识别token的核心就是有限自动机。</p>
<p>确定的有限自动机就是一个状态机，它的状态数量是有限的。该状态机在任何一个状态，基于输入的字符，都能做一个确定的状态转换。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131164038.png" alt="QQ截图20230131164038"></p>
<h3 id="2-2-2-语法分析："><a href="#2-2-2-语法分析：" class="headerlink" title="2.2.2: 语法分析："></a>2.2.2: 语法分析：</h3><p>词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构。这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点。</p>
<h3 id="2-2-3-上下文无关语法："><a href="#2-2-3-上下文无关语法：" class="headerlink" title="2.2.3: 上下文无关语法："></a>2.2.3: 上下文无关语法：</h3><p><strong>上下文无关语法 Context-Free Grammar</strong>：语言句子无需考虑上下文，就可以判断正确性。</p>
<p>编程语言不使用人类的语言（自然语言），而是采用上下文无关语法。</p>
<p>原因：</p>
<p>1.便于设计编译器。 客观上技术目前无法实现，如果使用了上下文相关文法，那就是真正实现了人工智能，NLP领域将会有重大突破。</p>
<p>2.便于代码开发维护。 如果开发出来的代码像高考的语文阅读理解一样，每个人都有不同的理解，那么，到底哪个才是作者真正想要表达的？如果人类都确定不了含义，那计算机同样也确定不了，最终结果就是错误执行或无法执行。</p>
<p>3.汇编语言&#x2F;机器语言是上下文无关的。CPU执行指令时，读到哪条执行哪条。如果CPU需要考虑上下文，来决定一个语句到底要做什么，那么CPU执行一条语句会比现在慢千倍万倍。考虑上下文的事情，完全可以用户在编程的时候用算法实现。既然机器语言是上下文无关的，那高级语言也基本上是上下文无关的，可能有某些个别语法为了方便使用，设计成了上下文相关的，比如脚本语言的弱类型。在便于使用的同时，增加了解析器的复杂度。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131170022.png" alt="QQ截图20230131170022"></p>
<h4 id="2-2-3-1：语法简介："><a href="#2-2-3-1：语法简介：" class="headerlink" title="2.2.3.1：语法简介："></a>2.2.3.1：语法简介：</h4><p><strong>上下文无关语法G：终结符集合T + 非终结符集合N + 产生式集合P + 起始符号S</strong></p>
<p>G由T、N、S和P组成，由语法G推导出来的所有句子的集合称为G语言！</p>
<p><strong>终结符：</strong> 组成串的基本符号。可以理解为词法分析器产生的token集合。比如 <code>+</code> <code>Id</code> <code>(</code> <code>)</code> 等</p>
<p><strong>非终结符：</strong> 表示token的的集合的语法变量。比如 <code>stmt</code> <code>varDecl</code> 等等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start：blockStmts ;               //起始</span><br><span class="line">block : &#x27;&#123;&#x27; blockStmts &#x27;&#125;&#x27; ;      //语句块</span><br><span class="line">blockStmts : stmt* ;              //语句块中的语句</span><br><span class="line">stmt = varDecl | expStmt | returnStmt | block;   //语句</span><br><span class="line">varDecl : type Id varInitializer？ &#x27;;&#x27; ;         //变量声明</span><br><span class="line">type : Int | Long ;                              //类型</span><br><span class="line">varInitializer : &#x27;=&#x27; exp ;                       //变量初始化</span><br><span class="line">expStmt : exp &#x27;;&#x27; ;                              //表达式语句</span><br><span class="line">returnStmt : Return exp &#x27;;&#x27; ;                    //return语句</span><br><span class="line">exp : add ;                                      //表达式       </span><br><span class="line">add : add &#x27;+&#x27; mul | mul;                         //加法表达式</span><br><span class="line">mul : mul &#x27;*&#x27; pri | pri;                         //乘法表达式</span><br><span class="line">pri : IntLiteral | Id | &#x27;(&#x27; exp &#x27;)&#x27; ;            //基础表达式 </span><br></pre></td></tr></table></figure>

<p>产生式：表示形式，S : AB ，就是说S的含义可以用语法AB进行表达</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S : AB </span><br><span class="line">A : aA | ε </span><br><span class="line">B : b | bB</span><br></pre></td></tr></table></figure>

<p><code>展开</code>(expand)：将P(A-&gt;<em>u</em> )应用到符号串vAw中，得到新串v<em>u</em> **w</p>
<p><code>折叠</code>(reduce)：将P(A-&gt;<em>uu</em> )应用到符号串v<em>uu</em> w中，得到新串vAw</p>
<p><code>推导</code>(derivate)：符号串<em>u</em> 应用一系列产生式，变成符号串<em>v</em> ，则<em>u</em> &#x3D;&gt;<em>v：S &#x3D;&gt; ab | b | bb</em></p>
<h4 id="2-2-3-2：巴科斯范式："><a href="#2-2-3-2：巴科斯范式：" class="headerlink" title="2.2.3.2：巴科斯范式："></a>2.2.3.2：巴科斯范式：</h4><p>BNF是描述上下文无关理论的一种具体方法，通过BNF可以实现上下文无关文法的具体化、公式化、科学化，是实现代码解析的必要条件。</p>
<p>BNF本质上就是树形分解，分解成一棵抽象语法树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;expr&gt; + &lt;term&gt;</span><br><span class="line">         | &lt;expr&gt; - &lt;term&gt;</span><br><span class="line">         | &lt;term&gt;</span><br><span class="line"></span><br><span class="line">&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;</span><br><span class="line">         | &lt;term&gt; / &lt;factor&gt;</span><br><span class="line">         | &lt;factor&gt;</span><br><span class="line"></span><br><span class="line">&lt;factor&gt; ::= ( &lt;expr&gt; )</span><br><span class="line">           | Num</span><br></pre></td></tr></table></figure>

<ul>
<li>每个产生式就是一个子树，在写编译器时，每个子树对应一个解析函数。</li>
<li>叶子节点叫做 <strong>终结符</strong>，非叶子节点叫做 <strong>非终结符</strong>。</li>
</ul>
<h4 id="2-2-3-3：递归下降算法-Recursive-Descent-Parsing："><a href="#2-2-3-3：递归下降算法-Recursive-Descent-Parsing：" class="headerlink" title="2.2.3.3：递归下降算法 Recursive Descent Parsing："></a>2.2.3.3：<strong>递归下降算法 Recursive Descent Parsing</strong>：</h4><p>基本思路就是按照语法规则去匹配 Token 串。比如说，变量声明语句的规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">varDecl : types Id varInitializer？ &#x27;;&#x27; ;        //变量声明</span><br><span class="line">varInitializer : &#x27;=&#x27; exp ;                       //变量初始化</span><br><span class="line">exp : add ;                                      //表达式       </span><br><span class="line">add : add &#x27;+&#x27; mul | mul;                         //加法表达式</span><br><span class="line">mul : mul &#x27;*&#x27; pri | pri;                         //乘法表达式</span><br><span class="line">pri : IntLiteral | Id | &#x27;(&#x27; exp &#x27;)&#x27; ;            //基础表达式</span><br></pre></td></tr></table></figure>

<p>如果写成产生式格式，是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">varDecl -&gt; types Id varInitializer &#x27;;&#x27; </span><br><span class="line">varInitializer -&gt; &#x27;=&#x27; exp             </span><br><span class="line">varInitializer -&gt; ε</span><br><span class="line">exp -&gt; add</span><br><span class="line">add -&gt; add + mul</span><br><span class="line">add -&gt; mul</span><br><span class="line">mul -&gt; mul * pri</span><br><span class="line">mul -&gt; pri</span><br><span class="line">pri -&gt; IntLiteral</span><br><span class="line">pri -&gt; Id</span><br><span class="line">pri -&gt; ( exp )</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匹配一个数据类型(types)</span><br><span class="line">匹配一个标识符(Id)，作为变量名称</span><br><span class="line">匹配初始化部分(varInitializer)，而这会导致下降一层，使用一个新的语法规则：</span><br><span class="line">   匹配一个等号</span><br><span class="line">   匹配一个表达式(在这个步骤会导致多层下降：exp-&gt;add-&gt;mul-&gt;pri-&gt;IntLiteral)</span><br><span class="line">   创建一个varInitializer对应的AST节点并返回</span><br><span class="line">如果没有成功地匹配初始化部分，则回溯，匹配ε，也就是没有初始化部分。</span><br><span class="line">匹配一个分号   </span><br><span class="line">创建一个varDecl对应的AST节点并返回</span><br></pre></td></tr></table></figure>

<p>对于一个非终结符，要从左到右依次匹配其产生式中的每个项，包括非终结符和终结符。</p>
<p>在匹配产生式右边的非终结符时，要下降一层，继续匹配该非终结符的产生式。</p>
<p>如果一个语法规则有多个可选的产生式，那么只要有一个产生式匹配成功就行。如果一个产生式匹配不成功，那就回退回来，尝试另一个产生式。这种回退过程，叫做回溯（Backtracking）。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131165906.png" alt="QQ截图20230131165906"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131170131.png" alt="QQ截图20230131170131"></p>
<h4 id="2-2-3-4-类型检查："><a href="#2-2-3-4-类型检查：" class="headerlink" title="2.2.3.4: 类型检查："></a>2.2.3.4: 类型检查：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230131170225.png" alt="QQ截图20230131170225"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>草木森</title>
    <url>/2023/01/17/%E8%8D%89%E6%9C%A8%E6%A3%AE/</url>
    <content><![CDATA[<p>草木森<br>阳春三月<br>奔赴苍翠草木<br>匆匆抖落满目风尘<br>青山上举目眺望<br>夭矫的鸿举起羽翼</p>
<p>铺陈原野的草木<br>栖身于涓涓冰雪<br>奋发于烈火嘶鸣<br>喟叹于反复摧毁自然的语言<br>冠着金翎 冲锋<br>缓缓推向身后<br>终将碧绿的浪涛</p>
<p>当灰色树枝与白色枯骨呼应<br>欣喜地听到春日的萌动<br>松开始终握紧的双手<br>以简单的魂魄敬天道昭彰<br>更从容的抹去本该矗立大地之上的名字三月东风佳人呓语<br>天色蔚蓝如画</p>
<p>岁月万古<br>层叠轮转的草木<br>总是把自己最珍视的绿色交予世人眼眸草木为森<br>徘徊于每一处森森草木间<br>希冀这草木天光永续<br>和着微风清唱起不存在的礼赞<br>万语干言</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>青萍</title>
    <url>/2023/02/10/%E9%9D%92%E8%90%8D/</url>
    <content><![CDATA[<h1 id="青萍"><a href="#青萍" class="headerlink" title="青萍"></a>青萍</h1><p>暖阳 穿彻高楼间的草木<br>照映到屋里少年郎 昏沉的脸庞<br>短暂的日光渐浓 渐斜 渐散乱<br>黑幕深重的夜 城市如苍茫荒野<br>青萍之末 西风吹彻 雾霭苍苍</p>
<p>渐清醒的少年郎 透过屏幕<br>纸醉金迷的安稳 疯狂<br>试图竭尽全力尽力思虑 妄想看到最远的远方<br>却总因无望而折返 哭泣 慌张<br>沉沦迷茫地 一次次地点燃<br>泛白屏幕里七彩色的篝火<br>试图遮挡住苍白脸庞上 无神清澈的目光</p>
<p>归途何往?<br>尔尔辞晚 总是做不到的一苇以航<br>少年郎 自以为阅尽千帆 深谙世事变幻<br>喟叹年岁辗转 朱颜折镜<br>自知拳劲孱弱 宝骏委顿 剑锋腐朽<br>且放掀澜青云志 不去谛听那厉哮寒风<br>拥抱最真实的拥抱 亲吻最甜美的笑容<br>暖阳缓缓 岁月蓦然</p>
<p>偶然的夜 幸福过后的辗转<br>少年郎 不经意间追忆过往的诗篇<br>再次看到蛛网 尘烟 枯藤 大海<br>再次触摸那<br>摇曳着曙光那枝温暖漂亮的笔杆<br>恍然 觉醒 回望<br>在时光内部核心里 滴答作响的旧时光</p>
<p>漫漫江湖 青萍飞扬的尘世<br>是少年郎心上 千载幽咽而天地共鸣的一个个文字<br>再一次谨醒他切莫虚度时光<br>追风折柳 揽桑榆 平风月<br>剥开历史风尘的面目 第一次清晰地看到<br>彼时年少的脸庞<br>思虑自己的笺越 思虑喜爱的奔忙 思虑家国的远方<br>对生活喜悦热情 对时光珍守如一</p>
<p>当城市里再次响起传唱乡野韵律<br>当如洪吕大钟的咆哮蜕变为小城歌谣的温婉<br>合上书页的少年郎<br>看着窗外的 永无休止的风暴<br>开始真实而坦率地期待着<br>某天的清晨 那穿过树林的微风与露珠折射出的太阳<br>生死聚散方知人生如梦<br>聚啸青山方知相守始终<br>少年郎 似青萍之微末 也似青萍一般孕育起势向整个世界的疾风<br>疾风闪烁 越过历史 岁月 死亡 年轻<br>裹挟着未来与生命 骄傲地佩戴着少年郎的名字<br>奔涌向前</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>近世代数</title>
    <url>/2023/01/17/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<h1 id="近世代数"><a href="#近世代数" class="headerlink" title="近世代数"></a>近世代数</h1><h1 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入:"></a>1.引入:</h1><p>近世代数主要研究所谓的代数系统,即带有运算的集合；研究代数运算的规律和各种代数系统的性质。</p>
<h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念:"></a>2.基本概念:</h1><h2 id="2-1-二元运算"><a href="#2-1-二元运算" class="headerlink" title="2.1 二元运算:"></a>2.1 二元运算:</h2><p>s为集合,sxs到s的映射,成为s上的一个二元运算.</p>
<p>S中任何两个元素的运算结果都属于S，这个性质称为运算的封闭性. (后面常说S对某运算封闭).</p>
<p>实例:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215025.png" alt="QQ截图20230206215025"></p>
<h2 id="2-2-一元运算"><a href="#2-2-一元运算" class="headerlink" title="2.2 一元运算:"></a>2.2 一元运算:</h2><p>s到s的映射.</p>
<p>表示:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215025-1675691574119-2.png" alt="QQ截图20230206215025"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215215.png" alt="QQ截图20230206215215"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215227.png" alt="QQ截图20230206215227"></p>
<h2 id="2-3-二元运算的规律"><a href="#2-3-二元运算的规律" class="headerlink" title="2.3 二元运算的规律:"></a>2.3 二元运算的规律:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215406.png" alt="QQ截图20230206215406"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215515.png" alt="QQ截图20230206215515"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207150210.png" alt="QQ截图20230207150210"></p>
<h2 id="2-4-单位元"><a href="#2-4-单位元" class="headerlink" title="2.4 单位元:"></a>2.4 单位元:</h2><p>类似乘法里面的1.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215633.png" alt="QQ截图20230206215633"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215652.png" alt="QQ截图20230206215652"></p>
<h2 id="2-5-零元"><a href="#2-5-零元" class="headerlink" title="2.5 零元:"></a>2.5 零元:</h2><p>类似乘法中的0.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206215840.png" alt="QQ截图20230206215840"></p>
<h2 id="2-6-逆元"><a href="#2-6-逆元" class="headerlink" title="2.6 逆元:"></a>2.6 逆元:</h2><p>类似倒数.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207150035.png" alt="QQ截图20230207150035"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207150103.png" alt="QQ截图20230207150103"></p>
<h2 id="2-7-代数系统"><a href="#2-7-代数系统" class="headerlink" title="2.7 代数系统:"></a>2.7 代数系<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207150253.png" alt="QQ截图20230207150253">统:</h2><p>一个集合+集合上的一些二元运算.</p>
<p>近世代数（或抽象代数）的主要研究内容就是研究所谓的代数系统，即带有运算的集合。在近世代数里，不管是在群、环里还是在其它代数系统里，研究一种代数系统就是要解决这一系统的存在问题、数量问题和构造问题。如果对于一个代数系统，这三个问题能得到圆满的解答，研究的目的就算达到了 <strong>。</strong></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207150539.png" alt="QQ截图20230207150539"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207150635.png" alt="QQ截图20230207150635"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207150649.png" alt="QQ截图20230207150649"></p>
<h1 id="3-半群"><a href="#3-半群" class="headerlink" title="3.半群:"></a>3.半群:</h1><h2 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义:"></a>3.1 定义:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207151020.png" alt="QQ截图20230207151020"></p>
<p>结合律:半群</p>
<p>交换律:交换半群,可换半群.</p>
<h2 id="3-2-半群的术语"><a href="#3-2-半群的术语" class="headerlink" title="3.2 半群的术语:"></a>3.2 半群的术语:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207151407.png" alt="QQ截图20230207151407"></p>
<p>单位元问题:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207151446.png" alt="QQ截图20230207151446"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207151558.png" alt="QQ截图20230207151558"></p>
<h2 id="3-3-子半群"><a href="#3-3-子半群" class="headerlink" title="3.3 子半群:"></a>3.3 子半群:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207151724.png" alt="QQ截图20230207151724"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207152024.png" alt="QQ截图20230207152024"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207152328.png" alt="QQ截图20230207152328"></p>
<h2 id="3-4-理想"><a href="#3-4-理想" class="headerlink" title="3.4 理想:"></a>3.4 理想:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207152359.png" alt="QQ截图20230207152359"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230207152451.png" alt="QQ截图20230207152451"></p>
<p>两个集合,不加符号,表示两个集合里面任意两个元素进行操作.</p>
<h2 id="3-5-循环半群"><a href="#3-5-循环半群" class="headerlink" title="3.5 循环半群:"></a>3.5 循环半群:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211155421.png" alt="QQ截图20230211155421"></p>
<h2 id="3-6-半群的同态和同构"><a href="#3-6-半群的同态和同构" class="headerlink" title="3.6 半群的同态和同构:"></a>3.6 半群的同态和同构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211155550.png" alt="QQ截图20230211155550"></p>
<h2 id="3-7-商半群"><a href="#3-7-商半群" class="headerlink" title="3.7 商半群:"></a>3.7 商半群:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211155650.png" alt="QQ截图20230211155650"></p>
<h1 id="4-幺半群"><a href="#4-幺半群" class="headerlink" title="4.幺半群:"></a>4.幺半群:</h1><p>有单位元的半群.</p>
<p>有单位元,符合集合律的代数系统.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211155934.png" alt="QQ截图20230211155934"></p>
<h2 id="4-1-幺半群的性质"><a href="#4-1-幺半群的性质" class="headerlink" title="4.1 幺半群的性质:"></a>4.1 幺半群的性质:</h2><p>有限与无限. S集合的基数成为幺半群的阶.</p>
<p>有的有零元,有的没有零元.</p>
<h2 id="4-2-逆元问题"><a href="#4-2-逆元问题" class="headerlink" title="4.2 逆元问题:"></a>4.2 逆元问题:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211160315.png" alt="QQ截图20230211160315"></p>
<h1 id="5-群"><a href="#5-群" class="headerlink" title="5.群:"></a>5.群:</h1><h2 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义:"></a>5.1 定义:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211160658.png" alt="QQ截图20230211160658"></p>
<h1 id="6-有限群和子群"><a href="#6-有限群和子群" class="headerlink" title="6.有限群和子群:"></a>6.有限群和子群:</h1><p>在群的定义上加上有限集合的限制条件.</p>
<h2 id="6-1-有限群的性质"><a href="#6-1-有限群的性质" class="headerlink" title="6.1 有限群的性质:"></a>6.1 有限群的性质:</h2><p>有限群的每个元素的阶均为有限且不超过群的阶.</p>
<h2 id="6-2-子群的定义"><a href="#6-2-子群的定义" class="headerlink" title="6.2 子群的定义:"></a>6.2 子群的定义:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211161340.png" alt="QQ截图20230211161340"></p>
<p>子集,运算封闭,构成群.</p>
<h2 id="6-3-子群的性质"><a href="#6-3-子群的性质" class="headerlink" title="6.3 子群的性质:"></a>6.3 子群的性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211161509.png" alt="QQ截图20230211161509"></p>
<h3 id="判别子群的方法"><a href="#判别子群的方法" class="headerlink" title="判别子群的方法:"></a>判别子群的方法:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/fwefsedsf.png" alt="fwefsedsf"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211161614.png" alt="QQ截图20230211161614"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211161632.png" alt="QQ截图20230211161632"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211161708.png" alt="QQ截图20230211161708"></p>
<h1 id="7-变换群"><a href="#7-变换群" class="headerlink" title="7.变换群:"></a>7.变换群:</h1><h2 id="7-1-变换"><a href="#7-1-变换" class="headerlink" title="7.1 变换:"></a>7.1 变换:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211161915.png" alt="QQ截图20230211161915"></p>
<h2 id="7-2-变换群"><a href="#7-2-变换群" class="headerlink" title="7.2 变换群:"></a>7.2 变换群:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162051.png" alt="QQ截图20230211162051"></p>
<h2 id="7-3-群的同构"><a href="#7-3-群的同构" class="headerlink" title="7.3 群的同构:"></a>7.3 群的同构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162120.png" alt="QQ截图20230211162120"></p>
<h2 id="7-4-群的Cayley定理"><a href="#7-4-群的Cayley定理" class="headerlink" title="7.4 群的Cayley定理:"></a>7.4 群的Cayley定理:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162300.png" alt="QQ截图20230211162300"></p>
<h1 id="8-置换群"><a href="#8-置换群" class="headerlink" title="8.置换群:"></a>8.置换群:</h1><h2 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1 定义:"></a>8.1 定义:</h2><p>特殊的变换群.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162432.png" alt="QQ截图20230211162432"></p>
<h2 id="8-2-n元置换的乘法"><a href="#8-2-n元置换的乘法" class="headerlink" title="8.2 n元置换的乘法:"></a>8.2 n元置换的乘法:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162648.png" alt="QQ截图20230211162648"></p>
<h2 id="8-3-n元置换的性质"><a href="#8-3-n元置换的性质" class="headerlink" title="8.3 n元置换的性质:"></a>8.3 n元置换的性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162738.png" alt="QQ截图20230211162738"></p>
<h2 id="8-4-置换群"><a href="#8-4-置换群" class="headerlink" title="8.4 置换群:"></a>8.4 置换群:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162820.png" alt="QQ截图20230211162820"></p>
<h1 id="9-循环群"><a href="#9-循环群" class="headerlink" title="9.循环群:"></a>9.循环群:</h1><h2 id="9-1-定义"><a href="#9-1-定义" class="headerlink" title="9.1 定义:"></a>9.1 定义:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211162949.png" alt="QQ截图20230211162949"></p>
<p>循环群必定是交换群.</p>
<h2 id="9-2-循环群的性质"><a href="#9-2-循环群的性质" class="headerlink" title="9.2 循环群的性质:"></a>9.2 循环群的性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211163226.png" alt="QQ截图20230211163226"></p>
<h2 id="9-3-循环群的子群"><a href="#9-3-循环群的子群" class="headerlink" title="9.3 循环群的子群:"></a>9.3 循环群的子群:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211163340.png" alt="QQ截图20230211163340"></p>
<h1 id="10-子群的陪集"><a href="#10-子群的陪集" class="headerlink" title="10. 子群的陪集:"></a>10. 子群的陪集:</h1><h2 id="10-1-陪集的定义"><a href="#10-1-陪集的定义" class="headerlink" title="10.1 陪集的定义:"></a>10.1 陪集的定义:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211164730.png" alt="QQ截图20230211164730"></p>
<h2 id="10-2-左陪集的基本性质"><a href="#10-2-左陪集的基本性质" class="headerlink" title="10.2 左陪集的基本性质:"></a>10.2 左陪集的基本性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165008.png" alt="QQ截图20230211165008"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165019.png" alt="QQ截图20230211165019"></p>
<h2 id="10-3-右陪集的基本性质"><a href="#10-3-右陪集的基本性质" class="headerlink" title="10.3 右陪集的基本性质:"></a>10.3 右陪集的基本性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165111.png" alt="QQ截图20230211165111"></p>
<h2 id="10-4-陪集的基本性质"><a href="#10-4-陪集的基本性质" class="headerlink" title="10.4 陪集的基本性质:"></a>10.4 陪集的基本性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165158.png" alt="QQ截图20230211165158"></p>
<h2 id="10-5-Lagrange定理"><a href="#10-5-Lagrange定理" class="headerlink" title="10.5 Lagrange定理:"></a>10.5 Lagrange定理:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165259.png" alt="QQ截图20230211165259"></p>
<h1 id="11-群的同态基本定理"><a href="#11-群的同态基本定理" class="headerlink" title="11. 群的同态基本定理:"></a>11. 群的同态基本定理:</h1><h2 id="11-1-正规子群与商群"><a href="#11-1-正规子群与商群" class="headerlink" title="11.1 正规子群与商群:"></a>11.1 正规子群与商群:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165646.png" alt="QQ截图20230211165646"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165708.png" alt="QQ截图20230211165708"></p>
<h2 id="11-2-正规子群的判别定理"><a href="#11-2-正规子群的判别定理" class="headerlink" title="11.2 正规子群的判别定理:"></a>11.2 正规子群的判别定理:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211165821.png" alt="QQ截图20230211165821"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211170106.png" alt="QQ截图20230211170106"></p>
<h1 id="12-环"><a href="#12-环" class="headerlink" title="12.环:"></a>12.环:</h1><h2 id="12-1-环的定义"><a href="#12-1-环的定义" class="headerlink" title="12.1 环的定义:"></a>12.1 环的定义:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211170310.png" alt="QQ截图20230211170310"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211170331.png" alt="QQ截图20230211170331"></p>
<h2 id="12-2-环的运算性质"><a href="#12-2-环的运算性质" class="headerlink" title="12.2 环的运算性质:"></a>12.2 环的运算性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211170428.png" alt="QQ截图20230211170428"></p>
<h2 id="12-3-零因子"><a href="#12-3-零因子" class="headerlink" title="12.3 零因子:"></a>12.3 零因子:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211170532.png" alt="QQ截图20230211170532"></p>
<h2 id="12-4-特殊的环"><a href="#12-4-特殊的环" class="headerlink" title="12.4 特殊的环:"></a>12.4 特殊的环:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211170740.png" alt="QQ截图20230211170740"></p>
<h1 id="13-格"><a href="#13-格" class="headerlink" title="13.格:"></a>13.格:</h1><h2 id="13-1-定义"><a href="#13-1-定义" class="headerlink" title="13.1 定义:"></a>13.1 定义:</h2><p>偏序关系,自反,反对称,传递的关系称为偏序关系.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214110232.png" alt="QQ截图20230214110232"></p>
<p>上确界:比两者都大,而却在这个偏序集中.符合这些条件的数里面最小的.</p>
<h2 id="13-2-格的对偶原理"><a href="#13-2-格的对偶原理" class="headerlink" title="13.2 格的对偶原理:"></a>13.2 格的对偶原理:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214110703.png" alt="QQ截图20230214110703"></p>
<h2 id="13-3-格的性质"><a href="#13-3-格的性质" class="headerlink" title="13.3 格的性质:"></a>13.3 格的性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214111418.png" alt="QQ截图20230214111418"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214112440.png" alt="QQ截图20230214112440"></p>
<h2 id="13-4-格作为代数系统"><a href="#13-4-格作为代数系统" class="headerlink" title="13.4 格作为代数系统:"></a>13.4 格作为代数系统:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214115726.png" alt="QQ截图20230214115726"></p>
<h2 id="13-5-子格"><a href="#13-5-子格" class="headerlink" title="13.5 子格:"></a>13.5 子格:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214115835.png" alt="QQ截图20230214115835"></p>
<p>判别法:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214115906.png" alt="QQ截图20230214115906"></p>
<h2 id="13-6-格的同态和同构"><a href="#13-6-格的同态和同构" class="headerlink" title="13.6 格的同态和同构:"></a>13.6 格的同态和同构:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214120020.png" alt="QQ截图20230214120020"></p>
<h2 id="13-7-有界格"><a href="#13-7-有界格" class="headerlink" title="13.7 有界格:"></a>13.7 有界格:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214120107.png" alt="QQ截图20230214120107"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214120134.png" alt="QQ截图20230214120134"></p>
<p>补元:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214120210.png" alt="QQ截图20230214120210"></p>
<h2 id="13-8-分配格"><a href="#13-8-分配格" class="headerlink" title="13.8 分配格:"></a>13.8 分配格:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214153931.png" alt="QQ截图20230214153931"></p>
<p>符合分配率的格.</p>
<p>性质:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214154040.png" alt="QQ截图20230214154040"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214154052.png" alt="QQ截图20230214154052"></p>
<h1 id="14-布尔代数"><a href="#14-布尔代数" class="headerlink" title="14.布尔代数:"></a>14.布尔代数:</h1><h2 id="14-1-定义"><a href="#14-1-定义" class="headerlink" title="14.1 定义:"></a>14.1 定义:</h2><p>有补分配格称为布尔代数.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214154214.png" alt="QQ截图20230214154214"></p>
<h2 id="14-2-性质"><a href="#14-2-性质" class="headerlink" title="14.2 性质:"></a>14.2 性质:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214154247.png" alt="QQ截图20230214154247"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214154256.png" alt="QQ截图20230214154256"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230214154310.png" alt="QQ截图20230214154310"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2023/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h1 id="1-目录"><a href="#1-目录" class="headerlink" title="1.目录:"></a>1.目录:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204152953.png" alt="QQ截图20230204152953"></p>
<h1 id="2-冯诺依曼计算机模型"><a href="#2-冯诺依曼计算机模型" class="headerlink" title="2.冯诺依曼计算机模型:"></a>2.冯诺依曼计算机模型:</h1><h2 id="2-1-基本组成"><a href="#2-1-基本组成" class="headerlink" title="2.1 基本组成:"></a>2.1 基本组成:</h2><p>运算器,存储器,输入单元,输出单元,控制器.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153113.png" alt="QQ截图20230204153113"></p>
<p>改进型:以存储器为中心:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153233.png" alt="QQ截图20230204153233"></p>
<h2 id="2-2-基本特征"><a href="#2-2-基本特征" class="headerlink" title="2.2 基本特征:"></a>2.2 基本特征:</h2><p>组成,存储器,程序.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153137.png" alt="QQ截图20230204153137"></p>
<p>二进制,相同,pc</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153151.png" alt="QQ截图20230204153151"></p>
<h1 id="3-计算机基本组成"><a href="#3-计算机基本组成" class="headerlink" title="3.计算机基本组成:"></a>3.计算机基本组成:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153312.png" alt="QQ截图20230204153312"></p>
<h2 id="3-1-硬件"><a href="#3-1-硬件" class="headerlink" title="3.1 硬件:"></a>3.1 硬件:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153355.png" alt="QQ截图20230204153355"></p>
<h3 id="3-1-1-辅存"><a href="#3-1-1-辅存" class="headerlink" title="3.1.1 辅存:"></a>3.1.1 辅存:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153432.png" alt="QQ截图20230204153432"></p>
<h3 id="3-1-2-处理单元-PU"><a href="#3-1-2-处理单元-PU" class="headerlink" title="3.1.2 处理单元:PU"></a>3.1.2 处理单元:PU</h3><p>运算单元＋控制单元+暂存单元等于处理单元.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153709.png" alt="QQ截图20230204153709"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153812.png" alt="QQ截图20230204153812"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204153842.png" alt="QQ截图20230204153842"></p>
<h2 id="3-2-软件"><a href="#3-2-软件" class="headerlink" title="3.2 软件:"></a>3.2 软件:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154038.png" alt="QQ截图20230204154038"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154114.png" alt="QQ截图20230204154050"></p>
<h2 id="3-3-计算机组成与计算机实现"><a href="#3-3-计算机组成与计算机实现" class="headerlink" title="3.3 计算机组成与计算机实现:"></a>3.3 计算机组成与计算机实现:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154155.png" alt="QQ截图20230204154155"></p>
<h2 id="3-4-指令集"><a href="#3-4-指令集" class="headerlink" title="3.4 指令集:"></a>3.4 指令集:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154509.png" alt="QQ截图20230204154509"></p>
<h2 id="3-5-计算机性能评价"><a href="#3-5-计算机性能评价" class="headerlink" title="3.5 计算机性能评价:"></a>3.5 计算机性能评价:</h2><h3 id="3-5-1-机器字长"><a href="#3-5-1-机器字长" class="headerlink" title="3.5.1 机器字长"></a>3.5.1 机器字长</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154530.png" alt="QQ截图20230204154530"></p>
<h3 id="3-5-2-主存储器容量"><a href="#3-5-2-主存储器容量" class="headerlink" title="3.5.2 主存储器容量"></a>3.5.2 主存储器容量</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154550.png" alt="QQ截图20230204154550"></p>
<h3 id="3-5-3-处理速度"><a href="#3-5-3-处理速度" class="headerlink" title="3.5.3 处理速度:"></a>3.5.3 处理速度:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154603.png" alt="QQ截图20230204154603"></p>
<h3 id="3-5-4-主频"><a href="#3-5-4-主频" class="headerlink" title="3.5.4 主频:"></a>3.5.4 主频:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154615.png" alt="QQ截图20230204154615"></p>
<h1 id="4-总线技术"><a href="#4-总线技术" class="headerlink" title="4. 总线技术:"></a>4. 总线技术:</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述:"></a>4.1 概述:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204154939.png" alt="QQ截图20230204154939"></p>
<h2 id="4-2-特性"><a href="#4-2-特性" class="headerlink" title="4.2 特性:"></a>4.2 特性:</h2><h3 id="4-2-1-功能特性"><a href="#4-2-1-功能特性" class="headerlink" title="4.2.1 功能特性"></a>4.2.1 功能特性</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204155020.png" alt="QQ截图20230204155020"></p>
<h3 id="4-2-2-物理特性"><a href="#4-2-2-物理特性" class="headerlink" title="4.2.2 物理特性:"></a>4.2.2 物理特性:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204155035.png" alt="QQ截图20230204155035"></p>
<h3 id="4-2-3-电气特性"><a href="#4-2-3-电气特性" class="headerlink" title="4.2.3 电气特性:"></a>4.2.3 电气特性:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204155047.png" alt="QQ截图20230204155047"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204155113.png" alt="QQ截图20230204155113"></p>
<h3 id="4-2-4-时间特性"><a href="#4-2-4-时间特性" class="headerlink" title="4.2.4 时间特性:"></a>4.2.4 时间特性:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204155227.png" alt="QQ截图20230204155227"></p>
<h3 id="4-2-5-收发特性-最重要"><a href="#4-2-5-收发特性-最重要" class="headerlink" title="4.2.5 收发特性(最重要):"></a>4.2.5 收发特性(最重要):</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204155322.png" alt="QQ截图20230204155322"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230204155346.png" alt="QQ截图20230204155346"></p>
<h2 id="4-3-分类"><a href="#4-3-分类" class="headerlink" title="4.3 分类:"></a>4.3 分类:</h2><h3 id="4-3-1-位置分类"><a href="#4-3-1-位置分类" class="headerlink" title="4.3.1 位置分类:"></a>4.3.1 位置分类:</h3><p>片内总线.cpu芯片内.</p>
<p>系统总线.各个部件之间信息传输.</p>
<h3 id="4-3-2-功能分类"><a href="#4-3-2-功能分类" class="headerlink" title="4.3.2 功能分类:"></a>4.3.2 功能分类:</h3><p>数据总线:db:双向.</p>
<p>地址总线:一组用来指出数据总线上的数据所对应的内存单元地址或I&#x2F;O外设地址的总线。单向,由cpu发出.</p>
<p>控制总线:发送控制信号.单&#x2F;双向.</p>
<p>外总线:用于两个系统之间的连接通信.</p>
<h3 id="4-3-3-总线小结"><a href="#4-3-3-总线小结" class="headerlink" title="4.3.3 总线小结:"></a>4.3.3 总线小结:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206151023.png" alt="QQ截图20230206151023"></p>
<h2 id="4-4-总线结构"><a href="#4-4-总线结构" class="headerlink" title="4.4 总线结构:"></a>4.4 总线结构:</h2><h3 id="4-4-1-单总线结构"><a href="#4-4-1-单总线结构" class="headerlink" title="4.4.1 单总线结构:"></a>4.4.1 单总线结构:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206151155.png" alt="QQ截图20230206151155"></p>
<h3 id="4-4-2-双总线结构"><a href="#4-4-2-双总线结构" class="headerlink" title="4.4.2 双总线结构:"></a>4.4.2 双总线结构:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206151231.png" alt="QQ截图20230206151231"></p>
<h3 id="4-4-3-三总线结构"><a href="#4-4-3-三总线结构" class="headerlink" title="4.4.3 三总线结构:"></a>4.4.3 三总线结构:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206151300.png" alt="QQ截图20230206151300"></p>
<h2 id="4-5-总线控制"><a href="#4-5-总线控制" class="headerlink" title="4.5 总线控制:"></a>4.5 总线控制:</h2><h3 id="4-5-1-总线的基本特性"><a href="#4-5-1-总线的基本特性" class="headerlink" title="4.5.1 总线的基本特性:"></a>4.5.1 总线的基本特性:</h3><p>电子计算机的总线具有两个特性：发送的互斥性和接受的共享性。</p>
<p>为了协调总线上各个部件对总线的争用、避免发生总线冲突，必须有一个总线控制器来对总线的使用进行分配和管理。</p>
<p>拥有总线控制权的总线部件，称为总线的主部件&#x2F;主设备. 被主部件访问的部件称为从部件&#x2F;从设备。 </p>
<h3 id="4-5-2-总线仲裁"><a href="#4-5-2-总线仲裁" class="headerlink" title="4.5.2 总线仲裁:"></a>4.5.2 总线仲裁:</h3><p>当总线上有多个候选的主部件同时申请使用总线时，必须有一个总线控制机构按照某种策略（优先次序）对申请进行裁决，这就叫做总线仲裁。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206151503.png" alt="QQ截图20230206151503"></p>
<h4 id="4-5-2-1-链式查询方式"><a href="#4-5-2-1-链式查询方式" class="headerlink" title="4.5.2.1 链式查询方式:"></a>4.5.2.1 链式查询方式:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206151624.png" alt="QQ截图20230206151624"></p>
<h4 id="4-5-2-2-计数器定时"><a href="#4-5-2-2-计数器定时" class="headerlink" title="4.5.2.2 计数器定时:"></a>4.5.2.2 计数器定时:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206151719.png" alt="QQ截图20230206151719"></p>
<h3 id="4-5-3-通信控制"><a href="#4-5-3-通信控制" class="headerlink" title="4.5.3 通信控制:"></a>4.5.3 通信控制:</h3><p>总线通信中，发出数据的部件称为源部件，                         接收数据的部件称为目的部件。</p>
<p>为了完成一次有效的通信，源部件与目的部件之间需要进行一系列有时序限制的操作。</p>
<p>基于“无须感知”观点进行总线通信控制的通信称为同步通信.</p>
<p>基于“需要感知”观点进行总线通信控制的通信称为异步通信.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206152301.png" alt="QQ截图20230206152301"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206152316.png" alt="QQ截图20230206152316"></p>
<h4 id="4-5-3-1-半同步通信"><a href="#4-5-3-1-半同步通信" class="headerlink" title="4.5.3.1 半同步通信:"></a>4.5.3.1 半同步通信:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206152407.png" alt="QQ截图20230206152407"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206152428.png" alt="QQ截图20230206152428"></p>
<h4 id="4-5-3-2-分离式通信"><a href="#4-5-3-2-分离式通信" class="headerlink" title="4.5.3.2 分离式通信:"></a>4.5.3.2 分离式通信:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206152636.png" alt="QQ截图20230206152636"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206213009.png" alt="QQ截图20230206213009"></p>
<h4 id="4-5-3-3-总结"><a href="#4-5-3-3-总结" class="headerlink" title="4.5.3.3 总结:"></a>4.5.3.3 总结:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206213130.png" alt="QQ截图20230206213130"></p>
<h2 id="4-6-总线的性能指标："><a href="#4-6-总线的性能指标：" class="headerlink" title="4.6 总线的性能指标："></a>4.6 总线的性能指标：</h2><p>位宽：总线一次同时传送的信息位数或所需的线数。即一次操作可以传输的数据位数。主要是指数据总线的数目。</p>
<p>总线宽度不会超过微处理器外部数据总线的宽度。</p>
<p>工作时钟频率：控制总线中的时钟信号线所提供的时钟频率。 ISA和EISA总线为8MHz， PCI总线为33.3 MHz。 </p>
<p>标准传输率：总线带宽。总线本身所能达到的最高传送速率。</p>
<p> 总线带宽＝总线位宽×总线工作频率&#x2F;8。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206213511.png" alt="QQ截图20230206213511"></p>
<h2 id="4-7-总线标准："><a href="#4-7-总线标准：" class="headerlink" title="4.7 总线标准："></a>4.7 总线标准：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206213548.png" alt="QQ截图20230206213548"></p>
<p> ISA(Industrial Standard Architecture)工业标准结构总线。工作频率为8MHz左右，数据线为16位（即16位插槽）；地址线为24位。EISA(Extended Industrial Standard Architecture)扩展工业标准结构总线.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206213753.png" alt="QQ截图20230206213753"></p>
<h2 id="4-8-总线重点题："><a href="#4-8-总线重点题：" class="headerlink" title="4.8 总线重点题："></a>4.8 总线重点题：</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206213942.png" alt="QQ截图20230206213942"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206214014.png" alt="QQ截图20230206214014"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206214021.png" alt="QQ截图20230206214021"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206214142.png" alt="QQ截图20230206214142"></p>
<p> 总线带宽＝总线位宽×(总线工作频率(位数))&#x2F;8。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230206214414.png" alt="QQ截图20230206214414"></p>
<h1 id="5-存储系统"><a href="#5-存储系统" class="headerlink" title="5. 存储系统:"></a>5. 存储系统:</h1><h2 id="5-1-存储器的分类"><a href="#5-1-存储器的分类" class="headerlink" title="5.1 存储器的分类:"></a>5.1 存储器的分类:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093233.png" alt="QQ截图20230210093233"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093255.png" alt="QQ截图20230210093255"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093453.png" alt="QQ截图20230210093453"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093528.png" alt="QQ截图20230210093528"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093553.png" alt="QQ截图20230210093553"></p>
<p>主存可以直接被cpu访问,辅存无法直接被CPU访问.</p>
<h2 id="5-2-存储器性能评价"><a href="#5-2-存储器性能评价" class="headerlink" title="5.2 存储器性能评价:"></a>5.2 存储器性能评价:</h2><h3 id="5-2-1-容量"><a href="#5-2-1-容量" class="headerlink" title="5.2.1 容量:"></a>5.2.1 容量:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093729.png" alt="QQ截图20230210093729"></p>
<h3 id="5-2-2-速度"><a href="#5-2-2-速度" class="headerlink" title="5.2.2 速度:"></a>5.2.2 速度:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093817.png" alt="QQ截图20230210093817"></p>
<p>存储周期＝存取时间+间隔时间.</p>
<h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽:"></a>带宽:</h5><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210093956.png" alt="QQ截图20230210093956"></p>
<h3 id="5-2-3-功耗与可靠性"><a href="#5-2-3-功耗与可靠性" class="headerlink" title="5.2.3 功耗与可靠性:"></a>5.2.3 功耗与可靠性:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094031.png" alt="QQ截图20230210094031"></p>
<h2 id="5-3-存储器访问的局部性原理"><a href="#5-3-存储器访问的局部性原理" class="headerlink" title="5.3 存储器访问的局部性原理:"></a>5.3 存储器访问的局部性原理:</h2><p>经过对处理器访问主存储器情况的统计发现，无论是取指令还是存取数据,处理器访问的存储单元趋向于聚集在一个相对较小的连续存储单元区域内.</p>
<p> 这种现象称为存储器访问的局部性原理。</p>
<p>分为时间局部性和空间局部性.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094159.png" alt="QQ截图20230210094159"></p>
<p>时间局部性是访问程序,空间局部性是访问连续大容量存放的数据.<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094239.png" alt="QQ截图20230210094239"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094416.png" alt="QQ截图20230210094416"></p>
<h3 id="5-3-1-层次访问存储系统"><a href="#5-3-1-层次访问存储系统" class="headerlink" title="5.3.1 层次访问存储系统:"></a>5.3.1 层次访问存储系统:</h3><p>频繁访问的抽出来,放到特定的存储模块内.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094611.png" alt="QQ截图20230210094611"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094646.png" alt="QQ截图20230210094646"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094743.png" alt="QQ截图20230210094743"></p>
<p>如果不采用这种策略,那么所有的数据都会通过m1读到,命中率自然也就是百分百了.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210094936.png" alt="QQ截图20230210094936"></p>
<p>尽量要让周期要短,而价格更低.</p>
<h2 id="5-4-半导体存储器"><a href="#5-4-半导体存储器" class="headerlink" title="5.4 半导体存储器:"></a>5.4 半导体存储器:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095050.png" alt="QQ截图20230210095050"></p>
<p>半导体存储器都是随机访问型的,访问任何一块地址所有的时间都是相等的,与单元地址的大小无关,根据地址进行搜索.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095206.png" alt="QQ截图20230210095206"></p>
<h3 id="5-4-1-sRAM"><a href="#5-4-1-sRAM" class="headerlink" title="5.4.1 sRAM:"></a>5.4.1 sRAM:</h3><p>主要分两种类型.双极型和MOS型.</p>
<p>存储1和0的原理:导通:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095512.png" alt="QQ截图20230210095512"></p>
<p>存储并联拓展.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095529.png" alt="QQ截图20230210095529"></p>
<p>举例:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095630.png" alt="QQ截图20230210095630"></p>
<h3 id="组成与地址译码"><a href="#组成与地址译码" class="headerlink" title="组成与地址译码:"></a>组成与地址译码:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095753.png" alt="QQ截图20230210095753"></p>
<h3 id="单译码"><a href="#单译码" class="headerlink" title="单译码:"></a>单译码:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095835.png" alt="QQ截图20230210095835"></p>
<h3 id="双译码"><a href="#双译码" class="headerlink" title="双译码:"></a>双译码:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210095916.png" alt="QQ截图20230210095916"></p>
<h3 id="典型芯片"><a href="#典型芯片" class="headerlink" title="典型芯片:"></a>典型芯片:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210100000.png" alt="QQ截图20230210100000"></p>
<h3 id="5-4-2-dRAM"><a href="#5-4-2-dRAM" class="headerlink" title="5.4.2 dRAM:"></a>5.4.2 dRAM:</h3><p>动态RAM.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210100341.png" alt="QQ截图20230210100341"></p>
<p>用电容的充电,放电来表示0.1.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210100428.png" alt="QQ截图20230210100428"></p>
<h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新:"></a>刷新:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210100506.png" alt="QQ截图20230210100506"></p>
<p>集中式刷新是在一个刷新间隔内，集中一段时间对全部存储单元进行逐行   刷新，在此期间正常的读&#x2F;写操作将被停止，所以这段时间称为死时间。</p>
<p>分散式刷新是指将存取周期分为两段，读写时间＋刷新时间,即将刷新分散到每个读&#x2F;写周期内完成。</p>
<p>把这两者结合起来，就形成了异步刷新。不是每次刷新全部数据，而是一次刷新一部分数据。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210111756.png" alt="QQ截图20230210111756"></p>
<p>二者的区别：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210112004.png" alt="QQ截图20230210112004"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210112016.png" alt="QQ截图20230210112016"></p>
<p>静态存储大数据，动态存储热点数据。</p>
<h2 id="5-5-只读半导体：ROM"><a href="#5-5-只读半导体：ROM" class="headerlink" title="5.5 只读半导体：ROM."></a>5.5 只读半导体：ROM.</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210112202.png" alt="QQ截图20230210112202">MROM:以晶体管（如二极管、双极型三极管或MOS管)的“有&#x2F;无”来代表“0&#x2F;1”，即每个存储基元的信息是由制造集成电路的掩模来决定的，制造完成后无法改变.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210112249.png" alt="QQ截图20230210112249"></p>
<h3 id="可编程"><a href="#可编程" class="headerlink" title="可编程:"></a>可编程:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210112332.png" alt="QQ截图20230210112332"></p>
<p>只能写一次.</p>
<p>所谓“编程”就是选择某些PN结将其击穿，使其导通。烧断熔丝或击穿PN结，都是不可逆的，所以PROM只允许1次编程。</p>
<h3 id="可擦除可编程"><a href="#可擦除可编程" class="headerlink" title="可擦除可编程:"></a>可擦除可编程:</h3><p>一种可由用户进行编程并可用紫外光擦除的只读存储器。存储在EPROM中内容能够长期保存达几十年之久，而且掉电后其内容也不会丢失。 <img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210112620.png" alt="QQ截图20230210112620"></p>
<h2 id="5-6-主存储器"><a href="#5-6-主存储器" class="headerlink" title="5.6 主存储器:"></a>5.6 主存储器:</h2><h3 id="5-6-1-构成"><a href="#5-6-1-构成" class="headerlink" title="5.6.1 构成:"></a>5.6.1 构成:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210112744.png" alt="QQ截图20230210112744"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210113040.png" alt="QQ截图20230210113040"></p>
<h3 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展:"></a>位扩展:</h3><p>多片芯片同时工作,只增加存储字长.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210113309.png" alt="QQ截图20230210113309"></p>
<p>看看在类似时序图的图中,是否是同在进行工作.</p>
<h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展:"></a>字扩展:</h3><p>增加拓展字的容量.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210113548.png" alt="QQ截图20230210113548"></p>
<p>在时序图中分部工作.</p>
<p>一部分芯片连接同一个译码器的接口.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210113657.png" alt="QQ截图20230210113657"></p>
<h3 id="同时扩展"><a href="#同时扩展" class="headerlink" title="同时扩展:"></a>同时扩展:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210113734.png" alt="QQ截图20230210113734"></p>
<h3 id="5-6-2-与CPU连接"><a href="#5-6-2-与CPU连接" class="headerlink" title="5.6.2 与CPU连接:"></a>5.6.2 与CPU连接:</h3><p>CPU与存储器通过三总线(即系统总线)的连接！</p>
<p>地址总线,数据总线,控制总线.</p>
<h3 id="片选信号形成方法"><a href="#片选信号形成方法" class="headerlink" title="片选信号形成方法:"></a>片选信号形成方法:</h3><h4 id="全译码"><a href="#全译码" class="headerlink" title="全译码:"></a>全译码:</h4><p>除了将地址总线的低位地址直接连至各存储芯片的地址线外，将所有余下的高位地址全部用于译码，译码输出作为各存储芯片片选信号.</p>
<p>高位全部译码.</p>
<h4 id="部分译码"><a href="#部分译码" class="headerlink" title="部分译码:"></a>部分译码:</h4><p>只选用地址总线的一部分进行译码.</p>
<h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法:"></a>线选法:</h4><p>高位每一根线代表一块芯片.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210114324.png" alt="QQ截图20230210114324"></p>
<p>特点:</p>
<p>线选方式的突出优点是无须使用片选译码器</p>
<p>缺点是存储地址空间被分成了相互隔离的区段，造成地址空间的不连续。(片选线多于一位为“0”以及片选线为全“1”的地址空间不能使用)</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211213651.png" alt="QQ截图20230211213651"></p>
<h2 id="5-7-高速缓冲存储器-Cache"><a href="#5-7-高速缓冲存储器-Cache" class="headerlink" title="5.7 高速缓冲存储器: Cache."></a>5.7 高速缓冲存储器: Cache.</h2><p>提升速度.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210114804.png" alt="QQ截图20230210114804"></p>
<p>Cache所体现的是一种思想： “缓存” ，即将经常被用到的东西，放到更加容易方便获取的地方。</p>
<p>没有Cache，计算机照常工作，有了Cache, 计算机工作得快一点！</p>
<p>工作原理:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210114927.png" alt="QQ截图20230210114927"></p>
<h3 id="块"><a href="#块" class="headerlink" title="块:"></a>块:</h3><p>若干个存储单元被称之为一块.</p>
<p>内存与Cache之间是以数据块为单位进行交换的。通常在主存与Cache之间设置一条多字宽的局部数据线。</p>
<p>当Cache不命中时，CPU将在访问目标数据的同时，一并从主存读出来的M   个字，并将其作为一个 块 传送给Cache。这样CPU的下一次访问基本上能够在Cache中命中了.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210115134.png" alt="QQ截图20230210115134"></p>
<h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率:"></a>命中率:</h3><p>命中率：——CPU访问的信息在Cache中的比率。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210115233.png" alt="QQ截图20230210115233"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230211214246.png" alt="QQ截图20230211214246"></p>
<h1 id="6-输入输出-I-x2F-O-接口"><a href="#6-输入输出-I-x2F-O-接口" class="headerlink" title="6.输入输出(I&#x2F;O)接口:"></a>6.输入输出(I&#x2F;O)接口:</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述:"></a>6.1 概述:</h2><p>接口是两个系统或两个部件之间的衔接部分.主要分为软件接口和硬件接口.</p>
<p>IO接口是连接主机与I&#x2F;O设备之间的中间电路或部件，由硬件电路,控制软件构成,是信息传送的桥梁和纽带.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210134116.png" alt="QQ截图20230210134116"></p>
<h3 id="接口与端口"><a href="#接口与端口" class="headerlink" title="接口与端口:"></a>接口与端口:</h3><p>端口（Port）：I&#x2F;o接口电路中可通过编程寻址并进行读&#x2F;写的寄存器.CPU对接口的访问基本上可以认为是对端口的读&#x2F;写。</p>
<p>接口包含端口.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210134229.png" alt="QQ截图20230210134229"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210134520.png" alt="QQ截图20230210134520"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210134601.png" alt="QQ截图20230210134601"></p>
<h2 id="6-2-程序查询方式"><a href="#6-2-程序查询方式" class="headerlink" title="6.2 程序查询方式:"></a>6.2 程序查询方式:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210134707.png" alt="QQ截图20230210134707"></p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断:"></a>中断:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210134825.png" alt="QQ截图20230210134825"></p>
<p>不管一个程序在执行的过程中，是否被中断，    中断多少次，其最终的运行结果必须是唯一的。</p>
<p>当有多个中断源向CPU提出中断请求时，CPU必须坚持的原则是:在任何一个时刻只能为一个中断源的请求提供服务！</p>
<h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统:"></a>中断系统:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210135138.png" alt="QQ截图20230210135138"></p>
<h4 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程:"></a>处理过程:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210135227.png" alt="QQ截图20230210135227"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210135220.png" alt="QQ截图20230210135220"></p>
<p>流程:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210180027.png" alt="QQ截图20230210180027"></p>
<h4 id="单重中断与多重中断"><a href="#单重中断与多重中断" class="headerlink" title="单重中断与多重中断:"></a>单重中断与多重中断:</h4><p>在处理中断的过程中，可能有新的、优先级更高的中断请求到来。当这种现象发生时，若允许CPU暂停现行的中断服务程序，转去处理新的中断请求,这种现象称为多重中断或中断嵌套，否则为单重中断。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210180202.png" alt="QQ截图20230210180202"></p>
<h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽:"></a>中断屏蔽:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210180324.png" alt="QQ截图20230210180324"></p>
<h2 id="6-3-DMA-技术"><a href="#6-3-DMA-技术" class="headerlink" title="6.3 DMA 技术:"></a>6.3 DMA 技术:</h2><p>DMA (Direct Memory Access):直接内存访问。</p>
<p>CPU暂时让出总线的控制权，由专用接口芯片DMAC——DMA控制器，全权控制存储器与I&#x2F;O之间直接进行高速的数据传送。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210180555.png" alt="QQ截图20230210180555"></p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程:"></a>工作过程:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210180718.png" alt="QQ截图20230210180718"></p>
<h3 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式:"></a>共享方式:</h3><h1 id="7-信息的表述与运算"><a href="#7-信息的表述与运算" class="headerlink" title="7. 信息的表述与运算:"></a>7. 信息的表述与运算:</h1><h2 id="7-1-数据表示"><a href="#7-1-数据表示" class="headerlink" title="7.1 数据表示:"></a>7.1 数据表示:</h2><p>定点数: 默认小数点在数值的最前方或者最后方。</p>
<p>真值：真正的数值，即带“＋”、“－”号的数.</p>
<p>机器数： 将符号数字化之后的数。</p>
<h3 id="定点数表示"><a href="#定点数表示" class="headerlink" title="定点数表示:"></a>定点数表示:</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码:"></a>原码:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210181556.png" alt="QQ截图20230210181556"></p>
<p>规律: 正数不变,负数加一.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210181707.png" alt="QQ截图20230210181707"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210181748.png" alt="QQ截图20230210181748"></p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码:"></a>补码:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210182301.png" alt="QQ截图20230210182301"></p>
<h4 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210220326.png" alt="QQ截图20230210220326"></p>
<h4 id="移码"><a href="#移码" class="headerlink" title="移码:"></a>移码:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210220505.png" alt="QQ截图20230210220505"></p>
<p>最小真值的移码为全 0.</p>
<h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示:"></a>浮点数表示:</h3><p>借助于数学中的“科学记数法”，把浮点数转化成定点数。</p>
<p>个浮点数N将被表示成：N &#x3D; M *R的E次方 。</p>
<p>M为尾数,是一个定点小数.</p>
<p>R为基值,是一个整数.</p>
<p>E为阶码,是一个整数.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210220853.png" alt="QQ截图20230210220853"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210220933.png" alt="QQ截图20230210220933"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210221020.png" alt="QQ截图20230210221020"></p>
<p>左移减，右移加。</p>
<h4 id="下溢："><a href="#下溢：" class="headerlink" title="下溢："></a>下溢：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210221107.png" alt="QQ截图20230210221107"></p>
<h4 id="上溢："><a href="#上溢：" class="headerlink" title="上溢："></a>上溢：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210221206.png" alt="QQ截图20230210221206"></p>
<h2 id="7-2-定点数运算："><a href="#7-2-定点数运算：" class="headerlink" title="7.2 定点数运算："></a>7.2 定点数运算：</h2><h3 id="7-2-1-逻辑运算："><a href="#7-2-1-逻辑运算：" class="headerlink" title="7.2.1 逻辑运算："></a>7.2.1 逻辑运算：</h3><p>逻辑运算的特点是按位进行，每一位运算后得到一个独立的结果，对其他位   没有影响。因此，逻辑运算不存在进位、借位、溢出等问题。</p>
<h4 id="非："><a href="#非：" class="headerlink" title="非："></a>非：</h4><p>按位取反.</p>
<h4 id="加："><a href="#加：" class="headerlink" title="加："></a>加：</h4><p>按位求或.</p>
<h4 id="乘："><a href="#乘：" class="headerlink" title="乘："></a>乘：</h4><p>按位求与.</p>
<h4 id="异或："><a href="#异或：" class="headerlink" title="异或："></a>异或：</h4><p>按照位置异或.</p>
<h3 id="7-2-2-移位运算："><a href="#7-2-2-移位运算：" class="headerlink" title="7.2.2 移位运算："></a>7.2.2 移位运算：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210221640.png" alt="QQ截图20230210221640"></p>
<p>总原则：符号位不变。<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210221726.png" alt="QQ截图20230210221726"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210221755.png" alt="QQ截图20230210221755"></p>
<h3 id="7-2-3-加减法运算："><a href="#7-2-3-加减法运算：" class="headerlink" title="7.2.3 加减法运算："></a>7.2.3 加减法运算：</h3><p>计算机通过引入补码将定点数的加、减运算都统一成加法运算，所以参加加、减运算的操作数都必须表示成补码。</p>
<p> 采用补码进行计算还有一个好处，结果的符号位不用单独处理，它是在运算过程中自然形成的。这是采用原码进行计算所不具有的，大大简化了硬件设计。 </p>
<p>公式：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230210221916.png" alt="QQ截图20230210221916"></p>
<p>和的补码等于补码的和。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>风凌夜话</title>
    <url>/2023/02/10/%E9%A3%8E%E5%87%8C%E5%A4%9C%E8%AF%9D/</url>
    <content><![CDATA[<h1 id="风凌夜话"><a href="#风凌夜话" class="headerlink" title="风凌夜话"></a>风凌夜话</h1><p>大江 北上<br>孕育经纬江河 编织千里沃土<br>船载渡口 渡口渡船<br>当微咸的海风吹过<br>风凌渡熙攘乘客的肩头<br>焦急而充满期待的旅人 匆匆翻越过船桨与时光<br>会再与你再一次相遇 把目光收藏</p>
<p>倦容奄奄 体态臃肿的远游客<br>竭力掩饰着<br>被昭彰大河的风暴摧毁的眼睛与衣袂<br>寄着绚丽斑斓 点翠的彩云笺<br>携着为你存留的松花酒与春水茶<br>念着酒醒日暮里 意气飞扬的闪念文字<br>目送着黄昏映在渡口的影子缓缓拉长 拉长<br>留下一个气韵生动的夜晚</p>
<p>悄悄燃点起西窗的红烛<br>庄重地摆正杯箸 大白未浮<br>客人迫不及待的与你分享 记忆里的故事与时光<br>几多喜悦 几多喟叹 几多潸然<br>只夹杂在觥筹交错间 化作克制平淡的点滴字句<br>折竹卧雪 烛火昏黄 风移影动<br>客人与你一同追忆往日的时光<br>让相携的双手或远望的眼眉 都在追忆里悠然镀上纯净的天青色</p>
<p>当星月沉落 暮色青冥 烟火漫卷<br>当拾肉的贪玩孩童飞奔着寻找母亲<br>过客与你 缓缓唱起未来的时光<br>凤冠浓妆 前方似轴戏大幕 春雷震震<br>浅斟低唱 来日寄寻常巷陌 红袖添香<br>你会抚慰过客的内心 再起义武奋扬<br>你会指引过客的步履 赴往春山横波<br>汽船刺耳的汽笛声缓缓吹响<br>过客与你急觉 东方既白早已屏退了白月光<br>残宴既尽 仍有万语千言 唯有娇笑着说着再见<br>过客纵马奔向远方 又携书剑<br>你仍守着这人影绰绰的风凌渡口</p>
<p>日后 行船的一千个夜晚<br>我会再一次想起这个夜晚与你的相遇<br>想起风凌夜话 你我仲夜轻声的语言<br>想起微弱模糊的光线里 你或放肆或温婉的笑容和眉眼<br>在渡口和夜话所不能至的地方<br>诠释着鼓励和希望的意义<br>践行着摇曳烛火下 夜话立下的诺言<br>期盼着下一个黄昏和长夜<br>我与你像侠客与侠女一般绕过万重关山 万里土地 万载时光<br>经行 相遇在下一个熙攘的风凌渡口<br>再一次收藏你的目光<br>再一次拥抱你的语言<br>再一次呢喃你的名字</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>鹤扶摇</title>
    <url>/2023/01/17/%E9%B9%A4%E6%89%B6%E6%91%87/</url>
    <content><![CDATA[<h5 id="鹤扶摇"><a href="#鹤扶摇" class="headerlink" title="鹤扶摇"></a>鹤扶摇</h5><p>长星坠落的青天<br>白云深处展浩然虹霓<br>黄鹤眺望<br>仙人颔首<br>辞人间阴阳交叠<br>尚存凭栏意气<br>无名之辈冲冠 负惬远游<br>追黄鹤跋涉川泽四海<br>以青衫浅袂涤荡满目风尘</p>
<p>黄鹤扶摇于春秋大争之世<br>过落日荒城的古渡与苍翠葱郁的山峡<br>观击楫中流 大江拍岸东去如金刚怒目<br>闻渔樵欸乃次第相接 渐和于风林簌簌<br>过平沙落雁的浅滩与苍木子了的青原<br>抚苇和锵羽音缓缓摇曳<br>拈花与明月光织影交错<br>过琉璃金銮的庙堂与书香琅琅的乡塾<br>慨君王冷眼 士深躬朗声奏对<br>喜蒙童惺忪 师正身顿挫授业<br>过山河朝暮 千秋万象<br>书生只怯懦相问 字字句句</p>
<p>问鹤于洛阳故友 五都豪雄<br>携夭矫钱塘含笑高冠博带<br>为雪白的羽翼镶嵌银枪<br>求桃李春风拥抱的确切深度<br>把与酒杯一同破碎的故梦一一拾起<br>为华枝春满的盛世丈量逆行的最远距离<br>轻轻唤起温暖闪烁的名字<br>捧出以光阴封存的寡淡薄酒</p>
<p>问鹤于九州更迭 风雨如晦<br>立德比邻里天涯间的守望<br>立功升苍生身侧的轻声耳语<br>立言沉绵延大地至深至暗<br>义武奋扬投鞭 霹雳轰鸣的钢铁洪流<br>金击火淬成镇国之器<br>弹指键跃出兴邦之网<br>掀帘洒庭生阖家之谊</p>
<p>问鹤于天上人间 长生证道<br>达观日升月落 苍狗白云 兴替生死<br>逆旅光阴外 向送魂的长歌遥遥挥手<br>汲书秩长卷<br>谛竹林击节<br>覆履江左周郎 博望诸葛 草木东山<br>清涧溪畔黄鹤饮泉 书生回首<br>天门拂尘仙都客<br>气蒸云梦<br>青丝绾颜</p>
<p>仙人驾鹤西征<br>乡野书生挥袖 清越挽歌<br>长相问鹤以万语千言<br>却此欲言又止<br>终究自驿路折返<br>漫漫书剑 漫漫青灯 漫漫少年<br>漫漫追忆西窗红烛下<br>向清凉皓月的承平岁月<br>反复斟酌所谓语言的终极意义<br>在下一个夜晚抽象锤炼<br>化为点滴翰墨<br>或被称为文字 付梓于浩荡青史<br>或伴猿揉长啸 被西风吹彻<br>天地之间</p>
<p>愿黄鹤去而复返<br>自灰港大瞧<br>愿每一个直面惨淡生活的眉间尺<br>都能抽出如虹长剑 微微敛袍颔首<br>远游追鹤<br>藏峰见史<br>守心传道<br>最终化作一句语言 一组剪影<br>一个被珍重为玉器的名字<br>且看<br>鹤乘风扶摇<br>天上仙人</p>
]]></content>
      <categories>
        <category>创作</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title>马克思主义原理</title>
    <url>/2023/02/10/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="马克思主义原理"><a href="#马克思主义原理" class="headerlink" title="马克思主义原理"></a>马克思主义原理</h1><h1 id="1-世界的物质性及发展规律"><a href="#1-世界的物质性及发展规律" class="headerlink" title="1.世界的物质性及发展规律:"></a>1.世界的物质性及发展规律:</h1><h2 id="1-1-哲学"><a href="#1-1-哲学" class="headerlink" title="1.1 哲学:"></a>1.1 哲学:</h2><p>哲学：系统化、理论化的世界观，是对自然知识、</p>
<p>社会知识和思维知识的概括和总结，它提供了对于世界以及人与世界关系的全面而深刻的思考。</p>
<p>全部哲学，特别是近代哲学的重大的基本问题，是思维和存在的关系问题。</p>
<h2 id="1-2-唯物主义和唯心主义"><a href="#1-2-唯物主义和唯心主义" class="headerlink" title="1.2 唯物主义和唯心主义"></a>1.2 唯物主义和唯心主义</h2><p>主观唯心主义:主体之内的精神是世界的本原，认为世界是人的主观意志的产物或表现。</p>
<p>客观唯心主义:主体之外的精神是世界的本原，认为世界是客观精神的产物或表现。</p>
<p>朴素唯物主义:根本观点：用某一种或几种具体的“原初”的物质形态解释世界本原，如水、火、气等，并认为物质形态是运动变化的。</p>
<p>形而上学唯物主义:原子是组成物质的最小单位.</p>
<p>辩证唯物主义:物质.物质的存在:运动,物质决定意识.</p>
<p>人工智能是人类智能的物质化.</p>
<h2 id="1-3-同一性"><a href="#1-3-同一性" class="headerlink" title="1.3 同一性:"></a>1.3 同一性:</h2><p>思维和存在有无同一性，即思维能否认识存在，能否正确认识存在的问题。</p>
<p>唯物论者、彻底唯心论者是可知论者.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212132335.png" alt="QQ截图20230212132335"></p>
<h2 id="1-4-辩证法"><a href="#1-4-辩证法" class="headerlink" title="1.4 辩证法:"></a>1.4 辩证法:</h2><p>事物的联系,发展和矛盾.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212132551.png" alt="QQ截图20230212132551"></p>
<p>矛盾的同一性和斗争性.普遍性和特殊性.</p>
<p>量变与质变.</p>
<p>辩证的否定观念:扬弃.既克服又保留.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212132922.png" alt="QQ截图20230212132922"></p>
<h2 id="1-5-实践与认识"><a href="#1-5-实践与认识" class="headerlink" title="1.5 实践与认识:"></a>1.5 实践与认识:</h2><p>实践是认识的来源.是认识发展的动力.是认识的目的.是检验真理的唯一标准.</p>
<p>认识的本质是主体在实践基础上对客体的能动反映.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212152334.png" alt="QQ截图20230212152334"></p>
<h2 id="1-6-真理"><a href="#1-6-真理" class="headerlink" title="1.6 真理:"></a>1.6 真理:</h2><p>客观性,绝对性,相对性.</p>
<p>真理的内容表明了主客观统一的确定性和发展的无限性.</p>
<p>人们在一定条件下对事物的客观过程及其发展规律的正确认识总是有限度的。</p>
<p>实践是检验真理的唯一标准.</p>
<p>实践标准有确定性和不确定性.</p>
<h1 id="2-人类社会发展规律"><a href="#2-人类社会发展规律" class="headerlink" title="2. 人类社会发展规律:"></a>2. 人类社会发展规律:</h1><p>历史观: 人类对社会历史发展的根本看法和根本观点.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212204345.png" alt="QQ截图20230212204345"></p>
<p>社会存在决定社会意识.</p>
<p>社会意识对社会存在具有能动的反作用.</p>
<h2 id="2-1-生产力与生产关系"><a href="#2-1-生产力与生产关系" class="headerlink" title="2.1 生产力与生产关系:"></a>2.1 生产力与生产关系:</h2><p>生产力决定生产关系.</p>
<p>生产关系要适合生产力.</p>
<h2 id="2-2-经济基础与上层建筑"><a href="#2-2-经济基础与上层建筑" class="headerlink" title="2.2 经济基础与上层建筑:"></a>2.2 经济基础与上层建筑:</h2><p>经济基础决定上层建筑.</p>
<p>上层建筑对经济基础具有能动的反作用.</p>
<h2 id="2-3-社会形态更替"><a href="#2-3-社会形态更替" class="headerlink" title="2.3 社会形态更替:"></a>2.3 社会形态更替:</h2><p>社会形态:经济基础+上层建筑.</p>
<p>根本属性: 生产资料所有关系.</p>
<p>统一性与多样性: 社会演进情况统一.具体过程多样.</p>
<p>必然性,历史选择性.</p>
<p>前进性,曲折性,顺序性,跨越性.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212205223.png" alt="QQ截图20230212205223"></p>
<h2 id="2-4-社会历史发展的动力"><a href="#2-4-社会历史发展的动力" class="headerlink" title="2.4 社会历史发展的动力:"></a>2.4 社会历史发展的动力:</h2><p>根本动力:社会基本矛盾:即生产力和生产关系的矛盾，经济基础和上层建筑的矛盾.</p>
<p>直接动力:阶级斗争和社会革命.</p>
<h2 id="2-5-人民群众在历史发展中的作用"><a href="#2-5-人民群众在历史发展中的作用" class="headerlink" title="2.5 人民群众在历史发展中的作用:"></a>2.5 人民群众在历史发展中的作用:</h2><p>人民群众是历史的创造者.</p>
<p>辩证的评价英雄领袖的作用.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212205534.png" alt="QQ截图20230212205534"></p>
<h1 id="3-资本主义的本质及规律"><a href="#3-资本主义的本质及规律" class="headerlink" title="3. 资本主义的本质及规律:"></a>3. 资本主义的本质及规律:</h1><p>商品经济:交换.</p>
<p>商品:使用价值和价值.</p>
<p>具体劳动和抽象劳动(脑力).</p>
<h2 id="3-1-价值规律"><a href="#3-1-价值规律" class="headerlink" title="3.1 价值规律:"></a>3.1 价值规律:</h2><p>商品价值量是由生产商品的劳动时间决定的.</p>
<p>价格围绕价值上下波动.</p>
<h2 id="3-2-私有制的基本矛盾"><a href="#3-2-私有制的基本矛盾" class="headerlink" title="3.2 私有制的基本矛盾:"></a>3.2 私有制的基本矛盾:</h2><p>私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾。</p>
<p>矛盾产生基础：社会分工和私有制。</p>
<p>矛盾解决途径：交换。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212210333.png" alt="QQ截图20230212210333"></p>
<h2 id="3-3-马克思劳动价值论"><a href="#3-3-马克思劳动价值论" class="headerlink" title="3.3 马克思劳动价值论:"></a>3.3 马克思劳动价值论:</h2><p>资本主义经济制度是以资本主义私有制和雇佣劳动为基础的一种剥削制度.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212210537.png" alt="QQ截图20230212210537"></p>
<h2 id="3-4-剩余价值"><a href="#3-4-剩余价值" class="headerlink" title="3.4 剩余价值:"></a>3.4 剩余价值:</h2><p>劳动不是商品，没有价值.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212210650.png" alt="QQ截图20230212210650"></p>
<p>剩余价值转换为利润.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212210939.png" alt="QQ截图20230212210939"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/QQ%E6%88%AA%E5%9B%BE20230212211038.png" alt="QQ截图20230212211038"></p>
<p>劳动二重性,一句话总结：具体劳动创造使用价值，抽象劳动创造价值。</p>
<h1 id="4-资本主义的发展及其规律"><a href="#4-资本主义的发展及其规律" class="headerlink" title="4. 资本主义的发展及其规律:"></a>4. 资本主义的发展及其规律:</h1><p>垄断资本主义.</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象建模技术</title>
    <url>/2023/03/18/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="面向对象建模技术"><a href="#面向对象建模技术" class="headerlink" title="面向对象建模技术                      "></a>面向对象建模技术                     <a href="af://n2"> </a></h1><h2 id="1-从结构化到面向对象模型"><a href="#1-从结构化到面向对象模型" class="headerlink" title="1.从结构化到面向对象模型:                 "></a>1.从结构化到面向对象模型:                <a href="af://n3"> </a></h2><h3 id="1-1-结构化与面向对象的区别"><a href="#1-1-结构化与面向对象的区别" class="headerlink" title="1.1 结构化与面向对象的区别:                          "></a>1.1 结构化与面向对象的区别:                         <a href="af://n4"> </a></h3><p>结构化思维用过程刻画数据间关系.对象思维直接用类表达数据间关系.结构化中，数据是死的，全部依赖 算法操作.对象思维中，数据是活的，  “她”知道自己的信息(属性)，并能完成自己的工作(操作)  .结构 化思维更像是一个人在解决所有问题.对象思维更像是一个团队的分工协作.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps1.png" alt="img"> </p>
<h3 id="1-2-面向对象方法"><a href="#1-2-面向对象方法" class="headerlink" title="1.2: 面向对象方法:                                   "></a>1.2: 面向对象方法:                                  <a href="af://n7"> </a></h3><p>面向对象方法(Object-Oriented Method)是一种把面向对象的思想应用于软件开发过程中，指导开发  活动的系统方法，简称OO (Object-Oriented)方法.面向对象方法的作用和意义决不只限于编程技术.它 是一种程序设计范型-面向对象程序设计范型；是软件系统开发的方法论-面向对象方法学；是流行的技  术-面向对象技术。</p>
<h3 id="1-3-面向对象技术"><a href="#1-3-面向对象技术" class="headerlink" title="1.3: 面向对象技术:                                   "></a>1.3: 面向对象技术:                                  <a href="af://n9"> </a></h3><p>面向对象技术是一系列指导软件构造的原则(如抽象、封装、多态等)，并通过语言、数据库和其它工 具来支持这些原则.从本质上讲，对象技术是对一系列相关原则的应用OO&#x3D;类+对象+抽象+封装+继承+多 态+消息 … …</p>
<h3 id="1-4-面向对象技术基本点"><a href="#1-4-面向对象技术基本点" class="headerlink" title="1.4: 面向对象技术基本点:                              "></a>1.4: 面向对象技术基本点:                             <a href="af://n11"> </a></h3><p>1.任何客观的事物或实体都是对象。对象组成客观世界，复杂对象可以由简单的对象组成。</p>
<p>2.具有相同数据和操作的对象可以归并为一个类(class ) ，对象是对象类的一个实例。   3.类可以派生出子类，子类继承父类的全部特性(数据和操作)，又可以有自己的新特性。</p>
<p>4.子类与父类形成类的层次结构。  对象之间通过消息传递相互联系。</p>
<h3 id="1-5-面向对象技术的优势"><a href="#1-5-面向对象技术的优势" class="headerlink" title="1.5: 面向对象技术的优势:                              "></a>1.5: 面向对象技术的优势:                             <a href="af://n16"> </a></h3><p>1.顺应人类思维习惯，让软件开发人员在解空间中直接模拟问题空间中的对象及其行为.更要容易被开发 人员所接受.</p>
<p>2.稳定较小的需求变化不会导致系统结构大的改变.</p>
<p>功能最不稳定,数据次之,对象相对最稳定,而面向对象用对象承载功能和数据,用相对稳定的把不稳定 的”包”起来.</p>
<p>3.复用代码重用：类库、框架等重用机制能提高质量，减少由于编制新的系统代码而产生的成本通过继 承、关联、封装等手段.</p>
<p>软件开发组越大，组中每个成员的生产率就越低–Philippe Kahn, Borland公司创始人.</p>
<h3 id="1-6-对象定义"><a href="#1-6-对象定义" class="headerlink" title="1.6: 对象定义:                                       "></a>1.6: 对象定义:                                      <a href="af://n22"> </a></h3><p>对象是一个实体，该实体：</p>
<p>1.具有明确定义的边界和标识边界意味着对象是一个封装体，通过封装来与其它对象分隔.标识则表明每 一个对象都是唯一的(在程序运行的时候，用计算机内存地址表示对象)</p>
<p>2.对象封装了状态和行为对象的状态通过对象的属性(attribute)和关系(relationship)来表达.对象的行为 通过对象的操作(operation),方法(method)和状态机(state machine)来表达</p>
<h3 id="1-7-面向对象相关原则"><a href="#1-7-面向对象相关原则" class="headerlink" title="1.7: 面向对象相关原则:                               "></a>1.7: 面向对象相关原则:                              <a href="af://n26"> </a></h3><h4 id="1-7-1-抽象-Abstraction"><a href="#1-7-1-抽象-Abstraction" class="headerlink" title="1.7.1: 抽象-Abstraction:"></a>1.7.1: 抽象-Abstraction:</h4><p>对象到类的过程就是抽象即将所见到的具体实体抽象成概念，从而在计算机世界中进行描述和各种操作.</p>
<h4 id="1-7-2-封装-Encapsulation"><a href="#1-7-2-封装-Encapsulation" class="headerlink" title="1.7.2: 封装-Encapsulation:"></a>1.7.2: 封装-Encapsulation:</h4><p>封装是对客户(使用者)隐藏具体实现细节.客户只依赖于接口通过封装实现信息隐藏和数据抽象.</p>
<p>比如在c语言中,对数据的访问没有限制.这就导致操作这个数据结构的程序员，必须严格遵守一系列业务 逻辑规则，否则很容易破坏数据的一致性.结构化程序设计处理大项目时，多人协同开发时，本质上无法 保证数据的一致性.</p>
<p>但在面向对象的设计方法中,通过封装把数据隐藏起来,使得该数据无法被其他开发人员随意的修改.</p>
<h4 id="1-7-3-分解-Decomposition"><a href="#1-7-3-分解-Decomposition" class="headerlink" title="1.7.3: 分解-Decomposition:"></a>1.7.3: 分解-Decomposition:</h4><p>分解是指将单个大规模复杂系统划分为多个不同的小构件分解的构件通过抽象、封装等技术形成相对独 立的单元，可以独立设计和开发，从而实现化繁为简、分而治之.</p>
<p>面向对象设计中的模块化，将根据需要将类分组放在一些包中.</p>
<h4 id="1-7-4-泛化-Generalization"><a href="#1-7-4-泛化-Generalization" class="headerlink" title="1.7.4: 泛化-Generalization:"></a>1.7.4: 泛化-Generalization:</h4><p>泛化是类之间的一种isa&#x2F; is kind of 关系,通过该关系一个类(子类)可以共享另外一个或多个类(父 类)的结构和行为.</p>
<p>采用继承(Inheritance)实现泛化关系通过泛化关系，可以建立类之间的层次结构，根据继承层次中父 类的个数不同，分为：单一继承.多重继承(Java不允许).</p>
<h4 id="1-7-5-多态-Polymorphism"><a href="#1-7-5-多态-Polymorphism" class="headerlink" title="1.7.5: 多态-Polymorphism:"></a>1.7.5: 多态-Polymorphism:</h4><p>多态是在统一外表(接口)下隐藏不同实现的能力.</p>
<p>即一个接口可以有不同的实现行为.</p>
<p>是面向对象技术的本质特征.</p>
<p>多态是类型理论中的概念，其中，一个名字可以代表许多不同类的实例，只要它们有共同的超类。</p>
<h4 id="1-7-6-分层-Hierarchy"><a href="#1-7-6-分层-Hierarchy" class="headerlink" title="1.7.6: 分层-Hierarchy:"></a>1.7.6: 分层-Hierarchy:</h4><p>分层是指面向不同的目标建立不同的抽象级别层次，从而在不同的抽象层次对系统进行分解，进一步简 化对系统的理解.</p>
<p>两种分层结构类层次结构：</p>
<p>(1)在不同的抽象级别进行对象的抽象，通过泛化关系，形成类间的继承层次结构.</p>
<p>(2)对象层次结构：是指对象间的组成结构，即大的对象由小的对象组成.</p>
<h4 id="1-7-7-复用-Reuse"><a href="#1-7-7-复用-Reuse" class="headerlink" title="1.7.7: 复用-Reuse:"></a>1.7.7: 复用-Reuse:</h4><p>复用是借助于已有软件的各种有关知识建立新的软件的过程.</p>
<p>将软件看成是由不同功能部分的构件所组成的有机体，每个构件在设计编写时可以被设计成完成同类工 作的通用工具.</p>
<p>如果完成各种工作的构件被建立起来以后，编写特定软件的工作就变成了将各种不同构件进行组合的简 单问题，从而对软件产品的最终质量和维护工作都有本质性的改变.</p>
<p>系统开发各个阶段都可能涉及到复用.</p>
<p>从最底层的代码复用，到设计复用、架构复用，再到需求复用，甚至于延伸到特定业务领域的复用.</p>
<p>复用原则要求设计者不仅针对当前的业务需求开展设计，还需要考虑业务的通用性和可扩展性等问题， 从而设计抽象层次高、复用粒度大的组件.</p>
<h1 id="2-可视化建模"><a href="#2-可视化建模" class="headerlink" title="2.可视化建模:                             "></a>2.可视化建模:                            <a href="af://n56"> </a></h1><h2 id="2-1-瀑布模型"><a href="#2-1-瀑布模型" class="headerlink" title="2.1: 瀑布模型:                                       "></a>2.1: 瀑布模型:                                      <a href="af://n57"> </a></h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps2.jpg" alt="img"> </p>
<p>1.瀑布模型的性质:</p>
<p>不同的开发阶段应该被连贯地进行.每个阶段都有文档，上一个阶段的文档是下一个阶段文档工作的基础. 系统部署后，进入维护阶段.</p>
<p>2.瀑布模型的优点:</p>
<p>将软件开发当做工程对待.</p>
<p>3.瀑布模型的缺点:</p>
<p>没有引入迭代.</p>
<h2 id="2-2-统一过程模型"><a href="#2-2-统一过程模型" class="headerlink" title="2.2: 统一过程模型:                                   "></a>2.2: 统一过程模型:                                  <a href="af://n64"> </a></h2><p>统一过程(THE UNIFIED PROCESS)试图在整体开发过程模型中结合迭代与渐增两种思想.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps3.jpg" alt="img"> </p>
<p>特点:</p>
<p>每项活动都可以在任何一次迭代发生，但是重心随着开发过程的进行，每次迭代的重心都不同.</p>
<h2 id="2-3-UML-统一建模语言"><a href="#2-3-UML-统一建模语言" class="headerlink" title="2.3: UML:统一建模语言                           "></a>2.3: UML:统一建模语言                          <a href="af://n69"> </a></h2><p>UML — Unified Modeling Language.</p>
<p>UML是一种标准的图形化建模语言，是面向对象分析与设计的标准表示，它不是一种程序设计语言，而 是一种可视化的建模语言(用于分析设计).</p>
<p>Unified Modeling Language (统一建模语言)是对象管理组织(OMG)制定的一个通用的、可视化的 建模语言标准，可以用来可视化(visualize)  、描述(specify)、构造(construct)和文档化      (document)软件密集型系统的各种工件(artifacts，又译制品)  .</p>
<h2 id="2-4-结构"><a href="#2-4-结构" class="headerlink" title="2.4: 结构:                                           "></a>2.4: 结构:                                          <a href="af://n73"> </a></h2><p>UML主要包括两类图:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps4.png" alt="img"> </p>
<p>结构图: 结构图用于表示系统中元素的静态结构，例如系统组织结构，例如，类图系统的物理元素，例 如，包，组件图运行时配置等.</p>
<p>行为图: 用来描述动态行为对象的创建与销毁对象按照顺序发送消息外部事件引发了特定的对象的操作.</p>
<h2 id="2-5-4-1模型"><a href="#2-5-4-1模型" class="headerlink" title="2.5: 4+1模型:                                        "></a>2.5: 4+1模型:                                       <a href="af://n77"> </a></h2><p>UML试图在5个方面刻画一个软件.</p>
<p>系统的结构用五个视图(Views)描述，用例视图在集成其他四个视图的内容中起着特殊的作用。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps5.jpg" alt="img"> </p>
<h2 id="2-6-类图"><a href="#2-6-类图" class="headerlink" title="2.6: 类图:                                           "></a>2.6: 类图:                                          <a href="af://n81"> </a></h2><p>类图表示类的存在以及从逻辑层面表达它们之间的关系.</p>
<p>类图的基本要素：类，以及它们之间的关系.</p>
<p>类图中一个类的结构:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps6.png" alt="img"> </p>
<p>类图中类之间的关系:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps7.jpg" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps8.png" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps9.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps10.png" alt="img"></p>
<h2 id="2-7-聚合与组合"><a href="#2-7-聚合与组合" class="headerlink" title="2.7: 聚合与组合:"></a>2.7: 聚合与组合:</h2><p>聚合 (aggregation): “part of” 关系.不是物理包含关系.表示一种弱关联.有独立的生命周期. </p>
<p>组合(composition)的概念：整体包括部分,是一种物理包含.一个部分对象仅仅对应于1个整体对象；该整 体对象如果不存在，则部分对象也就没有存在的必要组合中，创建“整体”对象，则要创建“部分”对象；消 灭“整体”对象，其组合的“部分”也必须被消灭。相反，如果“部分”对象被消灭，则“整体”对象也必须被消 灭.一般在构造函数中引入.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps11.png" alt="img"> </p>
<h2 id="2-8-类的可视性记号"><a href="#2-8-类的可视性记号" class="headerlink" title="2.8: 类的可视性记号:                                 "></a>2.8: 类的可视性记号:                                <a href="af://n94"> </a></h2><p>出现在uml类图中的符号:</p>
<p>Public (+)：所有的其它类都可以访问 .</p>
<p>Protected (#)：类中的元素以及子类中的元素可访问 .</p>
<p>Private (-): 仅类中的元素可以访问.</p>
<p>Package (~): 仅仅同一个包中的元素可以访问.</p>
<h3 id="2-8-2-对象图"><a href="#2-8-2-对象图" class="headerlink" title="2.8.2: 对象图:"></a>2.8.2: 对象图:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps12.png" alt="img"> </p>
<h2 id="2-9-构件图"><a href="#2-9-构件图" class="headerlink" title="2.9: 构件图:                                         "></a>2.9: 构件图:                                        <a href="af://n103"> </a></h2><p>构件(Component)是系统中遵从一组接口且提供其实现的物理的、可替换的部分。</p>
<p>构件图(Component diagram)则是显示一组组件以及它们之间的相互关系，包括编译、链接还在执 行时组件之间的依赖关系。</p>
<p>一个构件代表一个可复用的软件；提供一批有意义的功能在最底层，一个构件是一群(自己内聚的)松散耦 合的类系统中的每一个类必须在一个构件之中，或者在系统的顶层；一个构件可以包含其它构件.</p>
<p>可以利用构件层次地分解一个系统与表达系统的逻辑结构 (这是在UML2.0中新引进的；面向构件编程).</p>
<h3 id="2-9-1-基本元素"><a href="#2-9-1-基本元素" class="headerlink" title="2.9.1: 基本元素:"></a>2.9.1: 基本元素:</h3><p>components,构件</p>
<p>their interfaces, 接口</p>
<p>their realizations. 接口实现</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps14.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps15.png" alt="img"> </p>
<h2 id="2-10-部署图-Deployment-Diagram"><a href="#2-10-部署图-Deployment-Diagram" class="headerlink" title="2.10: 部署图(Deployment Diagram):                  "></a>2.10: 部署图(Deployment Diagram):                 <a href="af://n114"> </a></h2><p>部署图被用来表示将工件分配到系统的各个物理设计节点的情况。部署图代表系统的工件结构的视图. 使用部署图表示系统执行平台的物理节点的集合；这些节点组成了系统的执行平台。</p>
<p>三个基本的部署图元素：工件、节点、连接符号.</p>
<h2 id="2-11-用例图"><a href="#2-11-用例图" class="headerlink" title="2.11: 用例图:                                        "></a>2.11: 用例图:                                       <a href="af://n118"> </a></h2><p>用例图：描述将要创建的系统的环境与系统应该提供的功能描述谁与系统交互；即(外部世界) 用户让系 统做什么.</p>
<p>用例描述包括将系统作为一个黑匣子。描述人与系统之间的交互。</p>
<p>比如一个人去银行.他与系统进行的交互就是存现金,取现金,那么这就是两个用例.</p>
<h2 id="2-12-活动图"><a href="#2-12-活动图" class="headerlink" title="2.12: 活动图:                                        "></a>2.12: 活动图:                                       <a href="af://n122"> </a></h2><p>与流程图比较类似.</p>
<p>]活动图提供了活动流的可视化描述(系统中，业务中，工作流，其它流程中)；</p>
<p>活动图关注应有的活动，以及谁负责完成这些活动.</p>
<h1 id="3-建模过程"><a href="#3-建模过程" class="headerlink" title="3.建模过程:                               "></a>3.建模过程:                              <a href="af://n126"> </a></h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps16.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps17.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps18.png" alt="img"> </p>
<h2 id="3-1-领域模型"><a href="#3-1-领域模型" class="headerlink" title="3.1: 领域模型:                                       "></a>3.1: 领域模型:                                      <a href="af://n130"> </a></h2><p>领域模型捕捉业务环境最重要的对象(产生类图).</p>
<p>领域模型代表存在的“实物” 或业务环境中出现的事件.</p>
<p>专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps19.png" alt="img"> </p>
<h2 id="3-2-用例模型"><a href="#3-2-用例模型" class="headerlink" title="3.2: 用例模型:                                       "></a>3.2: 用例模型:                                      <a href="af://n135"> </a></h2><p>一个用例图涉及到一个参与者与一个用例.表达的是功能化的需求.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps20.jpg" alt="img"> </p>
<h3 id="3-2-1-参与者："><a href="#3-2-1-参与者：" class="headerlink" title="3.2.1: 参与者："></a>3.2.1: 参与者：</h3><p>在系统之外，透过系统边界与系统进行有意义交互的任何事物.参与者透过系统边界直接与系统交互，参 与者的确定代表系统边界的确定.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps21.png" alt="img"> </p>
<p>参与者可以通过泛化关系来定义，在这种泛化关系中，一个参与者的抽象描述可以被一个或多个具体的 参与者所共享.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps22.png" alt="img"> </p>
<p>识别参与者:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps23.jpg" alt="img"> </p>
<h3 id="3-2-2-用例"><a href="#3-2-2-用例" class="headerlink" title="3.2.2: 用例:"></a>3.2.2: 用例:</h3><p>例描述的是参与者与系统的交互，而不是系统内在的活动。因此用例的定义也应该只关注系统对外所体 现的行为，即用例止于系统边界.将系统视为黑匣子描述的不是内在的系统活动.</p>
<p>每个用例都会对参与者产生一个有价值的结果。</p>
<p>购买商品的会员构造一个”购买商品”的用例是合理的.倘若构造”查询商品”,”购买”这两个用例就是不好的 用例.</p>
<h3 id="3-2-3-用例其他注意事项"><a href="#3-2-3-用例其他注意事项" class="headerlink" title="3.2.3: 用例其他注意事项:"></a>3.2.3: 用例其他注意事项:</h3><p>(1)系统执行，每个用例所产生的结果值都是由系统生成的。</p>
<p>(2)用例从参与者的观点出发,而不是从系统的观点出发.</p>
<p>(3)粒度问题:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps24.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps25.jpg" alt="img"> </p>
<p>处理方式:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps26.png" alt="img"> </p>
<h3 id="3-2-4-用例图"><a href="#3-2-4-用例图" class="headerlink" title="3.2.4: 用例图:"></a>3.2.4: 用例图:</h3><p>用例图：表达参与者与用例关系图形.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps27.png" alt="img"> </p>
<p>一个用例图实例:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps28.png" alt="img"> </p>
<h2 id="3-3-用例文档"><a href="#3-3-用例文档" class="headerlink" title="3.3: 用例文档:                                       "></a>3.3: 用例文档:                                      <a href="af://n161"> </a></h2><p>用例文档：描述用户与系统交互的需求说明书.</p>
<p>用例描述是需求的核心内容,而用例图作为用例文档的索引图.</p>
<p>用例文档要考虑到每个用例的各种场景.文档中每一句话都有其价值.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps29.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps30.jpg" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps31.jpg" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps32.png" alt="img"></p>
<h2 id="3-4-重构用例模型"><a href="#3-4-重构用例模型" class="headerlink" title="3.4: 重构用例模型:"></a>3.4: 重构用例模型:</h2><p>(1)用例关系:</p>
<p>通过用例关系将复杂的用例进行适当的分解，以便于提高需求的复用性和可扩展性等，从而使用例模型 的结构更合理.</p>
<p>(2)用例分级:</p>
<p>可以根据用例的重要程度进行分级，以便后续迭代计划的制定，高级别的用例优先考虑用例分包将相关 的.</p>
<p>(3)用例分包:</p>
<p>将相关的用例打包，通过分包的方式可以将用例图分层表示，以用于大规模系统的用例建模。</p>
<h3 id="3-4-1-用例关系："><a href="#3-4-1-用例关系：" class="headerlink" title="3.4.1: 用例关系："></a>3.4.1: 用例关系：</h3><p>(1)Include(包含):</p>
<p>基用例中复用被包含用例的行为提取公共步骤，便于复用.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps33.png" alt="img"> </p>
<p>(2)Extend(扩展):</p>
<p>通过扩展用例对基用例增加附加的行为.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps34.jpg" alt="img"> </p>
<p>(3)Generalization(泛化):</p>
<p>派生用例继承泛化用例的行为并添加新行为.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps35.png" alt="img"> </p>
<p>重构的用例模型例子：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps36.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps37.jpg" alt="img"></p>
<h3 id="3-4-2：注意事项："><a href="#3-4-2：注意事项：" class="headerlink" title="3.4.2：注意事项："></a>3.4.2：注意事项：</h3><p>用例不是功能分解.使用用例进行功能分解，是用例使用过程中最容易出现的问题.用例是目标，不是过 程；用例不代表功能模块.</p>
<p>用例说明了系统所能提供的功能、服务，而软件分析&#x2F;设计者可能会进行不同的设计.</p>
<h2 id="3-5-用例分析："><a href="#3-5-用例分析：" class="headerlink" title="3.5: 用例分析：                                  "></a>3.5: 用例分析：                                 <a href="af://n188"> </a></h2><p>得到用例模型之后，进行用例分析，根据分析进行设计，从而得到类图，并编写代码。</p>
<p>分析：为了满足需求模型中所描述的功能，系统内部应该有什么样的业务核心机制(需要几个对象互相协 作呢？ )</p>
<p>分析的目标是开发一系列模型，以描述软件核心成分，从而满足客户定义的需求：称为分析模型。</p>
<p>需求模型以用户的角度描述系统所要实现的目标，而分析模型表示在系统内部应该提供哪些核心业务元 素和关系，以实现需求模型提出的目标(例如，要有哪些对象(类)的配合才能完成需求中所提出的功   能)。</p>
<p>用例模型被“翻译”成分析模型(用例描述  顺序图，用例描述中的重要名词被翻译成类名及其属性)</p>
<h3 id="3-5-1-用例实现："><a href="#3-5-1-用例实现：" class="headerlink" title="3.5.1:用例实现："></a>3.5.1:用例实现：</h3><p>用例实现：  将用例行为分配给类</p>
<p>用例实现是分析&#x2F;设计模型中系统用例的表达式。</p>
<p>用例实现描述了对象间的协作以完成用例目标。</p>
<p>用例实现将用例模型中的用例和设计(分析)模型中的类和关系连接在一起，说明了每个用例必须用那些类 来实现。提供了从分析和设计到需求的可跟踪性。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps38.png" alt="img"> </p>
<p>用例实现和用例是两个不同的概念，它们关注的重点不同.</p>
<p>用例(描述)面向用户，描述功能。</p>
<p>用例实现则面向分析设计人员，描述软件的内部结构。</p>
<p>构造用例实现是分析最核心的工作。</p>
<p>获得实现用例行为所必须的分析类，利用这些分析类来描述其实现逻辑。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps39.png" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps40.jpg" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps41.jpg" alt="img"> </p>
<h3 id="3-5-2-顺序图"><a href="#3-5-2-顺序图" class="headerlink" title="3.5.2: 顺序图:"></a>3.5.2: 顺序图:</h3><p>顺序图是一种交互图，描述对象之间的动态交互关系，着重体现对象间消息传递的时间顺序.</p>
<p>对象(Object)：对象、对象的生命线、对象的执行发生和对象的删除.</p>
<p>消息(Message)：简单消息、同步消息、异步消息、返回消息.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps42.png" alt="img"></p>
<h3 id="3-5-3-专家模式"><a href="#3-5-3-专家模式" class="headerlink" title="3.5.3: 专家模式:"></a>3.5.3: 专家模式:</h3><p>是怎样将职责分配到分析类的指南.</p>
<p>将职责分配给具有当前职责所需要的数据的类如果一个类有这个数据，就将职责分配给这个类.<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps43.jpg" alt="img"> </p>
<h3 id="3-5-4-VOPC图"><a href="#3-5-4-VOPC图" class="headerlink" title="3.5.4: VOPC图:"></a>3.5.4: VOPC图:</h3><p>对于每一个“用例实现”，需要绘制与之相关的类图，即VOPC图.</p>
<p>参与类类图(VOPC, View Of Participating Classes Class Diagram).</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps44.png" alt="img"> </p>
<p>当所有的用例的VOPC图都画完了以后，就由此可以推导出分析类图.</p>
<h2 id="3-6-架构分析："><a href="#3-6-架构分析：" class="headerlink" title="3.6: 架构分析：                                  "></a>3.6: 架构分析：                                 <a href="af://n219"> </a></h2><p>架构分析的过程就是定义系统高层组织结构和核心架构机制的过程。</p>
<p>​	( 1)定义系统的备选架构来描述系统的高层组织结构—备选架构(选取层次结构，  Client-server, MVC 等).</p>
<p>​	( 2)提取系统的关键抽象以揭示系统必须能够处理的核心概念—关键抽象(领域模型图).</p>
<p>​	( 3)创建用例实现来启动用例分析—用例实现 .</p>
<p>架构模式(软件体系结构，架构)表示了对软件系统的一个基础结构组织形式。它提供了一套预定义子系 统，详细说明它们的职责，并且包括组织它们之间的规则和指南。</p>
<p>经典的架构有：</p>
<p>​	( 1)分层架构(层次架构)</p>
<p>​	( 2)  模型-视图-控制器(M-V-C)</p>
<p>​	( 3)  客户端-服务器架构 …</p>
<h2 id="3-7-分析类图"><a href="#3-7-分析类图" class="headerlink" title="3.7: 分析类图:                                       "></a>3.7: 分析类图:                                      <a href="af://n229"> </a></h2><p>最终目标是从系统的角度明确说明每一个分析类的职责和属性以及类之间的关系, 从而构造系统的分析类 视图。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps45.png" alt="img"> </p>
<p>分析阶段的重点在于找出体现系统核心业务所需数据的实体类，而界面和业务逻辑细节分别由边界类和 控制类隐藏.</p>
<p>在很多UML模型中，分析阶段的工作就是找到这些实体类.</p>
<p>这些实体类组成系统概念模型(分析类图).</p>
<p>通过比较各个用例的VOPC图，删除重复的与那些没有引用的实体类，即可得到由实体类组成的分析类 图，这些是分析的关键.</p>
<h3 id="3-7-1-类之间的关系："><a href="#3-7-1-类之间的关系：" class="headerlink" title="3.7.1: 类之间的关系："></a>3.7.1: 类之间的关系：</h3><p>​	( 1)关联：关联是类之间的一种结构化关系，是类之间的语义联系表明类的对象之间存在着链接对象是 类的实例，而链接是关联的实例。</p>
<p>​	( 2)自反关联：自反关联是指一个类自身之间存在关联，它表明同一个类的不同对象之间存在链接。</p>
<p>​	( 3)聚合：聚合(Aggregation)关系是一种特殊的关联关系。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps46.jpg" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps47.jpg" alt="img">除了拥有关联关系所有的基本特征之外,两个关联的类还分别代表“整体”和“部分” .         (4)泛化：泛化是指类间的结构关系、亲子关系子类继承父类所具有的属性、操作和关联。</p>
<p>分析类图实例：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps48.png" alt="img"> </p>
<h1 id="4-面向对象的设计原则"><a href="#4-面向对象的设计原则" class="headerlink" title="4.面向对象的设计原则:"></a>4.面向对象的设计原则:</h1><p>面向对象的设计原则是面向对象设计的基本指导思想.</p>
<p>是评价面向对象设计的价值观体系.</p>
<p>是设计模式的出发点和归宿.</p>
<p>是构造高质量软件的出发点.</p>
<h2 id="4-1-好的设计"><a href="#4-1-好的设计" class="headerlink" title="4.1: 好的设计:"></a>4.1: 好的设计:</h2><p>好的设计:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps49.jpg" alt="img"> </p>
<h2 id="4-2-LSP-替换原则"><a href="#4-2-LSP-替换原则" class="headerlink" title="4.2: LSP-替换原则:                                   "></a>4.2: LSP-替换原则:                                  <a href="af://n254"> </a></h2><p>LSP(The Liskov Substitution Principle, Liskov替换原则).</p>
<p>“若对于类型S的任一对象o1，均有类型T的对象o2存在，使得在T定义的所有程序P中，用o1替换o2之 后，程序的行为不变，则S是T的子类型” .</p>
<p>如果在任何情况下，子类(或子类型)或实现类与超类对象都是可以互换的，那么继承的使用就是合适 的。为了达到这一目标，子类不能添加任何父类没有的附加约束.</p>
<p>“子类对象必须可以替换超类对象” .</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps50.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps51.jpg" alt="img">当设计违背LSP原则时,可参考一下思路:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps52.png" alt="img"> </p>
<h2 id="4-3-OCP-开闭原则"><a href="#4-3-OCP-开闭原则" class="headerlink" title="4.3: OCP-开闭原则:                                   "></a>4.3: OCP-开闭原则:                                  <a href="af://n261"> </a></h2><p>开闭原则:  ( OCP-The Open-Close Principle)</p>
<p>开闭原则说明软件实体应该对扩展开放，对修改关闭；即在不修改已经存在的源代码的情况下，修改其 行为.</p>
<p>这在软件生产环境中尤其有价值，因为在生产环境下可能需要更改源代码。然后，极有可能对源代码进 行代码评审；单元测试，集成测试等符合开闭原则的代码可以做到在不修改源代码的情况下扩展功能， 因此从经济方面非常节省。</p>
<p>实现开闭原则的两种策略:</p>
<h3 id="4-3-1-复用代码"><a href="#4-3-1-复用代码" class="headerlink" title="4.3.1: 复用代码:"></a>4.3.1: 复用代码:</h3><p>只有在更正代码错误的情况下才能修改一个类；新增或改变功能需要创建不同的类。</p>
<p>新类通过继承的方式复用原来的类的代码 子类可能与超类可能有不同的接口.</p>
<p>主要思想是：复用实现(代码)，而不复用接口现有实现代码不允许修改，新实现不需要实现现有接 口。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps53.png" alt="img"> </p>
<h3 id="4-3-2-复用接口"><a href="#4-3-2-复用接口" class="headerlink" title="4.3.2: 复用接口:"></a>4.3.2: 复用接口:</h3><p>重用抽象接口，而不是重用实现(代码)  .<img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps54.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps55.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps56.png" alt="img"> </p>
<h2 id="4-4-SRP-单一职责原则"><a href="#4-4-SRP-单一职责原则" class="headerlink" title="4.4: SRP-单一职责原则:                               "></a>4.4: SRP-单一职责原则:                              <a href="af://n276"> </a></h2><p>SRP(The Single Responsibility Principle).</p>
<p>就一个类而言，应该仅有一个引起它变化的原因.</p>
<p>有关类的职责分配问题，是面向对象设计中最重要的基本原则.</p>
<p>SRP体现了内聚性(Cohesion)  .</p>
<p>内聚性：一个模块的组成元素之间的功能相关性类的职责定义为“变化的原因”，每个职责都是变化的一 个轴线；当需求变化时，该变化会反映为类的职责的变化如果一个类承担了多于一个的职责，那么引起 它变化的原因就会有多个.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps57.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps58.png" alt="img"> </p>
<h2 id="4-5-ISP-接口隔离原则"><a href="#4-5-ISP-接口隔离原则" class="headerlink" title="4.5: ISP-接口隔离原则:                                "></a>4.5: ISP-接口隔离原则:                               <a href="af://n284"> </a></h2><p>ISP(The Interface Segregation Principle).</p>
<p>将很大的接口拆分成较小的，更具体的接口；使得客户类只需要知道它所感兴趣的方法。  ISP原则的意图 是使得一个系统保持较低的耦合，以便于更容易重构，修改与部署。</p>
<p>使用多个专门的接口比使用单一的接口好一个类对另一个类的依赖性应当是建立在最小的接口上的避免 接口污染(Interface Pollution).</p>
<h2 id="4-6-DIP-依赖倒转原则"><a href="#4-6-DIP-依赖倒转原则" class="headerlink" title="4.6: DIP-依赖倒转原则:                               "></a>4.6: DIP-依赖倒转原则:                              <a href="af://n288"> </a></h2><p>(DIP-The Dependency Inversion Principle).</p>
<p>高层模块不依赖于低层模块，二者都依赖于抽象.抽象不依赖于细节，细节依赖于抽象.</p>
<p>针对接口编程，不要针对实现编程.</p>
<p>又称控制反转(IoC ，  Inversion of Control)、依赖注入.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps59.png" alt="img"> </p>
<p>结构化设计，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块 的复用性降低而且大大提高了开发的成本。面向对象设计中的依赖倒转：一般情况下抽象的变化概率很 小，让客户类依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程 序也不需要变化。这大大降低了客户程序与实现细节的耦合度。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps60.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps61.jpg" alt="img"> </p>
<p>ps: 这个带菱形的箭头表示为类之间的聚合关系.</p>
<h1 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5.设计模式:                              "></a>5.设计模式:                             <a href="af://n300"> </a></h1><p>设计模式是在构件设计阶段，通过定义类或特定对象之间的结构和行为，从而解决每类设计问题的通用 解决方案.</p>
<p>设计就是解决方案—对某个问题的解决.如果某个解决方案对某类问题都很有用.这时就把它总结出来.这就产生了设计模式.</p>
<p>设计模式是：优秀的设计范例,从优秀设计方案中发现和总结出来的经验,在实践中反复出现的设计问题的优秀解决方案,设计者相互交流的基本术语,设计语言培养优秀设计师的一条捷径.</p>
<h2 id="5-1-设计模式与设计原则"><a href="#5-1-设计模式与设计原则" class="headerlink" title="5.1: 设计模式与设计原则:                              "></a>5.1: 设计模式与设计原则:                             <a href="af://n304"> </a></h2><p>设计原则是面向对象设计的指导思想,设计模式只是更好地遵循这一指导思想的手段之一.  设计模式是面向对象设计的具体技术,设计模式抽象出成功设计的共性，并进行分类与标识. 设计模式通过描述对象、协作和职责将设计中的意图抽取出来.</p>
<h2 id="5-2-GRASP"><a href="#5-2-GRASP" class="headerlink" title="5.2: GRASP:"></a>5.2: GRASP:</h2><p>GRASP ( General Responsibility Assignment Software Pattern，通用职责分配软件模式)  . GRASP模式描述了将职责分配给对象的基本原则，这些原则被表示成模式.</p>
<p>职责和职责分配是面向对象分析和设计的最核心工作，合理的职责分配直接决定了设计的质量.</p>
<p>GRASP就是用于指导职责分配的原则和模式.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps64.png" alt="img"> </p>
<h2 id="5-3-信息专家模式"><a href="#5-3-信息专家模式" class="headerlink" title="5.3: 信息专家模式:                                   "></a>5.3: 信息专家模式:                                  <a href="af://n314"> </a></h2><p>信息专家模式：将责任分配给信息专家类(拥有实现该责任的信息的类)  .</p>
<p>将职责分配拥有履行一个职责所必需信息的类，即信息专家信息专家模式在职责分配中的应用比任何其 他模式都广泛，它是面向对象的设计中的一个基本指导.</p>
<p>原则信息专家不是一个模糊或者新奇的设计概念，它表述了最普遍的一种“直觉”，即对象所能完成的工 作要依赖于它所掌握的信息.</p>
<p>优点：</p>
<p>(1)封装能够得以维持，因为对象只使用他们自己包含的信息来完成任务(低耦合)  .</p>
<p>(2)系统行为只分布在具有所需信息的类中(高内聚)  .</p>
<h2 id="5-4-创建者模式"><a href="#5-4-创建者模式" class="headerlink" title="5.4: 创建者模式:                                     "></a>5.4: 创建者模式:                                    <a href="af://n321"> </a></h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps65.png" alt="img"> </p>
<p>使用创建者模式的好处支持低耦合，从而意味着低维护依赖，高复用机会.</p>
<h2 id="5-5-低耦合模式"><a href="#5-5-低耦合模式" class="headerlink" title="5.5: 低耦合模式:                                     "></a>5.5: 低耦合模式:                                    <a href="af://n324"> </a></h2><p>低耦合模式：通过分配责任使得得到低耦合的设计.</p>
<p>高耦合的设计:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps66.png" alt="img"> </p>
<p>低耦合的改进方法:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps67.png" alt="img"> </p>
<h2 id="5-6-高内聚模式"><a href="#5-6-高内聚模式" class="headerlink" title="5.6: 高内聚模式:                                     "></a>5.6: 高内聚模式:                                    <a href="af://n330"> </a></h2><h2 id="5-7-控制器模式"><a href="#5-7-控制器模式" class="headerlink" title="5.7: 控制器模式:                                     "></a>5.7: 控制器模式:                                    <a href="af://n331"> </a></h2><p>控制器模式：将接受(处理)系统事件消息的责任分配给一个代表整体系统(子系统、设备)的类，叫 做门面控制器或者代表一个用例场景的类，称为用例控制器的类。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps68.png" alt="img"> </p>
<p>控制器是一个非用户图形界面对象。控制器负责接收或处理系统消息。控制器决定调用哪些系统操作。 优点：</p>
<p>Controller类对象代表了应用层的控制器，它提供了用户图形界面所需要的方法。这样， ChartDrawerGUI类就可以不和Chart层次类产生关联，而只要调用Controller类即可。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps69.jpg" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps70.png" alt="img">用户图形界面ChartDrawerGUI是可插拔的，可以轻松地替换的.</p>
<p>增加用户图形界面的复用，产生可插拔的用户图形界面可能性.  保证应用逻辑不包含在GUI层.  将系统操 作代理给一个Controller类的好处是支持应用逻辑在将来的应用程序中的复用.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps71.png" alt="img">5.8: 多态模式:</p>
<p>如果一个程序使用了条件语句，则当有新的条件被加入的话，则需要修改原来的条件语句组的逻辑缺 点：程序不容易扩展。原因是如果程序有了新变化的时候，则可能会涉及到多处的修改。</p>
<p>解决方案：使用多态模式。当相关的行为基于类型而变化，使用多态操作，将行为责任分配给相关的类 型</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps72.png" alt="img"> </p>
<p>。</p>
<p>简单地说,就是把复杂的方法”退化”到类,避免了因为需求的变化大幅度的修改和重新编译原有类的操作.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps73.png" alt="img"></p>
<h2 id="5-9-纯虚构模式"><a href="#5-9-纯虚构模式" class="headerlink" title="5.9: 纯虚构模式:                                     "></a>5.9: 纯虚构模式:                                    <a href="af://n344"> </a></h2><p>将一组高内聚的责任分配给一个不代表领域类概念的虚构的类。该虚构的类的存在支持高内聚，低耦合 与复用.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps74.png" alt="img"> </p>
<p>这种设计不好：数据库操作方法与这3个类没有概念上的关系，如果数据库操作包含在3个类中，那么您 将得到一个低内聚的设计(导致低内聚的设计);这样做将生成一个与数据库接口(例如JDBC)紧密耦合的 类图.</p>
<p>一方面，按照信息专家模式，三个领域类类都应该拥有数据库访问的职责，而另一方面，如果这样做， 会导致低内聚，高耦合与可重用性差的设计。</p>
<p>使用纯虚构模式进行设计:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps75.png" alt="img"> </p>
<h2 id="5-10-间接模式"><a href="#5-10-间接模式" class="headerlink" title="5.10: 间接模式:                                      "></a>5.10: 间接模式:                                     <a href="af://n351"> </a></h2><p>将责任分配给中介对象，以便在其它组件之间进行协调，以使它们不直接耦合。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps76.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps77.png" alt="img"> </p>
<h2 id="5-11-受保护模式"><a href="#5-11-受保护模式" class="headerlink" title="5.11: 受保护模式:                                    "></a>5.11: 受保护模式:                                   <a href="af://n355"> </a></h2><p>如何设计对象、子系统和系统，以使这些元素中的变化或不稳定对其他元素不会产生不良影响？ 确定能预测到的(类型)变化或不稳定点；分配责任以建立一个稳定的接口.</p>
<p>PV是大多数编程和设计的机制和模式的基本动机之一，它使得系统能适应和隔离变化.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps78.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps79.png" alt="img"> </p>
<p>改善之后的设计容易维护,容易扩展,而且符合开闭原则.</p>
<h2 id="5-12-Demeter定律"><a href="#5-12-Demeter定律" class="headerlink" title="5.12: Demeter定律:                                 "></a>5.12: Demeter定律:                                <a href="af://n362"> </a></h2><p>类的方法不应该依赖于其它的类的结构，而只能依赖于自己所在的类或者其最靠近的超类。 不符合此定律的设计:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps80.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps81.png" alt="img"> </p>
<p>符合此定律的设计:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps82.jpg" alt="img"> </p>
<p>应用Demeter定律的基本效果是可以创建松散耦合的类，其实现秘密被封装了；因此，为了理解一个类 的意图，不必理解许多其它类的细节。</p>
<h1 id="6-分析与设计"><a href="#6-分析与设计" class="headerlink" title="6.分析与设计:                             "></a>6.分析与设计:                            <a href="af://n370"> </a></h1><h2 id="6-1-设计策略"><a href="#6-1-设计策略" class="headerlink" title="6.1: 设计策略:                                       "></a>6.1: 设计策略:                                      <a href="af://n371"> </a></h2><p>D-设计(分解设计，  Decomposition design)将系统映射为构件片(component pieces)，再对各个 构件片进行内部设计；是应用广泛的设计策略。</p>
<p>FP-设计(Family Patterndesign)是一种探求一定范围的通用性设计策略，不从需求入手，而去探求问 题的本质特征。主要用于通用产品设计，例如通用财务软件的设计。</p>
<p>I-设计(Invention design)基于概念化原型作系统分析，定义系统以满足所发现的需要和需求.</p>
<h2 id="6-2-从分析到设计："><a href="#6-2-从分析到设计：" class="headerlink" title="6.2: 从分析到设计：                               "></a>6.2: 从分析到设计：                              <a href="af://n374"> </a></h2><p>面向对象分析是面向对象设计的输入，设计是分析的细化方法。</p>
<p>相同点：都产生类图，分析类图，设计类图)。。</p>
<p>分析：做什么(What)分析有效地确定了将要构建的内容分析重点关注业务(business)问题。</p>
<p>设计：怎么做(How)设计定义如何构建目标系统：采用何种技术、何种平台(如JavaEE，前后端分离开发) 来实现分析模型设计关注于系统的技术(technical)和实现(implementation)细节。</p>
<p>分析集中在系统需求，而设计集中在待生产的软件的结构.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps83.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps84.png" alt="img"> </p>
<p>OO设计是对OO分析的进一步细化，其根本思想是：对分析模型中的分析类进行进一步的设计，添加实 现细节，这些分析类最终转变成设计元素面向对象的方法中，设计是分析的自然延续，在分析模型中添 加特定的实现机制，得到可以实现的设计元素.</p>
<h1 id="7-架构设计基础"><a href="#7-架构设计基础" class="headerlink" title="7.架构设计基础:                           "></a>7.架构设计基础:                          <a href="af://n383"> </a></h1><h2 id="7-1-架构与架构设计"><a href="#7-1-架构与架构设计" class="headerlink" title="7.1: 架构与架构设计:                                 "></a>7.1: 架构与架构设计:                                <a href="af://n384"> </a></h2><p>架构是一个系统的组织结构，包括系统分解成的各个部分、它们的连接性、交互机制和指导系统设计的 相关规则.</p>
<p>架构设计的活动在分析阶段就已经开始，分析阶段主要关注基础架构的选型和并确定核心的分析机制.</p>
<p>设计阶段，要针对分析阶段的备选架构的各个方面进行详细的定义，以设计出符合特定系统的架构.</p>
<h2 id="7-2-架构设计内容"><a href="#7-2-架构设计内容" class="headerlink" title="7.2: 架构设计内容:                                   "></a>7.2: 架构设计内容:                                  <a href="af://n388"> </a></h2><p>(1)确定核心元素：在架构的中高层，以“分析类”为出发点，确定相应的“核心设计元素”  (设计类，接口， 子系统等)  </p>
<p>(2)优化组织结构：按照高内聚、低耦合的基本原则，整理并逐渐充实架构的层次和内容(在架构的哪些 层，具体地包含哪些包，在哪些包中，包含哪些类)  .</p>
<p>(3)定义设计后的组织结构：架构设计还应该考虑设计完成后系统实现、运行以及部署等阶段的组织结构 (JavaEE, 前后端分离开发，服务器，数据存储，软件部署)  .</p>
<h2 id="7-3-包图"><a href="#7-3-包图" class="headerlink" title="7.3: 包图:                                           "></a>7.3: 包图:                                          <a href="af://n392"> </a></h2><p>包图是一种将模型元素分组的机制.</p>
<p>包主要用于组织模型元素配置管理单元.</p>
<p>分包的原则：职责相似，将一组职责相似、但以不同方式实现的类归为一组有意义的包；如java类库中 的javax.swing.border.</p>
<p>协作关系：包图包含了各种不同类型的类，它们之间通过相互协作实现一个意义重大的职责.</p>
<p>可以使用包记号表示大的系统架构与局部的结构表示架构，可以依据架构层依据用户功能.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps85.png" alt="img"> </p>
<h3 id="7-3-1-包的关系"><a href="#7-3-1-包的关系" class="headerlink" title="7.3.1: 包的关系:"></a>7.3.1: 包的关系:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps86.jpg" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps87.jpg" alt="img"> </p>
<h3 id="7-3-2-包的设计原则"><a href="#7-3-2-包的设计原则" class="headerlink" title="7.3.2: 包的设计原则:"></a>7.3.2: 包的设计原则:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps88.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps89.jpg" alt="img"> </p>
<h2 id="7-4-设计元素"><a href="#7-4-设计元素" class="headerlink" title="7.4: 设计元素:                                       "></a>7.4: 设计元素:                                      <a href="af://n407"> </a></h2><p>设计元素(Design Elements)是指能够直接用于实现(编码)的模型要素.</p>
<p>主要包括:</p>
<p>包(Package).</p>
<p>设计类(Design Classes).</p>
<p>子系统(Subsystem).</p>
<p>接口(Interface).</p>
<p>主动类(Active Class).</p>
<p>确定设计元素的目的是改进(调整)分析类，使之成为适当的设计模型元素.</p>
<h3 id="7-4-1-分析类到设计元素"><a href="#7-4-1-分析类到设计元素" class="headerlink" title="7.4.1: 分析类到设计元素:"></a>7.4.1: 分析类到设计元素:</h3><p>(1)简单的分析类被直接映射到设计类，如果：若一个分析类是一个简单类(表示一个简单逻辑抽象)则 将此分析类增加详细内容(属性，方法的参数，返回值)，从而成为设计类.</p>
<p>(2)更复杂的分析类可能被分成:</p>
<p>多个设计类.</p>
<p>设计为一个包.</p>
<p>设计为一个接口和子系统.</p>
<h3 id="7-4-2-接口"><a href="#7-4-2-接口" class="headerlink" title="7.4.2: 接口:"></a>7.4.2: 接口:</h3><p>接口(Interface)是类、子系统或构件提供的操作的集合接口允许用户以公开的方式定义多态，并且和实 现没有直接联系接口支持“即插即用”的结构.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps90.jpg" alt="img"><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps91.jpg" alt="img"> </p>
<h3 id="7-4-3-子系统与接口"><a href="#7-4-3-子系统与接口" class="headerlink" title="7.4.3: 子系统与接口:"></a>7.4.3: 子系统与接口:</h3><p>子系统(Subsystem)是一种介于包和类之间的一种设计机制，它实现一个或多个接口所定义的行为. 具有包的语义：能够包含其它模型元素.</p>
<p>具有类的语义：具有行为.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps92.png" alt="img"> </p>
<p>子系统可以将系统划分成独立的部分，将被实现为独立的构件，这些构件在保持结构不变的情况下，可 以独立地开发和部署，适应变更，而不影响到其它系统.</p>
<p>子系统也可用于将系统划分成若干单元表示设计中的既存产品或外部系统.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps93.jpg" alt="img"> </p>
<h2 id="7-5-永久数据存储"><a href="#7-5-永久数据存储" class="headerlink" title="7.5: 永久数据存储:                                   "></a>7.5: 永久数据存储:                                  <a href="af://n483"> </a></h2><h1 id="8-类的设计理论"><a href="#8-类的设计理论" class="headerlink" title="8.类的设计理论:                           "></a>8.类的设计理论:                          <a href="af://n438"> </a></h1><p>类设计(Class Design)目标确保类可为用例实现提供必需的操作确保提供足够的信息可明确无误地实现处 理和类相关的非功能需求(例如，可扩展性).</p>
<p>输入:用例实现(设计).</p>
<p>输出:设计类.</p>
<h2 id="8-1-主要内容"><a href="#8-1-主要内容" class="headerlink" title="8.1: 主要内容:"></a>8.1: 主要内容:</h2><ol>
<li><p>创建初始设计类.</p>
</li>
<li><p>定义操作.</p>
</li>
<li><p>定义属性.</p>
</li>
<li><p>定义关系.</p>
</li>
</ol>
<h2 id="8-2-初始设计类"><a href="#8-2-初始设计类" class="headerlink" title="8.2: 初始设计类:                                     "></a>8.2: 初始设计类:                                    <a href="af://n452"> </a></h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps94.png" alt="img"> </p>
<h3 id="8-2-1-边界类"><a href="#8-2-1-边界类" class="headerlink" title="8.2.1: 边界类:"></a>8.2.1: 边界类:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps95.png" alt="img"> </p>
<h3 id="8-2-2-实体类"><a href="#8-2-2-实体类" class="headerlink" title="8.2.2: 实体类:"></a>8.2.2: 实体类:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps96.png" alt="img"> </p>
<h3 id="8-2-3-控制类"><a href="#8-2-3-控制类" class="headerlink" title="8.2.3: 控制类:"></a>8.2.3: 控制类:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps97.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps98.png" alt="img"> </p>
<h2 id="8-4-定义属性"><a href="#8-4-定义属性" class="headerlink" title="8.4: 定义属性:                                       "></a>8.4: 定义属性:                                      <a href="af://n462"> </a></h2><h2 id="8-5-定义关系"><a href="#8-5-定义关系" class="headerlink" title="8.5: 定义关系:                                       "></a>8.5: 定义关系:                                      <a href="af://n463"> </a></h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps99.png" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps100.jpg" alt="img"> </p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/wps101.jpg" alt="img"> </p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>课程</tag>
      </tags>
  </entry>
</search>
