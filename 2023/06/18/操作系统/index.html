<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>操作系统 | 风凌渡</title>
<noscript>开启Javascript是必要的</noscript>
<link rel="icon" type="image/x-icon" href="/img/avatar.webp">
<link rel="apple-touch-icon" href="/img/avatar.webp">
<meta name="apple-mobile-web-app-title" content="风凌渡">
<link rel="bookmark" href="/img/avatar.webp">
<link rel="apple-touch-icon-precomposed" sizes="180x180" href="/img/avatar.webp">
<meta name="description" content="a blog 一个分享技术与生活的博客">
<meta name="theme-color" content="#1C1C1F">
<link rel="stylesheet" href="/css/var.css">
<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/css/custom.css">



<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    

<link rel="stylesheet" href="/lib/snackbar.min.css">


<script src="/lib/qrcode.min.js"></script>





<script>var GLOBALCONFIG = {"root":"/","runtime":"2022-5-21 00:00:00","lazyload":{"enable":false,"error":"/img/acrylic.png"},"hightlight":{"enable":false,"limit":200},"lightbox":true,"randomlinks":false,"lang":{"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"recent":"最近","yesterday":"昨天","berforeyesterday":"前天","daybefore":"天前","runtime":"天"},"sayhello":{"morning":"早上好","noon":"中午好","afternoon":"下午好","night":"晚上好","goodnight":"晚安","iam":"!  我是"},"search":{"empty":"搜索结果为空","hit":"已为您找到 ${query} 条结果","placeholder":"输入关键词快速查找"}},"covercolor":false,"localsearch":{"preload":false,"path":"/search.xml"}};</script><script id="site-config">var PAGECONFIG = {"is_home":false,"is_post":true,"is_page":false,"page":false,"toc":true,"comment":false};</script>
    <meta name="generator" content="Hexo 6.3.0"></head>
    <body id="body">
        
        <div id="console" style="zoom: 1;" class="">
    <div class="close-btn" onclick="acrylic.hideConsole()" href="javascript:void(0);">
        <i class="fas fa-circle-xmark"></i>
    </div>
    <div class="button-group">
        <div class="console-btn-item"> <a class="darkmode_switchbutton" onclick="acrylic.switchDarkMode()" title="显示模式切换"
                href="javascript:void(0);" rel="external nofollow" data-pjax-state=""><i class="fas fa-moon"
                    style="font-size: 1rem;"></i></a></div>
                    
            <div class="console-btn-item" id="consoleMusic" onclick="acrylic.musicToggle()" title="音乐开关"><a class="music-switch"><i class="fas fa-music"></i></a></div>
        
        <div class="console-btn-item" id="consoleFPS" onclick="acrylic.FPSToggle()" title="帧率显示开关"><a class="FPS-switch"
                data-pjax-state=""><i class="fas fa-gauge"></i></a></div>
    </div>
    <div class="console-mask" onclick="acrylic.hideConsole()" href="javascript:void(0);" rel="external nofollow"></div>
</div>
        <div id="sidebar" style="zoom: 1;">
    <div id="menu-mask" style="display: none;"></div>
    <div id="sidebar-menus" class>
        <span class="sidebar-menu-item-title">功能</span>
        <div class="sidebar-menu-item">
            <a class="darkmode_switchbutton menu-child" onclick="acrylic.switchDarkMode()" title="显示模式切换"
                href="javascript:void(0);" rel="external nofollow">
                <i class="fas fa-moon" style="font-size: 1rem;"></i>
                <span>显示模式</span>
            </a>
        </div>
        
            <div class="back-menu-list-groups">
    
      
      <div class="back-menu-list-group">
        <div class="back-menu-list-title">
          我的
        </div>
        <div class="back-menu-list">
          
            
            <a class="back-menu-item" href="/" rel="external nofollow" title="博客">
              <img class="back-menu-item-icon" src="/img/avatar.webp" loading="lazy">
              <span class="back-menu-item-text">
                博客
              </span>
            </a>
          
        </div>
      </div>
    
  </div>
  
        
        <div class="menus_items">
    
        <div class="menus_item">
            
                <a class="site-page" href="javascript:void(0);" rel="external nofollow">
                    <span> 文库</span>
                </a>
                <ul class="menus_item_child">
                    
                        <li>
                            <a class="site-page child" href="/archives/">
                                <i class="fas fa-box-archive"></i>
                                <span> 文章列表</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/categories/">
                                <i class="fas fa-cube"></i>
                                <span> 全部分类</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/tags/">
                                <i class="fas fa-tags"></i>
                                <span> 全部标签</span>
                            </a>
                        </li>
                    
                </ul>
             
        </div>
    
        <div class="menus_item">
            
                <a class="site-page not-child" target="_blank" href="https://github.com/bearslyricattack" rel="external nofollow noopener">
                    <span> 仓库</span>
                </a>
             
        </div>
    
</div>
        <span class="sidebar-menu-item-title">标签</span>
        <div class="card-widget card-tags card-archives card-webinfo card-allinfo">
            <div class="item-headline">
                <i class="fas fa-tags"></i>
                <span>标签</span>
            </div>
            <div class="card-tag-cloud">
                
                    <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 1em; color: #d3d3d3">中间件
                        <sup>4</sup>
                    </a>
                
                    <a href="/tags/Go/" style="font-size: 1em; color: #d3d3d3">Go
                        <sup>3</sup>
                    </a>
                
                    <a href="/tags/Java/" style="font-size: 1em; color: #d3d3d3">Java
                        <sup>3</sup>
                    </a>
                
                    <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1em; color: #d3d3d3">架构
                        <sup>3</sup>
                    </a>
                
                    <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1em; color: #d3d3d3">项目
                        <sup>2</sup>
                    </a>
                
                    <a href="/tags/%E5%BD%B1%E8%AF%84/" style="font-size: 1em; color: #d3d3d3">影评
                        <sup>1</sup>
                    </a>
                
                    <a href="/tags/%E8%AF%97%E6%AD%8C/" style="font-size: 1em; color: #d3d3d3">诗歌
                        <sup>14</sup>
                    </a>
                
                    <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1em; color: #d3d3d3">分布式
                        <sup>1</sup>
                    </a>
                
                    <a href="/tags/%E5%A5%8E%E6%A1%91%E6%8F%90/" style="font-size: 1em; color: #d3d3d3">奎桑提
                        <sup>1</sup>
                    </a>
                
                    <a href="/tags/%E5%A5%A5%E6%81%A9/" style="font-size: 1em; color: #d3d3d3">奥恩
                        <sup>1</sup>
                    </a>
                
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1em; color: #d3d3d3">数据库
                        <sup>2</sup>
                    </a>
                
                    <a href="/tags/%E8%AF%BE%E7%A8%8B/" style="font-size: 1em; color: #d3d3d3">课程
                        <sup>8</sup>
                    </a>
                
                    <a href="/tags/%E8%AF%84%E8%AE%BA/" style="font-size: 1em; color: #d3d3d3">评论
                        <sup>1</sup>
                    </a>
                
                    <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1em; color: #d3d3d3">服务器
                        <sup>1</sup>
                    </a>
                
                    <a href="/tags/%E6%A1%8C%E6%90%AD/" style="font-size: 1em; color: #d3d3d3">桌搭
                        <sup>1</sup>
                    </a>
                
            </div>
        </div>
    </div>
</div>    
        
            <div class="post" id="body-wrap">
                <header class="post-bg" id="page-header">
    <nav id="nav" class="show">
    <div id="nav-group">
        <div id="blog_name">
            
                <div class="back-home-button" tabindex="-1">
                    <i class="back-home-button-icon fas fa-grip-vertical"></i>
                    <div class="back-menu-list-groups">
    
      
      <div class="back-menu-list-group">
        <div class="back-menu-list-title">
          我的
        </div>
        <div class="back-menu-list">
          
            
            <a class="back-menu-item" href="/" rel="external nofollow" title="博客">
              <img class="back-menu-item-icon" src="/img/avatar.webp" loading="lazy">
              <span class="back-menu-item-text">
                博客
              </span>
            </a>
          
        </div>
      </div>
    
  </div>
  
                </div>
            
            <a id="site-name" href="/" title="返回博客主页">
                    
            </a>
        </div>
        <div id="page-name-mask">
            <div id="page-name">
                <a id="page-name-text" onclick="acrylic.toTop()">操作系统</a>
            </div>
        </div>
        <div id="menus">
            <div class="menus_items">
    
        <div class="menus_item">
            
                <a class="site-page" href="javascript:void(0);" rel="external nofollow">
                    <span> 文库</span>
                </a>
                <ul class="menus_item_child">
                    
                        <li>
                            <a class="site-page child" href="/archives/">
                                <i class="fas fa-box-archive"></i>
                                <span> 文章列表</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/categories/">
                                <i class="fas fa-cube"></i>
                                <span> 全部分类</span>
                            </a>
                        </li>
                    
                        <li>
                            <a class="site-page child" href="/tags/">
                                <i class="fas fa-tags"></i>
                                <span> 全部标签</span>
                            </a>
                        </li>
                    
                </ul>
             
        </div>
    
        <div class="menus_item">
            
                <a class="site-page not-child" target="_blank" href="https://github.com/bearslyricattack" rel="external nofollow noopener">
                    <span> 仓库</span>
                </a>
             
        </div>
    
</div>
        </div>
        <!-- <div id="nav-left">
            <div id="fps-group">
                <div id="fps">145</div><span class="fpsText">FPS</span>
            </div>
        </div> -->
        <div id="nav-right">
            
    <div class="nav-button only-home" id="travellings_button">
        <a class="site-page"  target="_blank" rel="noopener external nofollow" href="https://www.travellings.cn/go.html" title="开往-友链接力"  width="120">
            <i class="fa-solid fa-train-subway" style="font-size: 1rem;"></i>
        </a>
    </div>


    <div class="nav-button" id="randomPost_button">
        <a class="site-page" onclick="toRandomPost()"
            title="随机前往一个文章">
            <i class="fas fa-shuffle" style="font-size: 1rem;"></i>
        </a>
    </div>


    <div class="nav-button" id="search-button">
        <a class="site-page social-icon search" title="站内搜索"
            href="javascript:void(0);" rel="external nofollow">
            <i class="fas fa-magnifying-glass" style="font-size: 1rem;"></i>
        </a>
    </div>


    <div class="nav-button" id="nav-console">
        <a class="console_switchbutton" onclick="acrylic.showConsole()"
        title="显示中控台" href="javascript:void(0);" rel="external nofollow">
        <i class="fas fa-bars-progress" style="font-size: 1rem;"></i>
        </a>
    </div>

<div class="nav-button" id="nav-totop" onclick="acrylic.toTop()">
    <a class="totopbtn">
        <i class="fas fa-arrow-up"></i>
        <span id="percent">0</span>
    </a>
</div>
<div id="toggle-menu">
    <a class="site-page">
        <i class="fas fa-bars fa-fw" style="font-size: 1rem;"></i>
    </a>
</div>
        </div>
    </div>
</nav>
    
        <div class="coverdiv" id="coverdiv">
    <img id="post-cover" class="nolazyload" src="/img/301.jpg" alt="cover">
</div>
<div id="post-info">
    <div id="post-firstinfo">
        <div class="meta-firstline">
            <a class="post-meta-original" title="该文章为原创文章，注意版权协议">
                原创
            </a>
            
            <span class="post-meta-categories">
                
                    <a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                
            </span>
            
            <div class="tag_share">
                <div class="post-meta__tag-list">
                    
                        <a class="post-meta__tags" href="/tags/%E8%AF%BE%E7%A8%8B/">
                            <span class="tags-punctuation">#</span>
                            <span class="tags-name">课程</span>
                        </a>
                    
                </div>
            </div>
        </div>
    </div>
    <h1 class="post-title">操作系统</h1>
    <div id="post-meta">
        <div class="meta-secondline">
            <span class="post-meta-date" title="发布于">
                <i class="post-meta-icon fa-fw fas fa-calendar"></i>
                <time datetime="2023-06-18T15:48:34+08:00"></time>
            </span>
            
            
                <span class="post-meta-position" title="作者IP归属地为山东·威海">
                    <i class="fas fa-location-dot post-meta-icon"></i>
                    <span>山东·威海</span>
                </span>
            
            
                
                
            
            
                
        </div>
    </div>
</div>
<section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg"
    xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
    <defs>
        <path id="gentle-wave"
            d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path>
    </defs>
    <g class="parallax">
        <use href="#gentle-wave" x="48" y="0"></use>
        <use href="#gentle-wave" x="48" y="3"></use>
        <use href="#gentle-wave" x="48" y="5"></use>
        <use href="#gentle-wave" x="48" y="7"></use>
    </g>
</svg>
</section>

        
</header>
                <main class="layout" id="content-inner">
    <div id="post">
        <article class="post-content" id="article-container">
            <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论:"></a>1.绪论:</h1><h2 id="1-1-操作系统定义"><a href="#1-1-操作系统定义" class="headerlink" title="1.1 操作系统定义:"></a>1.1 操作系统定义:</h2><p>操作系统是一直运行在计算机上的程序，通常狭义上被称为内核（Kernel）程序，其他程序则为系统程序和应用程序。</p>
<p>它是资源管理平台，运行程序的平台，也是为用户提供服务的平台.</p>
<h2 id="1-2-计算机系统"><a href="#1-2-计算机系统" class="headerlink" title="1.2 计算机系统:"></a>1.2 计算机系统:</h2><h3 id="1-2-1-体系结构图"><a href="#1-2-1-体系结构图" class="headerlink" title="1.2.1 体系结构图:"></a>1.2.1 体系结构图:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618155714422.png" alt="image-20230618155714422"></p>
<h3 id="1-2-2-初始化"><a href="#1-2-2-初始化" class="headerlink" title="1.2.2: 初始化:"></a>1.2.2: 初始化:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618160029930.png" alt="image-20230618160029930"></p>
<h3 id="1-2-3-中断"><a href="#1-2-3-中断" class="headerlink" title="1.2.3 中断:"></a>1.2.3 中断:</h3><p>一个事件的触发是通过硬件或软件中断来实现的</p>
<p>在实现操作系统功能时，中断是一个非常重要的实现机制</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618160113053.png" alt="image-20230618160113053"></p>
<p>系统一旦发生中断，CPU会运行中断服务程序(Interrupt Service Routine)，且每个中断都有自己对应的中断服务程序 ISR</p>
<p>系统通过中断向量表（Interrupt Vector Table）来管理中断请求与中断服务程序之间的对应关系.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618160204190.png" alt="image-20230618160204190"></p>
<p>现代的操作系统一般被视为以中断驱动 （InterruptDriven ）或事件驱动（ Event-Driven ）的系统</p>
<h3 id="1-2-4-I-x2F-O结构"><a href="#1-2-4-I-x2F-O结构" class="headerlink" title="1.2.4 I&#x2F;O结构:"></a>1.2.4 I&#x2F;O结构:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618160308833.png" alt="image-20230618160308833"></p>
<p><strong>CPU</strong>负责内存与本地缓冲器之间的数据传递.</p>
<p>设备控制器负责在其所控制的外部设备与本地缓冲存储之间进行数据传递.</p>
<p>I&#x2F;O 操作结束后，设备控制器通过中断通知 CPU 表示 I&#x2F;O结束.</p>
<p>如磁盘控制器每次传输数据时，通过中断通知CPU，表示I&#x2F;O结束.</p>
<h4 id="1-2-4-1-DMA"><a href="#1-2-4-1-DMA" class="headerlink" title="1.2.4.1 DMA:"></a>1.2.4.1 DMA:</h4><p>DMA直接访问内存是在专门的硬件控制下，实现高速外部设备与主存储器之间自动成批交换数据，尽量减少CPU干预的I&#x2F;O操作方式.</p>
<p>有利于高速 I&#x2F;O设备传送数据，接近于内存速度.</p>
<h4 id="1-2-4-2-I-x2F-O类型"><a href="#1-2-4-2-I-x2F-O类型" class="headerlink" title="1.2.4.2 I&#x2F;O类型:"></a>1.2.4.2 I&#x2F;O类型:</h4><p>同步:</p>
<p>只有 I&#x2F;O 结束后，用户程序才能获得控制权，即 I&#x2F;O 进行期间，用户程序无法继续运行。</p>
<p>异步:</p>
<p>I&#x2F;O 还没有结束的情况下，用户程序可以获得控制权，即 I&#x2F;O进行期间，用户程序可以继续运行。</p>
<h3 id="1-2-5-存储结构"><a href="#1-2-5-存储结构" class="headerlink" title="1.2.5 存储结构:"></a>1.2.5 存储结构:</h3><p>两级存储.</p>
<p>一级存储设备指内存（主存）CPU可以直接随机访问的唯一大容量存储设备，是易失存储设备。易失存储设备指的是断电后，数据会丢失的设备.</p>
<p>二级存储设备: 一般不易失的存储设备，一般是磁盘类.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618160716478.png" alt="image-20230618160716478"></p>
<h3 id="1-2-6-处理器系统"><a href="#1-2-6-处理器系统" class="headerlink" title="1.2.6 处理器系统:"></a>1.2.6 处理器系统:</h3><h4 id="1-2-6-1-单处理器"><a href="#1-2-6-1-单处理器" class="headerlink" title="1.2.6.1 单处理器:"></a>1.2.6.1 单处理器:</h4><p>系统中只有一个通用处理器（CPU），用来处理来自用户进程的指令.</p>
<p>除了通用处理器，系统一般还包括其他专用处理器，如磁盘控制器、图形控制器等.</p>
<h4 id="1-2-6-2-多处理器"><a href="#1-2-6-2-多处理器" class="headerlink" title="1.2.6.2 多处理器:"></a>1.2.6.2 多处理器:</h4><p>系统中有多个处理器，又称为并联系统(parallel systems、tightly-coupled systems)，多个处理器共享一个内存.</p>
<p>CPU之间通过共享内存来进行通讯.</p>
<p>操作系统可以运行在某一个CPU上或多个CPU上.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618160910835.png" alt="image-20230618160910835"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618160928960.png" alt="image-20230618160928960"></p>
<p>多处理器环境下，不管多处理器还是多核处理器、每个处理器都需要有自己的寄存器和高速缓存.</p>
<h2 id="1-3-类型"><a href="#1-3-类型" class="headerlink" title="1.3 类型:"></a>1.3 类型:</h2><h3 id="1-3-1-批处理系统"><a href="#1-3-1-批处理系统" class="headerlink" title="1.3.1 批处理系统:"></a>1.3.1 批处理系统:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618161105569.png" alt="image-20230618161105569"></p>
<p>而所谓批处理系统,就是在当发生 I&#x2F;O 操作时，由操作员手动的调度另一个程序运行，从而提高CPU的使用率.</p>
<h3 id="1-3-2-多道程序系统"><a href="#1-3-2-多道程序系统" class="headerlink" title="1.3.2 多道程序系统:"></a>1.3.2 多道程序系统:</h3><p>把操作员的工作内容写到操作系统里，由操作系统进行任务的调度.</p>
<p>当系统进行 I&#x2F;O 操作时，调度器就会选择另一个任务并运行.</p>
<h3 id="1-3-3-分时系统"><a href="#1-3-3-分时系统" class="headerlink" title="1.3.3 分时系统:"></a>1.3.3 分时系统:</h3><p>给每个任务赋予一个给定的时间片（time slot，time slice）CPU 在多任务之间相互切换，如20msec为单位切换另一个用户.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618161456968.png" alt="image-20230618161456968"></p>
<h2 id="1-4-操作："><a href="#1-4-操作：" class="headerlink" title="1.4 操作："></a>1.4 操作：</h2><h3 id="1-4-1-双重模式操作："><a href="#1-4-1-双重模式操作：" class="headerlink" title="1.4.1 双重模式操作："></a>1.4.1 双重模式操作：</h3><p>一个操作系统可以被多个用户、多个程序所共享。多个用户之间、多个程序之间可能相互影响。非法或不正确的操作会导致系统崩溃或破坏。如无限循环会导致其他程序无法运行，会导致系统失灵或崩溃。</p>
<p>所以操作系统需要有一个保护机制.</p>
<p>双重模式：用户模式和内核模式。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618161636016.png" alt="image-20230618161636016"></p>
<p>如系统调用（System Call），当用户程序调用系统调用函数的时候，操作系统的运行模式从用户模式转变成内核模式，如调用 printf() 函数.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618161744978.png" alt="image-20230618161744978"></p>
<p>两种模式之间通过类似api的方式进行连接，从而避免了操作系统损坏的问题。</p>
<h2 id="1-5-管理"><a href="#1-5-管理" class="headerlink" title="1.5 管理:"></a>1.5 管理:</h2><h3 id="1-5-1-进程管理："><a href="#1-5-1-进程管理：" class="headerlink" title="1.5.1 进程管理："></a>1.5.1 进程管理：</h3><p>进程是运行中的程序，是系统的运行单元。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618161900172.png" alt="image-20230618161900172"></p>
<h3 id="1-5-2-内存管理："><a href="#1-5-2-内存管理：" class="headerlink" title="1.5.2 内存管理："></a>1.5.2 内存管理：</h3><p>管理内存中的数据的存储、指令的运行。</p>
<p>内存管理的主要目的就是提高内存的使用率，从而有效使用内存。</p>
<h3 id="1-5-3-文件系统管理："><a href="#1-5-3-文件系统管理：" class="headerlink" title="1.5.3 文件系统管理："></a>1.5.3 文件系统管理：</h3><p>操作系统对存储设备的物理属性进行了抽象的定义，即文件， 它是存储的逻辑单元。文件通常组成目录以方便使用。</p>
<h4 id="1-5-3-1-I-x2F-O子系统："><a href="#1-5-3-1-I-x2F-O子系统：" class="headerlink" title="1.5.3.1 I&#x2F;O子系统："></a>1.5.3.1 I&#x2F;O子系统：</h4><p>I&#x2F;O子系统的目的是针对用户隐藏具体硬件设备的特性，它包括以下几个部分:</p>
<ol>
<li>一个包括缓冲(buffer)、高速缓存(cache)和假脱机(spooling)的内存管理部分</li>
<li>通用设备驱动器接口</li>
<li>特定硬件设备的驱动程序)</li>
</ol>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618162933258.png" alt="image-20230618162933258"></p>
<h2 id="1-6-其他操作系统"><a href="#1-6-其他操作系统" class="headerlink" title="1.6 其他操作系统:"></a>1.6 其他操作系统:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163120267.png" alt="image-20230618163120267"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163126933.png" alt="image-20230618163126933"></p>
<p>云计算:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163144501.png" alt="image-20230618163144501"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163157194.png" alt="image-20230618163157194"></p>
<h1 id="2-操作系统结构"><a href="#2-操作系统结构" class="headerlink" title="2.操作系统结构:"></a>2.操作系统结构:</h1><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163255967.png" alt="image-20230618163255967"></p>
<h2 id="2-1-系统服务"><a href="#2-1-系统服务" class="headerlink" title="2.1 系统服务:"></a>2.1 系统服务:</h2><p>操作系统以不同形式向程序和用户提供服务.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163343967.png" alt="image-20230618163343967"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163349713.png" alt="image-20230618163349713"></p>
<h2 id="2-2-用户界面"><a href="#2-2-用户界面" class="headerlink" title="2.2 用户界面:"></a>2.2 用户界面:</h2><h3 id="2-2-1-命令行界面"><a href="#2-2-1-命令行界面" class="headerlink" title="2.2.1 命令行界面:"></a>2.2.1 命令行界面:</h3><p>CLI（Command Line Interface）允许用户直接输入操作系统完成的命令</p>
<p>有的在内核中实现，有的通过系统程序实现.</p>
<h3 id="2-2-2-图形用户界面"><a href="#2-2-2-图形用户界面" class="headerlink" title="2.2.2 图形用户界面:"></a>2.2.2 图形用户界面:</h3><p>GUI.</p>
<p>用户界面友好的桌面接口</p>
<p>• 通常使用鼠标、键盘和监视器</p>
<p>• 图标代表文件、程序、系统功能等</p>
<p>许多系统同时包含CLI和GUI界面.</p>
<h2 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3 系统调用:"></a>2.3 系统调用:</h2><p>是操作系统服务的编程接口,面向程序.通常用高级语言编写. </p>
<p>程序通过应用程序接口(API)访问，而不是直接使用系统调用.</p>
<p>举个例子:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163758097.png" alt="image-20230618163758097"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163807053.png" alt="image-20230618163807053"></p>
<p>每个系统调用都有一个固有番号(System Call Number),操作系统通过一张系统调用番号表来管理系统调用接口.</p>
<p>作为开发者来说，不需要关心系统调用是怎么实现的，只需要掌握它的使用规则就可以.</p>
<p>一般系统调用被运行库(run-time support library)来管理，运行库提供API，开发者调用运行库提供的API即可.</p>
<h3 id="2-3-1-参数传递"><a href="#2-3-1-参数传递" class="headerlink" title="2.3.1 参数传递:"></a>2.3.1 参数传递:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618163932373.png" alt="image-20230618163932373"></p>
<h2 id="2-4-系统程序"><a href="#2-4-系统程序" class="headerlink" title="2.4 系统程序:"></a>2.4 系统程序:</h2><p>提供一个方便的环境，以开发程序和执行程序.为用户使用操作系统服务, 如文件管理器: 创建、删除、复制、重命名、打印、转储、列出和操作文件和目录.</p>
<p>可以说是在操作系统向应用层提供除了api之外的另一种服务.</p>
<p>系统程序不属于内核，但属于操作系统的一部分.</p>
<p>如查看文件目录,查看电脑的状态信息,修改文件,通信等功能.</p>
<h2 id="2-5-操作系统设计和实现"><a href="#2-5-操作系统设计和实现" class="headerlink" title="2.5 操作系统设计和实现:"></a>2.5 操作系统设计和实现:</h2><p>设计目标:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618164241126.png" alt="image-20230618164241126"></p>
<p>具体实现:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618164304992.png" alt="image-20230618164304992"></p>
<h2 id="2-6-结构类别"><a href="#2-6-结构类别" class="headerlink" title="2.6 结构类别:"></a>2.6 结构类别:</h2><h3 id="2-6-1-简单结构"><a href="#2-6-1-简单结构" class="headerlink" title="2.6.1 简单结构:"></a>2.6.1 简单结构:</h3><p>早期操作系统，规模小，简单，功能有限，以MS-DOS为例，以最小的空间提供最多的功能.</p>
<p>它没划分模块，尽管MS-DOS有某种结构，其接口和功能层没有划分清楚.</p>
<h3 id="2-6-2-层次结构"><a href="#2-6-2-层次结构" class="headerlink" title="2.6.2 层次结构:"></a>2.6.2 层次结构:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618164443531.png" alt="image-20230618164443531"></p>
<p>优点是简化了系统设计和实现，便于调试和升级维护,缺点是层定义，效率差.</p>
<h3 id="2-6-3-微内核结构"><a href="#2-6-3-微内核结构" class="headerlink" title="2.6.3 微内核结构:"></a>2.6.3 微内核结构:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618164545630.png" alt="image-20230618164545630"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618164615747.png" alt="image-20230618164615747"></p>
<h3 id="2-6-4-模块结构"><a href="#2-6-4-模块结构" class="headerlink" title="2.6.4 模块结构:"></a>2.6.4 模块结构:</h3><p>大部分现代操作系统采用模块结构:</p>
<p>– 使用面向对象方法</p>
<p>– 每个核心部件分开</p>
<p>– 每个与其他组件的会话被称为接口</p>
<p>– 每个组件在需要时被加载到内核</p>
<p>总体而言,与层次结构差不多,但是更加灵活.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618164725674.png" alt="image-20230618164725674"></p>
<h2 id="2-7-虚拟机"><a href="#2-7-虚拟机" class="headerlink" title="2.7 虚拟机:"></a>2.7 虚拟机:</h2><p>通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统.</p>
<p>物理计算机的资源被共享，以创建虚拟机.</p>
<p>虚拟机是研发操作系统的完美载体.</p>
<h1 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3.进程管理:"></a>3.进程管理:</h1><h2 id="3-1-进程"><a href="#3-1-进程" class="headerlink" title="3.1 进程:"></a>3.1 进程:</h2><p>定义：执行中的程序.</p>
<p>程序是被动的实体,进程是主动的实体,当一个程序被载入到内存中时,这个程序就会变成进程.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618165842699.png" alt="image-20230618165842699"></p>
<p>一个进程一般由以下内容，即进程在内存中的结构形式。</p>
<ol>
<li>代码段（code section）</li>
</ol>
<p>又称文本段（text section），通过程序计数器和处理器寄存器</p>
<p>的内容来表示当前活动（current activity)</p>
<ol start="2">
<li>栈（stack)：</li>
</ol>
<p>包含临时数据，如函数参数，返回地址，局部变量</p>
<ol start="3">
<li>数据段（data section）</li>
</ol>
<p>包含全局变量</p>
<ol start="4">
<li>堆（heap）</li>
</ol>
<p>在进程运行期间动态分配的内存</p>
<p>简单理解为:代码加数据,加堆栈.</p>
<h2 id="3-2-进程控制块"><a href="#3-2-进程控制块" class="headerlink" title="3.2 进程控制块:"></a>3.2 进程控制块:</h2><p>操作系统是通过“控制表”对系统中的每个资源进行管理.</p>
<p>每个进程在操作系统内用进程控制块（Process Control Block：PCB）来表示，</p>
<p>进程在操作系统中体现的数据结构。它包含许多与一个特定进程相关的信息.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618170215803.png" alt="image-20230618170215803"></p>
<p>父进程调用子进程,进程之间是树形结构.</p>
<h2 id="3-3-进程状态"><a href="#3-3-进程状态" class="headerlink" title="3.3 进程状态:"></a>3.3 进程状态:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618170326844.png" alt="image-20230618170326844"></p>
<h2 id="3-4-进程调度"><a href="#3-4-进程调度" class="headerlink" title="3.4 进程调度:"></a>3.4 进程调度:</h2><h3 id="3-4-1-进程调度队列"><a href="#3-4-1-进程调度队列" class="headerlink" title="3.4.1 进程调度队列:"></a>3.4.1 进程调度队列:</h3><p>多道程序类型(multiprogramming)的目的是无论何时都有进程在运行，从而使CPU的利用率达到最大。为此，CPU需要在多个可用进程之间进行快速切换，调度程序从多个可用进程中选择一个进程运行.</p>
<p>操作系统持有就绪队列和一组设备队列，进程可以在多个调度队列之间移动.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618170513660.png" alt="image-20230618170513660"></p>
<p>当进程分配到CPU并运行时（运行状态），也就是进程运行过程中，可能发生下面事件中的一种并进入到就绪状态：</p>
<p><strong>1.</strong> <strong>进程可能发出一个 I&#x2F;O 请求，并被放到 I&#x2F;O 队列</strong></p>
<p><strong>2.</strong> <strong>进程可能创建一个新的子进程，并等待该子进程结束</strong></p>
<p><strong>3.</strong> <strong>进程可能会由于等待中断而强制释放 CPU，并被放回到就绪队列</strong></p>
<p><strong>4.</strong> <strong>用完时间片（time slice &#x2F; time quantum)，并被放到就绪队列</strong></p>
<p>调度程序:</p>
<p>在就绪队列里选择程序的时候.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618170725432.png" alt="image-20230618170725432"></p>
<h3 id="3-4-2-上下文切换"><a href="#3-4-2-上下文切换" class="headerlink" title="3.4.2 上下文切换:"></a>3.4.2 上下文切换:</h3><p>当CPU从当前进程切换到另一个进程时，系统必须保存当前进程的相关信息，以备被切换的进程恢复运行.</p>
<p>将CPU切换到另一个进程需要保存当前进程的状态，并恢复另一个进程状态，这一任务称为上下文切换.</p>
<h2 id="3-5-进程操作"><a href="#3-5-进程操作" class="headerlink" title="3.5 进程操作:"></a>3.5 进程操作:</h2><h3 id="3-5-1-进程创建"><a href="#3-5-1-进程创建" class="headerlink" title="3.5.1 进程创建:"></a>3.5.1 进程创建:</h3><p>选项:</p>
<p><strong>1. 资源共享选项</strong></p>
<p>① 父进程和子进程共享所有资源</p>
<p>② 子进程共享父进程的部分资源</p>
<p>③ 父进程和子进程不共享资源</p>
<p><strong>2. 执行选项</strong></p>
<p>① 父进程和子进程同时执行</p>
<p>② 父进程等待子进程结束</p>
<p><strong>3. 地址空间选项</strong></p>
<p>① 子进程完全复制父进程内容</p>
<p>② 子进程覆盖父进程内存空间</p>
<p>过程:</p>
<ol>
<li>在系统内部创建进程控制块</li>
<li>分配内存</li>
<li>载入可执行文件（通过调用exec()系统调用）</li>
<li>初始化程序</li>
</ol>
<p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br><span class="line">//返回：success 返回两次 返回值为0 代表当前进程是子进程</span><br><span class="line">//					   返回值为非负数 代表当前进程是父进程，返回值为子进程ID</span><br><span class="line"></span><br><span class="line">// 获取子进程退出状态并返回死掉的子进程ID </span><br><span class="line">pid_t wait(int *stat_loc);</span><br><span class="line">参数为null 表示任意子进程结束就可以继续运行</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">2. pid_t pid;</span><br><span class="line">3. /* fork another process */</span><br><span class="line">4. pid = fork();</span><br><span class="line">5. if (pid &lt; 0) &#123; /* error occurred */</span><br><span class="line">6. fprintf(stderr, &quot;Fork Failed&quot;);</span><br><span class="line">7. exit(-1);</span><br><span class="line">8. &#125;</span><br><span class="line">9. else if (pid == 0) &#123; /* child process */</span><br><span class="line">10. printf(“I am a Child\n”);</span><br><span class="line">11. &#125;</span><br><span class="line">12. else &#123; /* parent process */</span><br><span class="line">13. /* parent will wait for the child to complete */</span><br><span class="line">14. wait (NULL);</span><br><span class="line">15. printf (“I am a Parent\n&quot;);</span><br><span class="line">16. exit(0);</span><br><span class="line">17. &#125;</span><br><span class="line">18. &#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，child和parent是按照顺序输出的，因为父进程只有在子进程结束之后才会继续运行。</p>
<p>如果没有这一句，那么父进程和子进程的结束时间是不可预测的，可能子进程还没有结束，但是父进程已经运行到了else 所以输出顺序不知。</p>
<p>与之前c语言创建函数不同的是，那个程序是在一个进程中的，这个是两个不同的进程，注意区分。</p>
<h3 id="3-5-2-进程终止"><a href="#3-5-2-进程终止" class="headerlink" title="3.5.2 进程终止:"></a>3.5.2 进程终止:</h3><p>进程完成最后语句，并使用 exit( ) 系统调用请求操作系统删除自身，并终止运行，这时，</p>
<p>进程可以通过 wait( ) 函数返回状态值给父进程并释放资源，资源被操作系统收回.</p>
<p>父进程可以用 abort( ) 系统调用终止子进程的执行.</p>
<p>如果一个进程终止，它的所有子进程也将终止，这种终止被称为级联终止（Cascading Termination）.</p>
<p>僵尸进程:</p>
<p>即在僵尸状态的进程，它是进程终止的特殊情况，即一个进程结束，但是他的父进程没有等待他(调用wait&#x2F;waitpid)，那么他将成</p>
<p>为一个僵尸进程。</p>
<h2 id="3-6-进程间通信"><a href="#3-6-进程间通信" class="headerlink" title="3.6 进程间通信:"></a>3.6 进程间通信:</h2><p>系统内并发运行的进程可以是相互独立或协作工作，进程协作的理由有信息共享、提高运算速度、模块化、方便.</p>
<p>大部分进程都需要进行进程的通信,主要分为消息传递和共享内存两种方式.</p>
<h3 id="3-6-1-消息传递"><a href="#3-6-1-消息传递" class="headerlink" title="3.6.1 消息传递:"></a>3.6.1 消息传递:</h3><p>一个进程传递消息给另一个进程,易于实现,但是需要内核的参与.适合传输少量的数据.</p>
<p>消息传递功能提供了两种操作：发送消息和接收消息 。而且消息可以是定长的或变长的.</p>
<p>假设进程 P 和 Q 需要通信，首先需要建立通信线路(communication link)，并相互发送消息和接受消息.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618172316544.png" alt="image-20230618172316544"></p>
<h4 id="3-6-1-1-直接通信"><a href="#3-6-1-1-直接通信" class="headerlink" title="3.6.1.1 直接通信:"></a>3.6.1.1 直接通信:</h4><p>需要通信的每个进程必须明确地命名通信的接受者和发送者.</p>
<p>就是知道对方进程的信息,直接与其联系.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618172417376.png" alt="image-20230618172417376"></p>
<p>在非对称寻址当中,一个进程可以接受多个进程发来的消息.</p>
<h4 id="3-6-1-2-间接通信"><a href="#3-6-1-2-间接通信" class="headerlink" title="3.6.1.2: 间接通信:"></a>3.6.1.2: 间接通信:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618172629694.png" alt="image-20230618172629694"></p>
<p>操作系统拥有的邮箱（端口）是独立存在的，操作系统必须提供机制以允许进程进行如下操作:</p>
<ol>
<li>创建或删除邮箱（端口）</li>
<li>通过邮箱（端口）发送和接受消息</li>
</ol>
<p>世界标准邮箱（端口）如 网页WEB使用80号端口，FTP使用21号端口，Telnet 使用 23号端口, ssh 使用22号等.</p>
<p>比如一个web后端项目打开了8080端口,那么其他进程只需要访问这个端口,就相当于和这个后端项目进行通信,可以获得其对应的信息.</p>
<p>再比如java后端代码和数据库之间的连接也是通过一个端口(一般是3306)来获取信息的.</p>
<h4 id="3-6-1-3-同步和异步"><a href="#3-6-1-3-同步和异步" class="headerlink" title="3.6.1.3 同步和异步:"></a>3.6.1.3 同步和异步:</h4><p>消息传递可以是同步或异步，又称为阻塞(blocking)或非阻塞(non-blocking).</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618172959459.png" alt="image-20230618172959459"></p>
<p>简单来说,同步就是只能发消息,消息不接收就不能进行操作.</p>
<h4 id="3-6-1-4-缓冲："><a href="#3-6-1-4-缓冲：" class="headerlink" title="3.6.1.4 缓冲："></a>3.6.1.4 缓冲：</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618210758238.png" alt="image-20230618210758238"></p>
<p>缓冲队列一共分为三种：零容量，有限容量，无限容量。</p>
<h3 id="3-6-2-共享内存"><a href="#3-6-2-共享内存" class="headerlink" title="3.6.2 共享内存:"></a>3.6.2 共享内存:</h3><p>两个或者多个进程共享同一块区域的内存,使用时直接读取.</p>
<p>速度更快,不需要内核的干涉.但是存在一些问题:</p>
<p>1.每个进程都有自己受保护的内存地址空间,通常操作系统试图阻止一个进程访问另一个进程的内存</p>
<p>地址空间.为了实现共享内存、便于两个或多个进程可以访问内存，共享区域应取消这个限制.</p>
<p>2.必须保障不能有两个以上的进程同时向共享区域写入数据，即需要一个同步机制.</p>
<h4 id="3-6-2-1-生产者-消费者问题"><a href="#3-6-2-1-生产者-消费者问题" class="headerlink" title="3.6.2.1 生产者-消费者问题:"></a>3.6.2.1 生产者-消费者问题:</h4><p>共享内存典型范例为生产者进程产生信息以供消费者进程消费的问题，即生产者和消费者问题.</p>
<p>为了允许生产者进程和消费者进程能并发运行，必须要有缓冲区被生产者和消费者所使用，此缓冲区为共享内存区域，该区域的实现可以采用以下两种方式:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618172224467.png" alt="image-20230618172224467"></p>
<h2 id="3-7-客户机与服务器系统间通信："><a href="#3-7-客户机与服务器系统间通信：" class="headerlink" title="3.7 客户机与服务器系统间通信："></a>3.7 客户机与服务器系统间通信：</h2><h3 id="3-7-1-套接字："><a href="#3-7-1-套接字：" class="headerlink" title="3.7.1 套接字："></a>3.7.1 套接字：</h3><p>套接字（Sockets）由IP地址和端口号连接组成.连接由一对套接字组成。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618211224836.png" alt="image-20230618211224836"></p>
<h3 id="3-7-2-RPC"><a href="#3-7-2-RPC" class="headerlink" title="3.7.2 RPC:"></a>3.7.2 RPC:</h3><p>远程过程调用(Remote Procedure Call:RPC)抽象化了通过网络连接的进程之间过程调用。</p>
<p>Stubs(存根)：远程过程的代理，隐藏了通信发生的细节,每个独立的远程过程都有一个存根.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618211327183.png" alt="image-20230618211327183"></p>
<h3 id="3-7-3-RMI"><a href="#3-7-3-RMI" class="headerlink" title="3.7.3 RMI:"></a>3.7.3 RMI:</h3><p>Remote Method Invocation:RMI类似于远程过程调用，是RPC的JAVA 特性。</p>
<p>与RPC的不同,RPC调用远程子程序或函数，RMI调用远程对象的方法,RPC参数传递方式是普通数据结构，RMI参数传递方式可以是对象.</p>
<h2 id="3-8-管道"><a href="#3-8-管道" class="headerlink" title="3.8 管道:"></a>3.8 管道:</h2><p>进程之间进行通信的另一种方式，管道通信方式的中间介质是文件，通常称这种文件为管道文件。</p>
<p>如两个进程利用管道文件进行通信时，一个进程为写进程，另一个进程为读进程。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618211640041.png" alt="image-20230618211640041"></p>
<h3 id="3-8-1-管道实现："><a href="#3-8-1-管道实现：" class="headerlink" title="3.8.1 管道实现："></a>3.8.1 管道实现：</h3><p>FIFO (First In, First Out)缓冲区就像一个队列，在队列的一端添加元素，并以相同的顺序从另一端退出，任何一个元素都不可能先于另一个元素前进。</p>
<p>Multiple Inputs-多输入管道：一个管道可以有多个输入,但除了先进先出，没有顺序的保证。</p>
<h1 id="4-线程："><a href="#4-线程：" class="headerlink" title="4.线程："></a>4.线程：</h1><p>为了提高CPU的使用率，目前我们想到的办法是多道程序，即当一个进程阻塞时（比如发生I&#x2F;O请求的时候）切换到另一个进程运行。这确实能提高CPU的使用率，但伴随着一些代价，比如上下文切换。</p>
<p>线程的出现就是为了解决只使用进程管理程序的高代价问题而出现的一种技术.</p>
<h2 id="4-1-多线程进程："><a href="#4-1-多线程进程：" class="headerlink" title="4.1 多线程进程："></a>4.1 多线程进程：</h2><p>一个进程可以拥有多个线程，而且线程之间共享以下内容：</p>
<ol>
<li>代码段，全局变量</li>
<li>打开的文件标识符</li>
<li>工作环境，包括当前目录，用户权限等</li>
</ol>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618212145529.png"></p>
<p>每个线程是独立的调度对象,一个进程可以拥有单个或多个线程，并共享内存空间.</p>
<h2 id="4-2-关系模型："><a href="#4-2-关系模型：" class="headerlink" title="4.2 关系模型："></a>4.2 关系模型：</h2><p>操作系统的服务与线程之间存在某种关系，这个关系我们叫做关系模型</p>
<h3 id="4-2-1-线程分类："><a href="#4-2-1-线程分类：" class="headerlink" title="4.2.1 线程分类："></a>4.2.1 线程分类：</h3><p>与双重模式操作一样，线程也分为两类：</p>
<p><strong>1.</strong> <strong>用户线程</strong></p>
<p>I. 用户线程受内核的支持</p>
<p>II. 用户线程是由用户层的线程库来管理，无需内核管理</p>
<p>III. 当前主要线程库有：(1)POSIX Pthreads, (2)Win32 Threads, (3)Java Threads</p>
<p><strong>2.</strong> <strong>内核线程</strong></p>
<p>I. 内核线程是由内核来管理</p>
<p>II. 有内核来进行维护和调度</p>
<p>III. 当前通用的操作系统，如 Windows, Solaris, Linux, Tru64 UNIX, Mac OS X 等都是支持内核线程</p>
<h3 id="4-2-2-一对一模型："><a href="#4-2-2-一对一模型：" class="headerlink" title="4.2.2 一对一模型："></a>4.2.2 一对一模型：</h3><p>一个用户线程映射到一个内核线程的模型，Linux，Windows.</p>
<p>一对一模型的唯一的缺点是创建一个用户线程就需要创建一个内核线程，造成内核负担重。</p>
<h3 id="4-2-3-多对一模型："><a href="#4-2-3-多对一模型：" class="headerlink" title="4.2.3 多对一模型："></a>4.2.3 多对一模型：</h3><p>多个用户线程对应一个内核线程。</p>
<p>多对一模型的缺点是一个用户线程一但被阻塞，其他用户线程也会阻塞，即针对同一个内核线程服务的用户线程无法提供并发功能。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618212756823.png" alt="image-20230618212756823"></p>
<h3 id="4-2-4-多对多模型："><a href="#4-2-4-多对多模型：" class="headerlink" title="4.2.4 多对多模型："></a>4.2.4 多对多模型：</h3><p>多个用户线程对应着多个内核线程。</p>
<p>多对多模型没有以上缺点，当一个线程执行阻塞系统调用时，内核能调度另一个线程的执行，但需要提供调度机制。</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618212925784.png" alt="image-20230618212925784"></p>
<h3 id="4-2-5-混合模型："><a href="#4-2-5-混合模型：" class="headerlink" title="4.2.5 混合模型："></a>4.2.5 混合模型：</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618212953666.png" alt="image-20230618212953666"></p>
<h2 id="4-3-线程库："><a href="#4-3-线程库：" class="headerlink" title="4.3 线程库："></a>4.3 线程库：</h2><p>为程序员提供的、创建和管理线程的 API， 主要有以下两种方法来实现。</p>
<ol>
<li>非嵌入到内核的方式：</li>
</ol>
<p>是在用户空间中提供一个没有内核支持的库，此库的所有代码和</p>
<p>数据结构都存在于用户空间中</p>
<ol start="2">
<li>嵌入到内核的方式</li>
</ol>
<p>是操作系统直接支持的内核库，此时所有代码和数据结构都存在</p>
<p>于内核中.</p>
<h2 id="4-4-多线程程序相关问题："><a href="#4-4-多线程程序相关问题：" class="headerlink" title="4.4 多线程程序相关问题："></a>4.4 多线程程序相关问题：</h2><h3 id="4-4-1-fork-和exec"><a href="#4-4-1-fork-和exec" class="headerlink" title="4.4.1 fork()和exec():"></a>4.4.1 fork()和exec():</h3><p>如果进程中的某一个线程调用 fork()，那么新进程会复制所有线程呢，还是只复制调用 fork()的线程呢？</p>
<p>如调用exec()，就复制一个,如不调用exec()，就复制全部.</p>
<h3 id="4-4-2-线程取消"><a href="#4-4-2-线程取消" class="headerlink" title="4.4.2 线程取消:"></a>4.4.2 线程取消:</h3><p>线程完成任务之前终止线程的任务.</p>
<p>目标线程的取消可能发生“要取消的线程正在更新与其他线程</p>
<p>所共享的数据”，为此，提供以下两种取消方式：</p>
<ol>
<li>异步取消（Asynchronous Cancellation）：一个线程立即终止</li>
</ol>
<p>目标线程.</p>
<ol start="2">
<li>延迟取消（Deferred Cancellation）：目标线程不断地检查它</li>
</ol>
<p>是否应终止.</p>
<h3 id="4-4-3-信号处理"><a href="#4-4-3-信号处理" class="headerlink" title="4.4.3 信号处理:"></a>4.4.3 信号处理:</h3><p>信号是用来通知进程某个特定事件的发生，这需要操作系统提供</p>
<p>一种内核和进程之间的通信机制。信号有以下两种：</p>
<p>I. 同步信号(内部信号)：进程本身事件产生的信号，如访问非法内存、除</p>
<p>零等</p>
<p>II. 异步信号(外部信号)：进程之外事件产生的信号，如按CTRL+C键等</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618213517984.png" alt="image-20230618213517984"></p>
<h3 id="4-4-4-线程池"><a href="#4-4-4-线程池" class="headerlink" title="4.4.4 线程池:"></a>4.4.4 线程池:</h3><p>线程池（thread pool）的主要思想是在进程开始时创建一定数量的线程，并放入到进程池中等待工作。</p>
<h3 id="4-4-5-调度程序的激活"><a href="#4-4-5-调度程序的激活" class="headerlink" title="4.4.5 调度程序的激活:"></a>4.4.5 调度程序的激活:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618213823826.png" alt="image-20230618213823826"></p>
<h1 id="5-CPU调度"><a href="#5-CPU调度" class="headerlink" title="5.CPU调度:"></a>5.CPU调度:</h1><p>多道程序的目的是使CPU的使用率最大化.</p>
<p>一个进程的执行由CPU执行(CPU区间)和I&#x2F;O等待(I&#x2F;O区间)组成。进程在执行的过程中，不断在这两个状态之间的进行切换.</p>
<p>经过对大量进程进行分析，得出的结论显示进程一般由大量的短CPU区间（&lt;8ms）和少量的长CPU区间组成.</p>
<p>1.I&#x2F;O为主的程序里短CPU区间较多，</p>
<p>2.CPU为主的程序里长CPU区间较少.</p>
<p>每当CPU空闲时，调度程序(短期调度程序)从就绪队列中选择一个进程，并为之分配CPU.</p>
<p>可以采用各种不同的排序方式对就绪队列中的进程进行排序(可以理解为不同的调度算法).</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618214506962.png" alt="image-20230618214506962"></p>
<h2 id="5-1-非抢占调度和抢占调度"><a href="#5-1-非抢占调度和抢占调度" class="headerlink" title="5.1 非抢占调度和抢占调度:"></a>5.1 非抢占调度和抢占调度:</h2><p>非抢占调度（nonpreemptive）:</p>
<p>一旦把CPU分配给一个进程，直到该进程结束之前，不能把CPU分配给其他进程.</p>
<p>抢占调度（preemptive） :</p>
<p>进程在执行过程中，可以被其他进程抢占CPU使用权.</p>
<h2 id="5-2-分派程序"><a href="#5-2-分派程序" class="headerlink" title="5.2 分派程序:"></a>5.2 分派程序:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230618214632539.png" alt="image-20230618214632539"></p>
<h2 id="5-3-调度准则"><a href="#5-3-调度准则" class="headerlink" title="5.3 调度准则:"></a>5.3 调度准则:</h2><h3 id="5-3-1-因素"><a href="#5-3-1-因素" class="headerlink" title="5.3.1 因素:"></a>5.3.1 因素:</h3><ol>
<li><p>CPU使用率（CPU Utilization）：需要使CPU尽可能忙</p>
</li>
<li><p>吞吐量（Throughput）：指的是在一个时间单元内所完成的进程数量</p>
</li>
<li><p>周转时间（Turnaround Time) ：从进程提交到进程完成的时间段称为周转时间。周转时间为所有时间段之和，包括等待进入内存，在就绪队列中等待，在CPU上执行和I&#x2F;O执行</p>
</li>
<li><p>等待时间（Waiting Time）：在就绪队列中等待的时间</p>
</li>
<li><p>响应时间（Response Time）： 从提交请求到产生第一相应的时间。注意， 它是开始响应所需要的时间，而不是输出响应所需要的时间（交互系统）</p>
</li>
</ol>
<h3 id="5-3-2-先到先服务"><a href="#5-3-2-先到先服务" class="headerlink" title="5.3.2 先到先服务:"></a>5.3.2 先到先服务:</h3><p>哪个进程先来了,就调用那个进程.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619121234146.png" alt="image-20230619121234146"></p>
<p>平均等待时间就是所有进程的等待时间&#x2F;进程数量.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619121346183.png" alt="image-20230619121346183"></p>
<p>由于上述问题,先到先服务算法不能很好的满足所有进程的需要.</p>
<h3 id="5-3-3-最短作业优先"><a href="#5-3-3-最短作业优先" class="headerlink" title="5.3.3 最短作业优先:"></a>5.3.3 最短作业优先:</h3><p>选择CPU区间长度最短的进程，这里的CPU区间是进程的下一个CPU区间（也就是剩余CPU区间），而不是进程整个区间长度。可分为非抢占调度和抢占调度.</p>
<p>对于给定的一组进程，在平均等待时间上，最短作业优先调度算法是最优算法.</p>
<p>问题是预先知道下一个CPU区间(remaining execution time)的长度是有难度的。</p>
<p>非抢占式:</p>
<p>在一个进程结束后,从等待的进程里选择区间时间最小的进程开始运行.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619122506499.png" alt="image-20230619122506499"></p>
<p>抢占式:</p>
<p>在一个进程运行时,如果有区间时间更短的进程开始,就抢占当前的进程,在当前进程完成之后,在运行上一个进程.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619122659539.png" alt="image-20230619122659539"></p>
<p>每个进程都有它的优先级，通常用数字来表示进程的优先级，数字值越小它的优先级越高。</p>
<h4 id="5-3-3-1-问题"><a href="#5-3-3-1-问题" class="headerlink" title="5.3.3.1 问题:"></a>5.3.3.1 问题:</h4><p>无限阻塞:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619122803348.png" alt="image-20230619122803348"></p>
<p>解决方案:增加进程的随着时间增加而增加的优先级.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619122851058.png" alt="image-20230619122851058"></p>
<h3 id="5-3-4-轮换法"><a href="#5-3-4-轮换法" class="headerlink" title="5.3.4 轮换法:"></a>5.3.4 轮换法:</h3><p>给每个进程分配一个时间片(time slice, time quantum)。时间片一般是10-100毫秒.</p>
<p>系统每隔一个时间片发出一个时钟中断(clock interrupt)，并调度另一个进程执行. </p>
<p>如果进程在给定的时间片内提前结束，发生中断并调度另一个进程.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619123131091.png" alt="image-20230619123131091"></p>
<p>根据经验,时间片大于80%的CPU区间即可.</p>
<h3 id="5-3-5-多级队列"><a href="#5-3-5-多级队列" class="headerlink" title="5.3.5 多级队列:"></a>5.3.5 多级队列:</h3><p>将就绪队列分为多个不同的队列,每个队列都有自己的调度算法,而不同队列之间也有响应的调度机制.</p>
<p>类似于分布式的思想.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619123332735.png" alt="image-20230619123332735"></p>
<h3 id="5-3-6-多级反馈队列"><a href="#5-3-6-多级反馈队列" class="headerlink" title="5.3.6 多级反馈队列;"></a>5.3.6 多级反馈队列;</h3><p>进程可以在多个队列之间移动.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619123434011.png" alt="image-20230619123434011"></p>
<h2 id="5-4-多处理器调度"><a href="#5-4-多处理器调度" class="headerlink" title="5.4 多处理器调度:"></a>5.4 多处理器调度:</h2><h3 id="5-4-1-介绍"><a href="#5-4-1-介绍" class="headerlink" title="5.4.1 介绍:"></a>5.4.1 介绍:</h3><p>同构处理器:功能,结构相同.</p>
<p>异构处理器:功能,结构不同.</p>
<h3 id="5-4-2-处理类型"><a href="#5-4-2-处理类型" class="headerlink" title="5.4.2 处理类型:"></a>5.4.2 处理类型:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619123609295.png" alt="image-20230619123609295"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619123642665.png" alt="image-20230619123642665"></p>
<p>负载平衡（load balancing）:</p>
<p>保持所有处理器的工作负载均衡.</p>
<h2 id="5-5-线程调度"><a href="#5-5-线程调度" class="headerlink" title="5.5 线程调度:"></a>5.5 线程调度:</h2><p>区分用户线程和内核线程， 多线程系统的调度对象是线程.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619123853547.png" alt="image-20230619123853547"></p>
<h2 id="5-6-实时调度"><a href="#5-6-实时调度" class="headerlink" title="5.6 实时调度:"></a>5.6 实时调度:</h2><p>进程有截止时间的要求.这种进程被称为实时任务.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619124019791.png" alt="image-20230619124019791"></p>
<p>算法:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619124036852.png" alt="image-20230619124036852"></p>
<h1 id="6-进程同步"><a href="#6-进程同步" class="headerlink" title="6.进程同步:"></a>6.进程同步:</h1><p>多个进程同步工作时,需要共享数据,确保数据一致性.</p>
<p>避免发生进程之间竞争的关键问题是确保操作共享数据的代码段执行同步.</p>
<h2 id="6-1-临界区问题"><a href="#6-1-临界区问题" class="headerlink" title="6.1 临界区问题:"></a>6.1 临界区问题:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619124331192.png" alt="image-20230619124331192"></p>
<p>1.确保单个进程在临界区执行.</p>
<p>2.确保其他进程也可以进入临界区.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619124425633.png" alt="image-20230619124425633"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619124510225.png" alt="image-20230619124510225"></p>
<h2 id="6-2-Peterson-96-s-算法"><a href="#6-2-Peterson-96-s-算法" class="headerlink" title="6.2  Peterson&#96;s 算法:"></a>6.2  Peterson&#96;s 算法:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619124734142.png" alt="image-20230619124734142"></p>
<p>这段代码的意识是i想进入临界区.</p>
<p>首先设置其flag为true,然后用while语句进行等待,如果j依然在临界区,就不会继续进行下去,即程序不会继续进行.</p>
<p>然后i进入临界区,进行操作,然后再设置为false.</p>
<h2 id="6-3-硬件同步"><a href="#6-3-硬件同步" class="headerlink" title="6.3 硬件同步:"></a>6.3 硬件同步:</h2><p>许多系统拥有简单的,不可中断的指令,用他们来解决临界区问题.</p>
<h3 id="6-3-1-有限等待原子指令"><a href="#6-3-1-有限等待原子指令" class="headerlink" title="6.3.1 有限等待原子指令:"></a>6.3.1 有限等待原子指令:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619125114578.png" alt="image-20230619125114578"></p>
<h2 id="6-4-信号量"><a href="#6-4-信号量" class="headerlink" title="6.4 信号量:"></a>6.4 信号量:</h2><p>无忙等待的同步功能工具.</p>
<h3 id="6-4-1-二进制信号量"><a href="#6-4-1-二进制信号量" class="headerlink" title="6.4.1 二进制信号量:"></a>6.4.1 二进制信号量:</h3><p>适用于单资源的共享,又称为互斥锁.</p>
<p>信号量的实现关键是保障 wait( ) (减)和 signal( ) (加)操作的原子执行，即必须保障没有两个进程能同时对同⼀信号量执⾏ wait( )和 signal( ) 操作。</p>
<h3 id="6-4-2-无忙等待"><a href="#6-4-2-无忙等待" class="headerlink" title="6.4.2 无忙等待:"></a>6.4.2 无忙等待:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619125615346.png" alt="image-20230619125615346"></p>
<h3 id="6-4-3-优化约束"><a href="#6-4-3-优化约束" class="headerlink" title="6.4.3 优化约束:"></a>6.4.3 优化约束:</h3><p>计数信号量可以适用于优化约束问题.</p>
<p>即把信号量设置为0,先开始的那个进程不需要减信号量,只需要在结束之后对信号量加一,表示已经被释放.</p>
<p>而后开始的进程需要在一开始减去信号量,在最后也不需要加上信号量.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">P1:</span><br><span class="line">do&#123;</span><br><span class="line">//write operation</span><br><span class="line">signal (mutex);</span><br><span class="line">&#125; while (TRUE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">P2:</span><br><span class="line">do&#123;</span><br><span class="line">wait (mutex);</span><br><span class="line">// read operation</span><br><span class="line">&#125; while (TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-5-死锁与饥饿"><a href="#6-5-死锁与饥饿" class="headerlink" title="6.5 死锁与饥饿:"></a>6.5 死锁与饥饿:</h2><p>两个或者多个线程无限的等待一个事件,而这些事件只能由这些等待的线程产生.</p>
<p>与死锁相关的另⼀个问题是饥饿问题:即进程在信号量内无限期的等待.</p>
<h2 id="6-6-经典同步问题"><a href="#6-6-经典同步问题" class="headerlink" title="6.6 经典同步问题:"></a>6.6 经典同步问题:</h2><h3 id="6-6-1-有限缓冲"><a href="#6-6-1-有限缓冲" class="headerlink" title="6.6.1 有限缓冲:"></a>6.6.1 有限缓冲:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619125929571.png" alt="image-20230619125929571"></p>
<p><strong>假定缓冲池中有 n 个缓冲项, 每个缓冲项能存⼀个数据项</strong></p>
<p><strong>1.</strong> <strong>⽤信号量 empty: 表⽰空缓冲项的个数</strong></p>
<p><strong>2.</strong> <strong>⽤信号量 full ：表⽰满缓冲项的个数</strong></p>
<p><strong>3.</strong> <strong>⽤信号量 mutex : 提供对缓冲池的读写互斥</strong></p>
<p>• <strong>信号量 mutex 初始化为1</strong></p>
<p>• <strong>信号量 full 初始化为 0</strong></p>
<p>• <strong>信号量 empty 初始化为 n.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//生产者:</span><br><span class="line">while (true) &#123;</span><br><span class="line">// produce an item</span><br><span class="line">wait (empty); //empty&gt;0, 只要有空缓冲项，就写</span><br><span class="line">wait (mutex);</span><br><span class="line">// add the item to the buffer</span><br><span class="line">signal (mutex);</span><br><span class="line">signal (full);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//消费者</span><br><span class="line">while (true) &#123;</span><br><span class="line">wait (full); //full &gt; 0, 只要缓冲项⾥有数据，就读</span><br><span class="line">wait (mutex);</span><br><span class="line">// remove an item from buffer</span><br><span class="line">signal (mutex);</span><br><span class="line">signal (empty);</span><br><span class="line">// consume the removed item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-2-读者-写者"><a href="#6-6-2-读者-写者" class="headerlink" title="6.6.2 读者-写者:"></a>6.6.2 读者-写者:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619130145782.png" alt="image-20230619130145782"></p>
<h3 id="6-6-3-哲学家进餐"><a href="#6-6-3-哲学家进餐" class="headerlink" title="6.6.3 哲学家进餐:"></a>6.6.3 哲学家进餐:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619130256049.png" alt="image-20230619130256049"></p>
<h2 id="6-7-管程"><a href="#6-7-管程" class="headerlink" title="6.7 管程:"></a>6.7 管程:</h2><p>⼀种⽤于多线程互斥访问共享资源的程序结构.</p>
<p>任⼀时刻最多只有⼀个线程执⾏管程代码.</p>
<h3 id="6-7-1-组成"><a href="#6-7-1-组成" class="headerlink" title="6.7.1 组成:"></a>6.7.1 组成:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619130413194.png" alt="image-20230619130413194"></p>
<p>用条件变量阻塞进程的运行.</p>
<h1 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7.死锁:"></a>7.死锁:</h1><h2 id="7-1-成因"><a href="#7-1-成因" class="headerlink" title="7.1 成因:"></a>7.1 成因:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619130831596.png" alt="image-20230619130831596"></p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619130910933.png" alt="image-20230619130910933"></p>
<p>进程R1,R2 进入无限的等待,即出现了死锁.</p>
<h2 id="7-2-资源分配图"><a href="#7-2-资源分配图" class="headerlink" title="7.2 资源分配图:"></a>7.2 资源分配图:</h2><p>两种节点:进程节点和资源节点.</p>
<p>有向边:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619131104205.png" alt="image-20230619131104205"></p>
<p>如果资源分配图没有环,那么肯定没有死锁,如果有环,就可能发生死锁.</p>
<h2 id="7-3-死锁预防"><a href="#7-3-死锁预防" class="headerlink" title="7.3 死锁预防:"></a>7.3 死锁预防:</h2><h3 id="7-3-1-占有等待"><a href="#7-3-1-占有等待" class="headerlink" title="7.3.1 占有等待:"></a>7.3.1 占有等待:</h3><p>确保当一个进程请求一个资源时，它不能占有其他资源。</p>
<p>实现的方法如下</p>
<p><strong>A. 每个进程在执⾏前申请并获得所有资源</strong></p>
<p><strong>B. 进程只有在不占⽤资源时, 允许进程申请资源</strong></p>
<p>就是已经占有资源的进程不能再占有其他的资源,从而避免了循环的问题.</p>
<h3 id="7-3-2-非抢占"><a href="#7-3-2-非抢占" class="headerlink" title="7.3.2 非抢占:"></a>7.3.2 非抢占:</h3><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619131654530.png" alt="image-20230619131654530"></p>
<h2 id="7-4-避免死锁"><a href="#7-4-避免死锁" class="headerlink" title="7.4 避免死锁:"></a>7.4 避免死锁:</h2><h3 id="7-4-1-资源分配图"><a href="#7-4-1-资源分配图" class="headerlink" title="7.4.1 资源分配图:"></a>7.4.1 资源分配图:</h3><p>需求边是进程指向资源的虚线.</p>
<p>申请边是进程指向资源的实线.</p>
<p>分配边是资源指向进程的实线.</p>
<p>对于申请,如果没有环(不算虚线).就会允许,否则不允许.</p>
<h3 id="7-4-2-银行家算法"><a href="#7-4-2-银行家算法" class="headerlink" title="7.4.2 银行家算法:"></a>7.4.2 银行家算法:</h3><p>由安全性算法和资源请求算法组成.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619133619460.png" alt="image-20230619133619460"></p>
<h4 id="7-4-2-1-安全性算法"><a href="#7-4-2-1-安全性算法" class="headerlink" title="7.4.2.1 安全性算法:"></a>7.4.2.1 安全性算法:</h4><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619133607814.png" alt="image-20230619133607814"></p>
<p>伪代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Work = Available;</span><br><span class="line">l For all i, Finish[i] = false;</span><br><span class="line"></span><br><span class="line">For all i do</span><br><span class="line">if ( Finish[i] == false &amp;&amp; Needi £ Work)</span><br><span class="line">Finish[ i ] = true</span><br><span class="line">Work = Work + Allocationi</span><br><span class="line">End for</span><br><span class="line"></span><br><span class="line">IF for all i, Finish[i] == true</span><br><span class="line">Then the system is safety</span><br><span class="line">End IF</span><br></pre></td></tr></table></figure>

<p>安全检查的是,能否使用当前的所有资源解决所有进程的问题.</p>
<p>所以work还要再加上当前进程已经占有的资源.</p>
<h4 id="7-4-2-2-资源分配算法"><a href="#7-4-2-2-资源分配算法" class="headerlink" title="7.4.2.2 资源分配算法:"></a>7.4.2.2 资源分配算法:</h4><p>假设请求的资源是requesti.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Available = Available – Requesti;</span><br><span class="line">Allocationi = Allocationi + Requesti;</span><br><span class="line">Needi = Needi – Requesti</span><br></pre></td></tr></table></figure>

<p>占用资源加,需要资源和可分配资源减少.相当于分配资源的过程.</p>
<p>每次资源分配之前都需要进行安全性检查.</p>
<h2 id="7-5-死锁检测"><a href="#7-5-死锁检测" class="headerlink" title="7.5 死锁检测:"></a>7.5 死锁检测:</h2><h3 id="7-5-1-单个实例资源"><a href="#7-5-1-单个实例资源" class="headerlink" title="7.5.1 单个实例资源:"></a>7.5.1 单个实例资源:</h3><p>把资源分配图变成等待图.</p>
<p>等待图只有进程到进程的连线,把原先图中的资源去掉.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619163552280.png" alt="image-20230619163552280"></p>
<h3 id="7-5-2-多个实例资源"><a href="#7-5-2-多个实例资源" class="headerlink" title="7.5.2 多个实例资源:"></a>7.5.2 多个实例资源:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Work = Available</span><br><span class="line">For all i do , </span><br><span class="line">IF Allocationi ¹ 0, Finish[i] = false;</span><br><span class="line">ELSE Finish[i] = true;</span><br><span class="line">End For</span><br><span class="line">For all i do , </span><br><span class="line">IF Finish[i] == false &amp;&amp; Requesti £ Work</span><br><span class="line">Work = Work + Allocationi ;</span><br><span class="line">Finish[i] = true;</span><br><span class="line">End IF</span><br><span class="line">If there is a i, Finish[i] == false</span><br><span class="line">then the system is deadlock；</span><br><span class="line">End For</span><br></pre></td></tr></table></figure>

<h2 id="7-6-死锁恢复"><a href="#7-6-死锁恢复" class="headerlink" title="7.6 死锁恢复:"></a>7.6 死锁恢复:</h2><h3 id="7-6-1-终止进程"><a href="#7-6-1-终止进程" class="headerlink" title="7.6.1 终止进程"></a>7.6.1 终止进程</h3><p>通过终止进程的方式恢复死锁.一次只终止一个进程直到取消死锁循环为止, 但要考虑:</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619163801165.png" alt="image-20230619163801165"></p>
<h3 id="7-6-2-抢占资源"><a href="#7-6-2-抢占资源" class="headerlink" title="7.6.2 抢占资源:"></a>7.6.2 抢占资源:</h3><p>通过抢占资源以取消死锁，逐步从进程中抢占资源给其他进程使用，直到死锁被打破为止。</p>
<h1 id="8-内存管理"><a href="#8-内存管理" class="headerlink" title="8.内存管理:"></a>8.内存管理:</h1><p>内存和寄存器是CPU唯一能直接访问的存储器,为了运行程序，必须把程序从磁盘载入到内存.</p>
<p>为确保进程只访问合法地址范围，一个进程使用的内存地址范围是由一对:</p>
<ol>
<li>基地址寄存器(base register)</li>
<li>界限地址寄存器(limit register)</li>
</ol>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619164133435.png" alt="image-20230619164133435"></p>
<h2 id="8-1-地址绑定"><a href="#8-1-地址绑定" class="headerlink" title="8.1 地址绑定:"></a>8.1 地址绑定:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619164228984.png" alt="image-20230619164228984"></p>
<p>地址绑定就是建立逻辑地址到物理地址的映射.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619164313093.png" alt="image-20230619164313093"></p>
<h3 id="8-1-1-时机"><a href="#8-1-1-时机" class="headerlink" title="8.1.1 时机:"></a>8.1.1 时机:</h3><p>程序主要有编译,加载,执行三个过程,这三个过程都可以进行地址绑定.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619164526746.png" alt="image-20230619164526746"></p>
<h2 id="8-2-动态加载"><a href="#8-2-动态加载" class="headerlink" title="8.2 动态加载:"></a>8.2 动态加载:</h2><p>直到被调用之前,程序不会载入内存.</p>
<p>内存使用率高,但是需要特别设计.由程序的设计者决定</p>
<h2 id="8-3-静态-x2F-动态链接"><a href="#8-3-静态-x2F-动态链接" class="headerlink" title="8.3 静态&#x2F;动态链接:"></a>8.3 静态&#x2F;动态链接:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619164735409.png" alt="image-20230619164735409"></p>
<p>动态加载由操作系统决定.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• 常规编译</span><br><span class="line">$ gcc -o main main.o bill.o fred.o</span><br><span class="line">• 静态链接</span><br><span class="line">$ gcc -o slmain main.o libfoo.a</span><br><span class="line">• 动态链接</span><br><span class="line">$ gcc -o dlmain main.c -L ./ -ltest</span><br></pre></td></tr></table></figure>

<h2 id="8-4-交换"><a href="#8-4-交换" class="headerlink" title="8.4 交换:"></a>8.4 交换:</h2><p>进程可以暂时从内存中交换到备份存储上(通常是快速磁盘)，当需要再次执行时再调回到内存.</p>
<p>在编译和加载时进行内存绑定的,交换后必须回到要原位.</p>
<p>在运行时进行内存绑定的,不需要回到原位.</p>
<h2 id="8-5-内存分配方式"><a href="#8-5-内存分配方式" class="headerlink" title="8.5 内存分配方式:"></a>8.5 内存分配方式:</h2><p>为进程分配内存的方式.</p>
<h3 id="8-5-1-连续分配"><a href="#8-5-1-连续分配" class="headerlink" title="8.5.1 连续分配:"></a>8.5.1 连续分配:</h3><p>每个进程位于连续的内存区域（多分区方法和可变分区方法）.</p>
<p>多分区方法:</p>
<p>多个大小固定的分区.这些分区可以是大小相同的,可以是大小不同的.</p>
<p>可变分区方法:</p>
<p>整个内存空间是就是一个大孔, 操作系统用表来记录已用和未用内存.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619184923124.png" alt="image-20230619184923124"></p>
<h3 id="8-5-2-不连续分配"><a href="#8-5-2-不连续分配" class="headerlink" title="8.5.2 不连续分配:"></a>8.5.2 不连续分配:</h3><p>帧：把物理内存划分为固定大小的块儿，称为帧。</p>
<p>页：把逻辑内存划分为固定大小的块儿，称为页。</p>
<p>一个页对应一个帧，当需要分配内存时，以页为单位分配内存.</p>
<p>帧是不连续的内存空间.</p>
<h2 id="8-6-地址变换"><a href="#8-6-地址变换" class="headerlink" title="8.6 地址变换:"></a>8.6 地址变换:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619185435623.png" alt="image-20230619185435623"></p>
<p>为了访问数据，需要两次访问内存,第一次查页表，第二次访问地址.</p>
<h3 id="8-6-1-页表结构"><a href="#8-6-1-页表结构" class="headerlink" title="8.6.1 页表结构:"></a>8.6.1 页表结构:</h3><h4 id="8-6-1-1-层次结构"><a href="#8-6-1-1-层次结构" class="headerlink" title="8.6.1.1 层次结构:"></a>8.6.1.1 层次结构:</h4><p>把逻辑地址编址设为多层次，即多层次的页表。</p>
<p>可以实现页表的不连续存储,节约内存空间.</p>
<h4 id="8-6-1-2-哈希页表"><a href="#8-6-1-2-哈希页表" class="headerlink" title="8.6.1.2 哈希页表:"></a>8.6.1.2 哈希页表:</h4><p>逻辑地址的定义为【虚拟页码，偏移量】把虚拟页码作为哈希值(key).</p>
<p>根据虚拟页码（哈希值）找到匹配的条目，并在链表里找到相对应的帧号.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619190039636.png" alt="image-20230619190039636"></p>
<h4 id="8-6-1-3-反向页表"><a href="#8-6-1-3-反向页表" class="headerlink" title="8.6.1.3 反向页表:"></a>8.6.1.3 反向页表:</h4><p>为了减少页表消耗的内存空间而采用的方法即，整个系统只有一个页表，页表对于每个真正的内存页或帧才建立一个条目.</p>
<h1 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9.虚拟内存:"></a>9.虚拟内存:</h1><p>虚拟内存是内存管理的一种技术，它允许执行进程时不必,完全载入内存，可以部分程序载入到内存.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619190254894.png" alt="image-20230619190254894"></p>
<p>可以提供更有效的进程创建.</p>
<h2 id="9-1-按需调页："><a href="#9-1-按需调页：" class="headerlink" title="9.1 按需调页："></a>9.1 按需调页：</h2><p>按照需要，调取页进入程序。</p>
<h2 id="9-2-页置换："><a href="#9-2-页置换：" class="headerlink" title="9.2 页置换："></a>9.2 页置换：</h2><p>1.找出一个牺牲的帧，并将其换出.</p>
<p>2.需要使用的页，将其换入.</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619202707697.png" alt="image-20230619202707697"></p>
<p>页置换发生两次页传输（换入、换出），导致页处理时间加倍，增加了内存访问时间。</p>
<p>针对这个问题有两种解决方案：</p>
<p>1.每个页关联一个修改位（modify bit）</p>
<p>2.系统保留一个空闲帧缓冲池，当需要牺牲帧写出虚拟内存时，写出之前，从空闲帧缓冲池中先得到内存（即先分配后换出）。</p>
<p>页置换算法：</p>
<p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619202917820.png" alt="image-20230619202917820"></p>
<h1 id="10-文件系统"><a href="#10-文件系统" class="headerlink" title="10.文件系统:"></a>10.文件系统:</h1><p>文件是逻辑外存的最小分配单元.大致分为数据和程序.</p>
<p>文件根据其类型具有不同的结构（格式）.</p>
<h2 id="10-1-文件属性"><a href="#10-1-文件属性" class="headerlink" title="10.1 文件属性:"></a>10.1 文件属性:</h2><p><img src="http://bearsblog.oss-cn-beijing.aliyuncs.com/img/image-20230619190811525.png" alt="image-20230619190811525"></p>
<h2 id="10-2-文件访问"><a href="#10-2-文件访问" class="headerlink" title="10.2 文件访问:"></a>10.2 文件访问:</h2><h3 id="10-2-1-顺序访问"><a href="#10-2-1-顺序访问" class="headerlink" title="10.2.1 顺序访问:"></a>10.2.1 顺序访问:</h3><p>文件信息按顺序，一个记录接着一个记录地加以处理.</p>
<h3 id="10-2-2-直接访问"><a href="#10-2-2-直接访问" class="headerlink" title="10.2.2 直接访问:"></a>10.2.2 直接访问:</h3><ol>
<li>文件由固定长度的逻辑记录组成</li>
<li>操作系统所提供的块儿号通常为相对块号，它是相对于文件开始的索引</li>
</ol>
<h3 id="10-2-3-目录结构"><a href="#10-2-3-目录结构" class="headerlink" title="10.2.3 目录结构:"></a>10.2.3 目录结构:</h3><p>• 每个磁盘分区可以创建一个文件系统</p>
<p>• 存储文件系统的一大块存储空间称为卷</p>
<p>• 每个卷必须包含其文件系统上文件的信息，这些信息保存在设备目录或卷表中。</p>

        </article>
        <div class="post-tools" id="post-tools">
            <div class="post-tools-left">
                
                <div class="share-link mobile">
    <div class="share-qrcode">
        <div class="share-button" title="使用手机访问这篇文章">
            <i class="fas fa-qrcode"></i>
        </div>
        <div class="share-main">
            <div class="share-main-all">
                <div id="qrcode" title="http://example.com/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                </div>
                <div class="reward-dec">使用手机访问这篇文章</div>
            </div>
        </div>
        <script type="text/javascript">
            new QRCode(document.getElementById("qrcode"), "http://example.com/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/");
        </script>
    </div>
</div>
                <div class="share-link weibo"><a class="share-button" target="_blank"
    href="https://service.weibo.com/share/share.php?title=操作系统&amp;url=http://example.com/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&amp;pic=/img/301.jpg"
    title="分享到微博" rel="noopener external nofollow noreferrer noopener">
    <i class="fab fa-weibo" style="font-size:22px"></i>
</a>
</div>
<div class="share-link copyurl">
<div class="share-button" id="post-share-url" title="复制链接" onclick="acrylic.copyPageUrl()">
    <i class="fas fa-link"></i>
</div>
</div>
            </div>
            <div class="post-tools-right">
                <div class="tag_share">
                    <div class="post-meta__tag-list">
                        
                            <a href="/tags/%E8%AF%BE%E7%A8%8B/" class="post-meta__tags">
                                <span class="tags-punctuation">#</span>
                                课程
                                <span class="tagsPageCount">8</span>
                            </a>
                        
                    </div>
                </div>
            </div>
        </div>
        <div class="post-copyright">
    <div class="post-copyright__author">
        <a class="post-copyright__original" title="该文章为原创文章，注意版权协议">原创</a>
        <a class="post-copyright-title" href="#">
            <span>操作系统</span>
        </a>
    </div>
    <div class="post-copyright__type">
        <span class="post-copyright-info" id="post-copyright-url">
            <a href="/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">http://example.com/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a>
        </span>
        <button class="post-copyright-copybtn" onclick="acrylic.copyPageUrl()">
            <i class="fas fa-paste copy-btn"></i>
        </button>
    </div>
    <div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用 <a
                href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a> 协议，完整转载请注明来自 <a
                href="/">风凌渡</a>
            </span>
        </div>
</div>
        <nav class="pagination-post" id="pagination">
    
        <div class="prev-post pull-left">
            <a href="/2023/06/18/%E5%A4%A7%E4%B8%80%E7%AB%8B%E9%A1%B9%E7%88%AC%E8%99%AB/">
                <div class="pagination-info">
                    <div class="label">上一篇</div>
                    <div class="prev_info">大一立项爬虫</div>
                </div>
            </a>
        </div>
        <div class="next-post pull-right">
            <a href="/2023/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">
                <div class="pagination-info">
                    <div class="label">下一篇</div>
                    <div class="next_info">数据库系统</div>
                </div>
            </a>
        </div>
    
</nav>
            
    </div>
    <div class="aside-content" id="aside-content">
    
    
        
        <div class="card-widget card-info">
    <div class="card-content">
        <div class="card-info-avatar is-center">
            <div class="author-info__sayhi" id="author-info__sayhi">
            </div>
            <div class="author-info__name">
                抒情熊
            </div>
            <div class="author-info__description">这有关于<b>后端</b>、<b>架构</b>的相关笔记分享，还有拙作<b>诗歌</b>和<b>小说</b>，另有如<b>奎桑提</b>和<b>奥恩</b>的相关教学。<br>相信会对你有所帮助.</div>
        </div>
    </div>
    <div class="banner-button-group">
        <a class="banner-button" href="/about/">
            <i class="fas fa-circle-chevron-right"></i>
            <span class="banner-button-text">了解更多</span>
        </a>
    </div>
    <div class="card-info-social-icons is-center">
        
            <a class="social-icon" target="_blank" rel="noopener" href="https://github.com/bearslyricattack" title="Github">
                <i class="fa-brands fa-github"></i>
            </a>
        
            <a class="social-icon" target="_blank" rel="noopener" href="https://user.qzone.qq.com/2669184984" title="Mail">
                <i class="fa-solid fa-envelope"></i>
            </a>
        
    </div>
</div>
     
    
    <div class="sticky_layout">
        
            <div class="card-widget" id="card-toc">
    <div class="item-headline">
        <i class="fas fa-bars"></i>
        <span>文章目录</span>
    </div>
    <div class="toc-content" id="toc-content">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BB%AA%E8%AE%BA"><span class="toc-text">1.绪论:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 操作系统定义:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.2 计算机系统:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">1.2.1 体系结构图:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.2.2: 初始化:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E4%B8%AD%E6%96%AD"><span class="toc-text">1.2.3 中断:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-I-x2F-O%E7%BB%93%E6%9E%84"><span class="toc-text">1.2.4 I&#x2F;O结构:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-1-DMA"><span class="toc-text">1.2.4.1 DMA:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-2-I-x2F-O%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2.4.2 I&#x2F;O类型:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-5-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">1.2.5 存储结构:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-6-%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.2.6 处理器系统:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-1-%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">1.2.6.1 单处理器:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-2-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">1.2.6.2 多处理器:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.3 类型:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.3.1 批处理系统:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.3.2 多道程序系统:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.3.3 分时系统:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">1.4 操作：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E5%8F%8C%E9%87%8D%E6%A8%A1%E5%BC%8F%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">1.4.1 双重模式操作：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E7%AE%A1%E7%90%86"><span class="toc-text">1.5 管理:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-text">1.5.1 进程管理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-text">1.5.2 内存管理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-text">1.5.3 文件系统管理：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-1-I-x2F-O%E5%AD%90%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="toc-text">1.5.3.1 I&#x2F;O子系统：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.6 其他操作系统:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text">2.操作系统结构:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-text">2.1 系统服务:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-text">2.2 用户界面:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2"><span class="toc-text">2.2.1 命令行界面:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-text">2.2.2 图形用户界面:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">2.3 系统调用:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">2.3.1 参数传递:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.4 系统程序:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.5 操作系统设计和实现:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%BB%93%E6%9E%84%E7%B1%BB%E5%88%AB"><span class="toc-text">2.6 结构类别:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E7%AE%80%E5%8D%95%E7%BB%93%E6%9E%84"><span class="toc-text">2.6.1 简单结构:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">2.6.2 层次结构:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="toc-text">2.6.3 微内核结构:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><span class="toc-text">2.6.4 模块结构:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">2.7 虚拟机:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">3.进程管理:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%BF%9B%E7%A8%8B"><span class="toc-text">3.1 进程:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-text">3.2 进程控制块:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">3.3 进程状态:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">3.4 进程调度:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-text">3.4.1 进程调度队列:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">3.4.2 上下文切换:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E8%BF%9B%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="toc-text">3.5 进程操作:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">3.5.1 进程创建:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-text">3.5.2 进程终止:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">3.6 进程间通信:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-text">3.6.1 消息传递:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-1-%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">3.6.1.1 直接通信:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-2-%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1"><span class="toc-text">3.6.1.2: 间接通信:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-3-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">3.6.1.3 同步和异步:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-4-%E7%BC%93%E5%86%B2%EF%BC%9A"><span class="toc-text">3.6.1.4 缓冲：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">3.6.2 共享内存:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-1-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">3.6.2.1 生产者-消费者问题:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%AE%A2%E6%88%B7%E6%9C%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">3.7 客户机与服务器系统间通信：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%9A"><span class="toc-text">3.7.1 套接字：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-RPC"><span class="toc-text">3.7.2 RPC:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-RMI"><span class="toc-text">3.7.3 RMI:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%AE%A1%E9%81%93"><span class="toc-text">3.8 管道:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">3.8.1 管道实现：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-text">4.线程：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%EF%BC%9A"><span class="toc-text">4.1 多线程进程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">4.2 关系模型：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%BA%BF%E7%A8%8B%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">4.2.1 线程分类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">4.2.2 一对一模型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">4.2.3 多对一模型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">4.2.4 多对多模型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-text">4.2.5 混合模型：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E5%BA%93%EF%BC%9A"><span class="toc-text">4.3 线程库：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">4.4 多线程程序相关问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-fork-%E5%92%8Cexec"><span class="toc-text">4.4.1 fork()和exec():</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="toc-text">4.4.2 线程取消:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-text">4.4.3 信号处理:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-4-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">4.4.4 线程池:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-5-%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%BF%80%E6%B4%BB"><span class="toc-text">4.4.5 调度程序的激活:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-CPU%E8%B0%83%E5%BA%A6"><span class="toc-text">5.CPU调度:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E9%9D%9E%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6%E5%92%8C%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="toc-text">5.1 非抢占调度和抢占调度:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%88%86%E6%B4%BE%E7%A8%8B%E5%BA%8F"><span class="toc-text">5.2 分派程序:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-text">5.3 调度准则:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E5%9B%A0%E7%B4%A0"><span class="toc-text">5.3.1 因素:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%85%88%E5%88%B0%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-text">5.3.2 先到先服务:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="toc-text">5.3.3 最短作业优先:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-1-%E9%97%AE%E9%A2%98"><span class="toc-text">5.3.3.1 问题:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E8%BD%AE%E6%8D%A2%E6%B3%95"><span class="toc-text">5.3.4 轮换法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">5.3.5 多级队列:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-text">5.3.6 多级反馈队列;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-text">5.4 多处理器调度:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.4.1 介绍:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.4.2 处理类型:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">5.5 线程调度:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-text">5.6 实时调度:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">6.进程同步:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="toc-text">6.1 临界区问题:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Peterson-96-s-%E7%AE%97%E6%B3%95"><span class="toc-text">6.2  Peterson&#96;s 算法:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="toc-text">6.3 硬件同步:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E6%9C%89%E9%99%90%E7%AD%89%E5%BE%85%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4"><span class="toc-text">6.3.1 有限等待原子指令:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">6.4 信号量:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">6.4.1 二进制信号量:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E6%97%A0%E5%BF%99%E7%AD%89%E5%BE%85"><span class="toc-text">6.4.2 无忙等待:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-%E4%BC%98%E5%8C%96%E7%BA%A6%E6%9D%9F"><span class="toc-text">6.4.3 优化约束:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E6%AD%BB%E9%94%81%E4%B8%8E%E9%A5%A5%E9%A5%BF"><span class="toc-text">6.5 死锁与饥饿:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">6.6 经典同步问题:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-%E6%9C%89%E9%99%90%E7%BC%93%E5%86%B2"><span class="toc-text">6.6.1 有限缓冲:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-2-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85"><span class="toc-text">6.6.2 读者-写者:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-3-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90"><span class="toc-text">6.6.3 哲学家进餐:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E7%AE%A1%E7%A8%8B"><span class="toc-text">6.7 管程:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-1-%E7%BB%84%E6%88%90"><span class="toc-text">6.7.1 组成:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%AD%BB%E9%94%81"><span class="toc-text">7.死锁:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%88%90%E5%9B%A0"><span class="toc-text">7.1 成因:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-text">7.2 资源分配图:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-text">7.3 死锁预防:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E5%8D%A0%E6%9C%89%E7%AD%89%E5%BE%85"><span class="toc-text">7.3.1 占有等待:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E9%9D%9E%E6%8A%A2%E5%8D%A0"><span class="toc-text">7.3.2 非抢占:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">7.4 避免死锁:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-1-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-text">7.4.1 资源分配图:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-2-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">7.4.2 银行家算法:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-1-%E5%AE%89%E5%85%A8%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-text">7.4.2.1 安全性算法:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-2-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-text">7.4.2.2 资源分配算法:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">7.5 死锁检测:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-1-%E5%8D%95%E4%B8%AA%E5%AE%9E%E4%BE%8B%E8%B5%84%E6%BA%90"><span class="toc-text">7.5.1 单个实例资源:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-2-%E5%A4%9A%E4%B8%AA%E5%AE%9E%E4%BE%8B%E8%B5%84%E6%BA%90"><span class="toc-text">7.5.2 多个实例资源:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="toc-text">7.6 死锁恢复:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B"><span class="toc-text">7.6.1 终止进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E6%8A%A2%E5%8D%A0%E8%B5%84%E6%BA%90"><span class="toc-text">7.6.2 抢占资源:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">8.内存管理:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A"><span class="toc-text">8.1 地址绑定:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E6%97%B6%E6%9C%BA"><span class="toc-text">8.1.1 时机:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-text">8.2 动态加载:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E9%9D%99%E6%80%81-x2F-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">8.3 静态&#x2F;动态链接:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E4%BA%A4%E6%8D%A2"><span class="toc-text">8.4 交换:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">8.5 内存分配方式:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-1-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-text">8.5.1 连续分配:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-2-%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-text">8.5.2 不连续分配:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-text">8.6 地址变换:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-1-%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">8.6.1 页表结构:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1-1-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">8.6.1.1 层次结构:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1-2-%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8"><span class="toc-text">8.6.1.2 哈希页表:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1-3-%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8"><span class="toc-text">8.6.1.3 反向页表:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">9.虚拟内存:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5%EF%BC%9A"><span class="toc-text">9.1 按需调页：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E9%A1%B5%E7%BD%AE%E6%8D%A2%EF%BC%9A"><span class="toc-text">9.2 页置换：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">10.文件系统:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-text">10.1 文件属性:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE"><span class="toc-text">10.2 文件访问:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE"><span class="toc-text">10.2.1 顺序访问:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="toc-text">10.2.2 直接访问:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-3-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">10.2.3 目录结构:</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
            
        
            
        <div class="card-widget card-recent-post">
    <div class="item-headline">
        <i class="fas fa-list-ol"></i>
        <span>最近发布</span>
    </div>
    <div class="aside-list">
        
        
            <div class="aside-list-item">
                <a class="thumbnail" href="/2023/06/18/%E5%A4%A7%E4%B8%80%E7%AB%8B%E9%A1%B9%E7%88%AC%E8%99%AB/" title="大一立项爬虫">
                    <img
                        alt="大一立项爬虫"
                        src="/img/302.jpg">
                </a>
                <div class="content">
                    
                        <a class="article-recent_post_categories" href="/2023/06/18/%E5%A4%A7%E4%B8%80%E7%AB%8B%E9%A1%B9%E7%88%AC%E8%99%AB/">
                            笔记
                        </a>
                    
                    <a class="title" href="/2023/06/18/%E5%A4%A7%E4%B8%80%E7%AB%8B%E9%A1%B9%E7%88%AC%E8%99%AB/" title="大一立项爬虫">
                        大一立项爬虫
                    </a>
                </div>
            </div>
                
        
            <div class="aside-list-item">
                <a class="thumbnail" href="/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">
                    <img
                        alt="操作系统"
                        src="/img/301.jpg">
                </a>
                <div class="content">
                    
                        <a class="article-recent_post_categories" href="/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                            笔记
                        </a>
                    
                    <a class="title" href="/2023/06/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">
                        操作系统
                    </a>
                </div>
            </div>
                
        
            <div class="aside-list-item">
                <a class="thumbnail" href="/2023/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" title="数据库系统">
                    <img
                        alt="数据库系统"
                        src="/img/100.jpg">
                </a>
                <div class="content">
                    
                        <a class="article-recent_post_categories" href="/2023/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">
                            课程
                        </a>
                    
                    <a class="title" href="/2023/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" title="数据库系统">
                        数据库系统
                    </a>
                </div>
            </div>
                
        
            <div class="aside-list-item">
                <a class="thumbnail" href="/2023/06/07/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%BB%BC%E6%B5%8B%E5%B9%B3%E5%8F%B0/" title="低代码综测平台">
                    <img
                        alt="低代码综测平台"
                        src="/img/200.jpg">
                </a>
                <div class="content">
                    
                        <a class="article-recent_post_categories" href="/2023/06/07/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%BB%BC%E6%B5%8B%E5%B9%B3%E5%8F%B0/">
                            创作
                        </a>
                    
                    <a class="title" href="/2023/06/07/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%BB%BC%E6%B5%8B%E5%B9%B3%E5%8F%B0/" title="低代码综测平台">
                        低代码综测平台
                    </a>
                </div>
            </div>
                
        
            <div class="aside-list-item">
                <a class="thumbnail" href="/2023/06/04/%E6%9C%89%E5%8C%AA/" title="有匪">
                    <img
                        alt="有匪"
                        src="/img/400.jpg">
                </a>
                <div class="content">
                    
                        <a class="article-recent_post_categories" href="/2023/06/04/%E6%9C%89%E5%8C%AA/">
                            创作
                        </a>
                    
                    <a class="title" href="/2023/06/04/%E6%9C%89%E5%8C%AA/" title="有匪">
                        有匪
                    </a>
                </div>
            </div>
            
    </div>
</div>
     
        
    </div>
</div> 
</main>
                <footer id="footer">
                    <div id="footer_deal">
    
        <a class="deal_link" target="_blank" href="https://github.com/bearslyricattack" rel="external nofollow noopener" title="Github">
            <i class="fa-brands fa-github"></i>
        </a>
    
        <a class="deal_link" target="_blank" href="https://user.qzone.qq.com/2669184984" rel="external nofollow noopener" title="Mail">
            <i class="fa-solid fa-envelope"></i>
        </a>
    
    <img class="footer_mini_logo" src="/img/avatar.webp"
        title="返回顶部" onclick="acrylic.toTop()">
    
        <a class="deal_link" target="_blank" href="https://music.163.com/#/user/follows?id=436327083" rel="external nofollow noopener" title="网易云">
            <i class="fa-solid fa-music"></i>
        </a>
    
        <a class="deal_link" target="_blank" href="https://space.bilibili.com/701779878?spm_id_from=333.1007.0.0" rel="external nofollow noopener" title="bilibili">
            <i class="fa-brands fa-bilibili"></i>
        </a>
    
</div>    
<div id="heo-footer">
    
    
</div>
<div id="footer-section">
    <div class="footer-section-links">
        <div class="footer-section-left">
            <div id="footer-section-tips">
                <div class="copyright">©2022 - 2023 By 
                    <a class="footer-section-link" href="/" rel="external nofollow">抒情熊</a>
                    <a class="footer-section-link" href="https://github.com/hexo-theme-Acrylic/Hexo-Theme-Acrylic-Next" rel="external nofollow" target="_blank"> Theme By Acrylic-Next</a>
                </div>
            </div>
        </div>
        <div class="footer-section-right">
            <a class="footer-section-link" href="/rss/">订阅</a>
            
            <a class="footer-section-link cc" target="_blank" href="https://creativecommons.org/licenses/by/4.0/" title="cc协议">
                <i class="fa-solid fa-closed-captioning"></i>
            </a>
        </div>
    </div>
</div>
                </footer>
            </div>
         
        <div>
    <script type="text/javascript" src="/js/utils.js"></script>
    <script type="text/javascript" src="/js/main.js"></script>
    

<script src="/lib/pjax.min.js"></script>



<script src="/lib/snackbar.min.js"></script>


    
<script src="/lib/view-image.min.js"></script>



    
<link rel="stylesheet" href="/lib/swiper.min.css">

    
<script src="/lib/swiper.min.js"></script>


<div id="js-pjax">
    
    
        <script async src="https://npm.elemecdn.com/penndu@1.0.0/bsz.js"></script>
     
</div>

    
<link rel="stylesheet" href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css">

    
<script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script>

    
<script src="https://cdn1.tianli0.top/npm/meting@2.0.1/dist/Meting.min.js"></script>



    
<script src="/js/extend/covercolor/web.js"></script>

        

    <script>
  let pjaxSelectors = [
    'title',
    '#body-wrap',
    '#site-config',
    'meta[name="description"]',
    '#js-pjax'
  ]
  
  const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
  })

  document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
</script>
    
</div>
        
    <div id="local-search">
    <div class="search-dialog">
        <nav class="search-nav">
            <span class="search-dialog-title">搜索</span>
            <button class="search-close-button">
                <i class="fas fa-times"></i>
            </button>
        </nav>
        <div id="loading-database">
            <i class="fas fa-spinner fa-pulse"></i>
            <span>加载中</span>
        </div>
        <div class="search-wrap">
            <div class="search-box">
                <input class="search-box-input" placeholder="输入关键词快速查找" type="text" id="search-input" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off">
            </div>
            <div id="loading-status"></div>
            <div id="search-results"></div>
        </div>
    </div>
    <div id="search-mask"></div>
</div>
    
<link rel="stylesheet" href="/css/search/local-search.css">

    
<script src="/js/extend/search/local-search.js"></script>


     
        <div class="needEndHide" id="nav-music" onclick="acrylic.musicToggle()">
    <div id="nav-music-hoverTips">音乐已暂停</div>
    <meting-js id="7315994021" server="tencent" type="playlist" mutex="true"
        preload="none" data-lrctype="0" order="random" theme="var(--heo-main)"></meting-js>
</div>
    
    </body>
</html>
<script>const posts=["2023/06/18/大一立项爬虫/","2023/06/18/操作系统/","2023/06/08/数据库系统/","2023/06/07/低代码综测平台/","2023/06/04/有匪/","2023/05/29/明月策/","2023/05/29/北邙星梦/","2023/05/29/侠藏/","2023/05/29/天风白马/","2023/04/28/ClickHouse/","2023/03/18/从IOC到Java架构/","2023/03/18/微服务/","2023/03/18/数据库概述/","2023/03/18/数据结构/","2023/03/18/桌搭教程/","2023/03/18/算法设计与分析/","2023/03/18/系统分析与设计/","2023/03/18/面向对象建模技术/","2023/03/14/Go语言设计与实现/","2023/03/13/Git/","2023/02/10/奎桑提教学/","2023/02/10/奥恩教学/","2023/02/10/服务器部署/","2023/02/10/规则引擎/","2023/02/10/风凌夜话/","2023/02/10/青萍/","2023/02/10/巷/","2023/02/10/乱世佳人/","2023/02/10/马克思主义原理/","2023/02/04/Hertz/","2023/01/17/架构设计/","2023/01/17/草木森/","2023/01/17/计算机组成原理/","2023/01/17/鹤扶摇/","2023/01/17/泠音泛海/","2023/01/17/江城一梦/","2023/01/17/近世代数/","2023/01/17/白马遥/","2023/01/17/塑鸿/","2023/01/17/彩云辞/","2023/01/17/Java虚拟机/","2023/01/17/Web基本原理/","2023/01/17/Springboot入门/","2023/01/17/分布式/","2023/01/17/Golang/","2023/01/17/Redis/"];function toRandomPost(){ window.pjax ? pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]) : window.open('/'+posts[Math.floor(Math.random()*posts.length)], "_self"); };</script>